<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-12-01T17:11:52+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">CMU15-445 Fa23: PROJECT2 - EXTENDIBLE HASH INDEX</title><link href="https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2.html" rel="alternate" type="text/html" title="CMU15-445 Fa23: PROJECT2 - EXTENDIBLE HASH INDEX" /><published>2023-11-28T00:00:00+08:00</published><updated>2023-11-28T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2.html"><![CDATA[<h2 id="1-理解-extendible-hash">1. 理解 Extendible Hash</h2>

<ul>
  <li><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">Extendible Hashing (Dynamic approach to DBMS)</a></li>
  <li><a href="http://www.cs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing-new1.html">Emory University: Extensible Hashing</a></li>
</ul>

<p class="info">后续有条件贴上自己暗推的测例， 有需要可留言给个邮箱。</p>

<h2 id="2-task1---readwrite-page-guards">2. task#1 - Read/Write Page Guards</h2>

<p><code class="language-html highlighter-rouge">Page Guard</code> 的作用是实现一个基于 C++ 的 RAII(Resource Acquisition Is Initialization) 机制的 Page 管理类， 这个类能够通过析构或手动 <code class="language-html highlighter-rouge">Drop</code> UnpinPage 并释放相应的 RLock 或者 WLock， 能够避免后续 Extendible Hash Index 实现时由于人为对读写锁的使用失误以及忘记 UnpinPage 导致 BufferPoolManager 的页管理出错。</p>

<h3 id="21-task1-实现细节提示">2.1 task#1 实现细节提示</h3>

<p>Project Specification 特地将这几个函数的实现放在一起是有其道理的， <code class="language-html highlighter-rouge">BasicPageGuard</code> 删除了拷贝构造和拷贝赋值， 需要实现移动构造和移动赋值以及其析构函数。 这里会需要较多的代码的复用， 尤其是 <code class="language-html highlighter-rouge">Drop</code> 函数。</p>

<ul>
  <li>
    <p><code class="language-html highlighter-rouge">PageGuard(PageGuard <span class="err">&amp;&amp;</span>that)</code>: Move constructor.</p>

    <blockquote>
      <p>对于 Basic 版本直接对 <code class="language-html highlighter-rouge">page_</code>， <code class="language-html highlighter-rouge">bpm_</code>， <code class="language-html highlighter-rouge">is_dirty</code> 进行赋值， 出于习惯将右值 <code class="language-html highlighter-rouge">that</code> 中的指针都置为 <code class="language-html highlighter-rouge">nullptr</code>。 而 Upgrade 版本则可方便地通过 <code class="language-html highlighter-rouge">std::move</code> 赋值 <code class="language-html highlighter-rouge">guard_</code>。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-html highlighter-rouge">operator=(PageGuard <span class="err">&amp;&amp;</span>that)</code>: Move operator.</p>

    <blockquote>
      <p>这里需要注意两点： 1. <code class="language-html highlighter-rouge">that</code> 是否为自身； 2. 如果当前的 <code class="language-html highlighter-rouge">guard_.page_</code> 或 <code class="language-html highlighter-rouge">page_</code> 非 <code class="language-html highlighter-rouge">nullptr</code>， 需要先 <code class="language-html highlighter-rouge">Drop</code> 已存储在当前 PageGuard 中的 Page。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-html highlighter-rouge">Drop()</code>: Unpin and/or unlatch.</p>

    <blockquote>
      <p>对 Basic 版本， 在 Page 有值的情况下需要调用 <code class="language-html highlighter-rouge">UnpinPage</code> 进行资源释放。 而对于 Upgrade 版本则需要释放相应的读写锁并调用 Basic 的 <code class="language-html highlighter-rouge">Drop</code>。 我个人还添加了一个标志位表示是否已经调用过 <code class="language-html highlighter-rouge">Drop</code>， 主要是避免后续手动调用 <code class="language-html highlighter-rouge">Drop</code> 函数可能出现的重复调用所引起的问题。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-html highlighter-rouge">~PageGuard()</code>: Destructor.</p>

    <blockquote>
      <p>直接调用 <code class="language-html highlighter-rouge">Drop</code> 就行啦！</p>
    </blockquote>
  </li>
</ul>

<p>至于下面这两个函数则让我面目狰狞， 给的注释说的非常隐晦， 要保证在 Upgrade 的过程中 Page 不被 Evict， 又说 BasicPageGuard 在调用这个函数后会 invalid。 具体细节参考下一小节的 <a href="#pageguardtestbpmtest">PageGuardTest.BPMTest</a> 调试。</p>

<ul>
  <li><code class="language-html highlighter-rouge">UpgradeRead()</code>: Upgrade to a ReadPageGuard</li>
  <li><code class="language-html highlighter-rouge">UpgradeWrite()</code>: Upgrade to a WritePageGuard</li>
</ul>

<p>而下面这四个函数也是清晰的， 对有 Read 和 Write 需求的就相应的给上读/写锁， 但这里考虑到 WritePageGuard 可能会被更改， 我个人认为需要在 Fetch 的同时将相应的 Page 设置为 <em><strong>dirty</strong></em>。</p>

<ul>
  <li><code class="language-html highlighter-rouge">FetchPageBasic(page_id_t page_id)</code></li>
  <li><code class="language-html highlighter-rouge">FetchPageRead(page_id_t page_id)</code></li>
  <li><code class="language-html highlighter-rouge">FetchPageWrite(page_id_t page_id)</code></li>
  <li><code class="language-html highlighter-rouge">NewPageGuarded(page_id_t *page_id)</code></li>
</ul>

<h3 id="22-task1-的调试与解析">2.2 task#1 的调试与解析</h3>

<h4 id="pageguardtestbpmtest">PageGuardTest.BPMTest</h4>

<p>Gradescope 中的 <strong>PageGuardTest.BPMTest</strong> 报错如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/autograder/source/bustub/test/storage/grading_page_guard_test.cpp:222: Failure
Expected equality of these values:
  2
  page1copy-&gt;GetPinCount<span class="o">()</span>
    Which is: 3
</code></pre></div></div>

<p>我自己模仿所给范例写了一些本地的测试都是通过的， 唯一感觉有些不确定的是 <code class="language-html highlighter-rouge">BasicPageGuard::UpgradeRead()</code> 和 <code class="language-html highlighter-rouge">BasicPageGuard::UpgradeWrite()</code> 这两个函数， 对于他们的实现细节我不是很清楚。 为了确定 Bug， 我用了 <code class="language-html highlighter-rouge">LOG_DEBUG(...)</code> 打印所有与 <strong>pinCount</strong> 变更相关的信息， 再次提交 Gradescope 后得到了这样的输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:210:NewPageGuarded] DEBUG - new basic page guard
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:61:NewPage] DEBUG - Create new page, page_id 0, pinCount <span class="o">[</span>1]
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 0 from buffer, pinCount from <span class="o">[</span>1] to <span class="o">[</span>2]
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:23:Drop] DEBUG - page_id 0, pinCount from <span class="o">[</span>2] to <span class="o">[</span>1]
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:186:FetchPageBasic] DEBUG - fetch basic page
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 0 from buffer, pinCount from <span class="o">[</span>1] to <span class="o">[</span>2]
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:23:Drop] DEBUG - page_id 0, pinCount from <span class="o">[</span>2] to <span class="o">[</span>1]
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:210:NewPageGuarded] DEBUG - new basic page guard
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:61:NewPage] DEBUG - Create new page, page_id 1, pinCount <span class="o">[</span>1]
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 1 from buffer, pinCount from <span class="o">[</span>1] to <span class="o">[</span>2]
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:192:FetchPageRead] DEBUG - fetch <span class="nb">read </span>page
2023-11-27 08:49:55 <span class="o">[</span>buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 1 from buffer, pinCount from <span class="o">[</span>2] to <span class="o">[</span>3]
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:58:UpgradeRead] DEBUG - Upgrade BasicPageGuard to ReadPageGuard, page_id 1, pinCount from <span class="o">[</span>2] to <span class="o">[</span>3]
/autograder/source/bustub/test/storage/grading_page_guard_test.cpp:222: Failure
Expected equality of these values:
  2
  page1copy-&gt;GetPinCount<span class="o">()</span>
    Which is: 3

2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:99:~ReadPageGuard] DEBUG - ReadPageGuard deconstructor Drop
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:86:Drop] DEBUG - <span class="nb">read </span>page guard is dropped.
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:23:Drop] DEBUG - page_id 1, pinCount from <span class="o">[</span>3] to <span class="o">[</span>2]
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:50:~BasicPageGuard] DEBUG - BasicPageGuard deconstructor Drop
2023-11-27 08:49:55 <span class="o">[</span>page_guard.cpp:23:Drop] DEBUG - page_id 1, pinCount from <span class="o">[</span>2] to <span class="o">[</span>1]
</code></pre></div></div>

<p>可以看到错误就发生在 <code class="language-html highlighter-rouge">BasicPageGuard</code> 转为 <code class="language-html highlighter-rouge">ReadPageGuard</code> 的过程中， 按照我之前的理解， 理应 Upgrade 应当增加一次对相应的 Page 的访问， 所以最开始的代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeRead</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ReadPageGuard</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageRead</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但按照所给测例的输出， <code class="language-html highlighter-rouge">BasicPageGuard</code> 应当在 Upgrade 之后释放原有的资源， 这意味着 <code class="language-html highlighter-rouge">BasicPageGuard</code> 在 Upgrade 之后无法再通过 Upgrade 返回一个 <code class="language-html highlighter-rouge">Read/WritePageGuard</code>， 在 Upgrade 完成后需要手动调用 <code class="language-html highlighter-rouge">BasicPageGuard::Drop()</code> 释放原有的资源， 当然这个猜想在所给代码注释中得到了印证：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  * The protected page is not evicted from the buffer pool during the upgrade,
  * and the basic page guard should be made invalid after calling this function.
  */</span>
</code></pre></div></div>

<p>至于为什么用 <code class="language-html highlighter-rouge">FetchPageRead</code> 而不是直接返回一个全新的 <code class="language-html highlighter-rouge">ReadPageGuard</code>， 主要是考虑到在 Upgrade 过程中会 <strong>Drop</strong> 原有的 <strong>Basic Guard</strong>， 而 Upgrade 需要保证这个 Page 不会被缓存池的 LRU-K 算法 Evict， 那需要保证这个 Page 处于一个 Pin 的状态。 Fetch 可以增加一次 <code class="language-html highlighter-rouge">pinCount</code>, 可以与 <code class="language-html highlighter-rouge">Drop</code> 中调用的 <code class="language-html highlighter-rouge">UnpinPage</code> 导致 <code class="language-html highlighter-rouge">pinCount</code> 的一次减少抵消。</p>

<p>后续提交通过了 <strong>BMPTest</strong> 证明了我的猜想。</p>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// reference code</span>
<span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeRead</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ReadPageGuard</span> <span class="p">{</span>
  <span class="n">ReadPageGuard</span> <span class="n">read_guard</span> <span class="o">=</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageRead</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
  <span class="n">Drop</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">read_guard</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeWrite</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">WritePageGuard</span> <span class="p">{</span>
  <span class="n">WritePageGuard</span> <span class="n">write_guard</span> <span class="o">=</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageWrite</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
  <span class="n">Drop</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">write_guard</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-task2---extendible-hash-table-pages">3. task#2 - Extendible Hash Table Pages</h2>

<p>相较往年 23Fall 版本增加了 Header Page， 但整体思路应当是一致的， 需要注意的是我们不能更改任何 private 和 public 域中的函数和变量， 在每个头文件的顶部说明规定了这些 Page 的结构和大小。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Header page format:
<span class="p">  ---------------------------------------------------</span>
 | DirectoryPageIds(2048) | MaxDepth (4) | Free(2044)
<span class="p">  ---------------------------------------------------
</span>
 Directory page format:
<span class="p">  --------------------------------------------------------------------------------------</span>
 | MaxDepth (4) | GlobalDepth (4) | LocalDepths (512) | BucketPageIds(2048) | Free(1528)
<span class="p">  --------------------------------------------------------------------------------------
</span>
 Bucket page format:
<span class="p">  ----------------------------------------------------------------------------</span>
 | METADATA | KEY(1) + VALUE(1) | KEY(2) + VALUE(2) | ... | KEY(n) + VALUE(n)
<span class="p">  ----------------------------------------------------------------------------
</span>
 Metadata format (size in byte, 8 bytes in total):
<span class="p">  --------------------------------</span>
 | CurrentSize (4) | MaxSize (4)
<span class="p">  --------------------------------
</span></code></pre></div></div>

<blockquote>
  <p>这里我偷偷改了 <code class="language-html highlighter-rouge">GetDirectoryPageId</code> 的返回类型， 不然和 <code class="language-html highlighter-rouge">directory_page_ids_</code> 数组的类型不统一。</p>
</blockquote>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">ExtendibleHTableHeaderPage</span><span class="o">::</span><span class="n">GetDirectoryPageId</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">directory_idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">page_id_t</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="31-task2-实现细节提示">3.1 task#2 实现细节提示</h3>

<h4 id="hash-table-header-page">Hash Table Header Page</h4>

<ul>
  <li><strong><code class="language-html highlighter-rouge">Init</code></strong>： 需要将 <code class="language-html highlighter-rouge">directory_page_ids_</code> 数组中的 page_id 都初始化为 <code class="language-html highlighter-rouge">INVALID_PAGE_ID</code>， <code class="language-html highlighter-rouge">max_depth</code> 是有它的上限的。</li>
  <li><strong><code class="language-html highlighter-rouge">HashToDirectoryIndex</code></strong>： 就比较阴险了， 对于 header 而言， 要获取 directory 的索引值， 是通过 32 位 Hash 的 MSB 实现的。 设想 <code class="language-html highlighter-rouge">max_depth</code> 为零， 32 位 Hash 右移 32 位仍是其本身。 因而需要特殊处理 <code class="language-html highlighter-rouge">max_depth</code> 为零的情况， 应返回一个 0 值。</li>
</ul>

<h4 id="hash-table-directory-page">Hash Table Directory Page</h4>

<ul>
  <li><strong><code class="language-html highlighter-rouge">Init</code></strong>： 同样需要初始化 <code class="language-html highlighter-rouge">local_depth_</code> 以及 <code class="language-html highlighter-rouge">bucket_page_id_</code> 这两个数组。 <code class="language-html highlighter-rouge">local_depth_</code> 以及 <code class="language-html highlighter-rouge">global_depth_</code> 需要初始化为 0。</li>
  <li><strong><code class="language-html highlighter-rouge">HashToBucketIndex</code></strong>： 有个比较巧妙的办法就是直接用 hash 值对 <code class="language-html highlighter-rouge">Size()</code> 取模， 这和使用 <code class="language-html highlighter-rouge">GetGlobalDepthMask</code> 是一样的。</li>
  <li>
    <p><strong><code class="language-html highlighter-rouge">GetSplitImageIndex</code></strong>： 主要得理解 Extendible Hash Index 的 Split 的思路， directory 部分扩大事实上就是左移了一个 global depth， 这导致 directory 数量变为原来的两倍。 例如 <code class="language-html highlighter-rouge">00</code> 会分裂为 <code class="language-html highlighter-rouge">000</code> 和 <code class="language-html highlighter-rouge">100</code> 但二者都指向同一个 bucket。 所以我们只需要得到当前 bucket 并对其 global_depth 位取反， 就能得到镜像的 bucket 的索引值。</p>

    <div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">ExtendibleHTableDirectoryPage</span><span class="o">::</span><span class="n">GetSplitImageIndex</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">bucket_idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint32_t</span> <span class="p">{</span>
  <span class="c1">// Ensure the bucket local depth has increased!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">local_depths_</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">bucket_idx</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">local_depths_</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-html highlighter-rouge">IncrGlobalDepth</code></strong>： 结合上个函数的解析， 如果理解了 Extendible Hash Index 的实现思路， 增加 global_depth 要做的就是拷贝一份原有的 buckets， 如 bucket_idx <code class="language-html highlighter-rouge">00</code> 分裂为 <code class="language-html highlighter-rouge">000</code> 和 <code class="language-html highlighter-rouge">100</code>， 把 <code class="language-html highlighter-rouge">00</code> 的内容拷贝一份到 <code class="language-html highlighter-rouge">100</code> 中即可。</p>

    <div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">ExtendibleHTableDirectoryPage</span><span class="o">::</span><span class="n">IncrGlobalDepth</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">global_depth_</span> <span class="o">&lt;</span> <span class="n">HTABLE_DIRECTORY_MAX_DEPTH</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">prev_expansion_num</span> <span class="o">=</span> <span class="n">Size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">prev_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">prev_expansion_num</span><span class="p">;</span> <span class="n">prev_idx</span> <span class="o">&lt;</span> <span class="n">prev_expansion_num</span><span class="p">;</span>
      <span class="n">prev_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curr_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">local_depths_</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_depths_</span><span class="p">[</span><span class="n">prev_idx</span><span class="p">];</span>
    <span class="n">bucket_page_ids_</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket_page_ids_</span><span class="p">[</span><span class="n">prev_idx</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">global_depth_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-html highlighter-rouge">CanShrink</code></strong>： 检查所有的 bucket 的 local_depth， 如果都比 global depth 要小， 就可以缩小 global_depth。 这个函数在后续 Merge 的时候需要用到。</li>
</ul>

<p>其他的该加加该减减就行， 不用想太多， 就是纯粹的增减！</p>

<h4 id="hash-table-bucket-page">Hash Table Bucket Page</h4>

<p>讲道理开始一点思路没有， 我看到有人在 <a href="https://zhuanlan.zhihu.com/p/664444839">知乎 - zihao 彼方 CMU15-445(2023FALL)-Project#2: Extendible Hash Index</a> 发了篇文章， 里面提到需要对 bucket 中的 <code class="language-html highlighter-rouge">array_</code> 数组全部初始化为一个特殊值 ， <strong>坑爹啊！！！</strong> 这导致我后续花了将近 6 个小时找 <strong>GrowShrinkTest</strong> 的错误。</p>

<p>实际上 bucket 的实现非常简洁， 我后来在看 <code class="language-html highlighter-rouge">PrintBucket</code> 的实现的时候得到了启发， BUSTUB 直接访问的前 <code class="language-html highlighter-rouge">size_</code> 个元素。 说明每次 <code class="language-html highlighter-rouge">Insert</code> 的时候利用 <code class="language-html highlighter-rouge">size_</code> 可以对数组进行尾部插入， 这是因为 <code class="language-html highlighter-rouge">size_</code> 始终指向下一个插入的位置。而每次 <code class="language-html highlighter-rouge">Remove</code> 的时候只用 <code class="language-html highlighter-rouge">size_</code> 指向当前数组的尾部数据 (人话就是 <code class="language-html highlighter-rouge">size_ -= 1</code>)， 让这个尾部数据填充到 <code class="language-html highlighter-rouge">RemoveAt</code> 的那个 bucket_idx 位置即可。</p>

<p>我们无需对数组进行初始化等操作， <code class="language-html highlighter-rouge">size_</code> 表示当前的数据大小可以很好的控制访问权限。</p>

<h3 id="32-task2-的调试与解析">3.2 task#2 的调试与解析</h3>

<h4 id="growshrinktest">GrowShrinkTest</h4>

<p>对 Bucket Page 理解不到位， 重构后能够通过该测例。</p>

<h2 id="4-task3---extendible-hashing-implementation">4. task#3 - Extendible Hashing Implementation</h2>

<p>感觉没必要细说， 但需要写一下踩过的坑以及记录一些实现相关的细节。</p>

<blockquote>
  <p>大家真没辙了参考这位大佬 21 年实现的版本， <a href="https://github.com/epis2048/cmu_15445_2021/tree/ghess/p2-refinement">cmu15-445/2021</a>， 核心与框架都是一致的。</p>
</blockquote>

<h3 id="41-task3-实现细节提示">4.1 task#3 实现细节提示</h3>

<p>这里实现的时候需要考虑 <code class="language-html highlighter-rouge">BasicPageGuard</code>， <code class="language-html highlighter-rouge">ReadPageGuard</code>， <code class="language-html highlighter-rouge">WritePageGuard</code> 的使用场景。 一般来说， 只有需要通过 <code class="language-html highlighter-rouge">NewPageGuarded</code> 获取新 Page 才会用到 <code class="language-html highlighter-rouge">BasicPageGuard</code>， 之后都会通过 Upgrade 函数将这个获取到的 Page 加上读写锁。 使用 PageGuard 原则就是看是否后续操作会产生对数据的更改， 如果不会更改就尽量使用 Read， 并在适当的时候通过 <code class="language-html highlighter-rouge">Drop</code> 函数提前释放相关的读写锁， 以提高并行效率。</p>

<h4 id="migrateentries">MigrateEntries</h4>

<p>我相信很多人看到这个函数是懵的， 这个函数究竟什么作用根本没有提示。 这个函数和 <code class="language-html highlighter-rouge">UpdateDirectoryMapping</code> 函数都是用在 <strong>Split Bucket</strong> 中的。 试想有一个 bucket_idx 为 <code class="language-html highlighter-rouge">00</code> 的 bucket 存储了两个 KV 数据， 在我们增加 global_depth 和 local_depth 之后， 我们需要将 bucket_idx <code class="language-html highlighter-rouge">00</code> 中的数据填充到新的 <code class="language-html highlighter-rouge">000</code>(原 <code class="language-html highlighter-rouge">00</code>) 和 <code class="language-html highlighter-rouge">100</code> 这两个 bucket， 此时就要用到 <code class="language-html highlighter-rouge">MigrateEntries</code> 函数。</p>

<p>首先将原有数据拷贝出来， 这里需要注意的是， 如果使用 <code class="language-html highlighter-rouge">ExtendibleHTableBucketPage<span class="nt">&lt;K</span><span class="err">,</span> <span class="na">V</span><span class="err">,</span> <span class="na">KC</span><span class="nt">&gt;</span>::EntryAt</code> 函数会有问题， 我们无法对一个 const 引用进行拷贝构造。 解决办法就是单独用 <code class="language-html highlighter-rouge">KeyAt</code> 和 <code class="language-html highlighter-rouge">ValueAt</code>配合 <code class="language-html highlighter-rouge">std::make_pair</code> 构造一个新的 KV。</p>

<blockquote>
  <p>可以自己尝试用 LOG_DEBUG 看看结果， 不出意外的话 <code class="language-html highlighter-rouge">copied</code> 的 KV 应都是 0 值。</p>
</blockquote>

<p>之后根据新的 local_depth 将拷贝的数据按照新的 bucket_idx 插入 old_bucket 或 new_bucket。</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">V</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">KC</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">DiskExtendibleHashTable</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;::</span><span class="n">MigrateEntries</span><span class="p">(</span><span class="n">ExtendibleHTableBucketPage</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">old_bucket</span><span class="p">,</span>
                                                       <span class="n">ExtendibleHTableBucketPage</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">new_bucket</span><span class="p">,</span>
                                                       <span class="kt">uint32_t</span> <span class="n">new_bucket_idx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">local_depth_mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Get valid items in old bucket */</span>
  <span class="kt">uint32_t</span> <span class="n">old_bucket_size</span> <span class="o">=</span> <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">copied</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">old_bucket_size</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">old_bucket_size</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">copied</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">KeyAt</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">ValueAt</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="cm">/* reset old bucket */</span>
  <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">(</span><span class="n">bucket_max_size_</span><span class="p">);</span>
  <span class="n">BUSTUB_ASSERT</span><span class="p">(</span><span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"old bucket should be reset"</span><span class="p">);</span>

  <span class="cm">/* Do rehashing */</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">old_bucket_size</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">target_bucket_idx</span> <span class="o">=</span> <span class="n">Hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">local_depth_mask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target_bucket_idx</span> <span class="o">==</span> <span class="n">new_bucket_idx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_bucket</span><span class="o">-&gt;</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">cmp_</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">cmp_</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="updatedirectorymapping">UpdateDirectoryMapping</h4>

<p>这又是做什么？ 可以想象的是， 有时候我们有很多 bucket_idx 指向的是同一个 page_id， 如果不清楚请参考 <a href="#1-理解-extendible-hash">理解-extendible-hash</a> 我们在 Split Bucket 完成后， 需要让原来指向 split_bucket_idx 的那些 buckets 重新分配指向， 要么是 split_bucket_idx， 要么是 image_bucket_idx， 并且都需要设定新的 local_depth。</p>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">V</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">KC</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">DiskExtendibleHashTable</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;::</span><span class="n">UpdateDirectoryMapping</span><span class="p">(</span><span class="n">ExtendibleHTableDirectoryPage</span> <span class="o">*</span><span class="n">directory</span><span class="p">,</span>
                                                               <span class="kt">uint32_t</span> <span class="n">new_bucket_idx</span><span class="p">,</span> <span class="n">page_id_t</span> <span class="n">new_bucket_page_id</span><span class="p">,</span>
                                                               <span class="kt">uint32_t</span> <span class="n">new_local_depth</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">local_depth_mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">msb_diff</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">new_local_depth</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">new_bucket_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">msb_diff</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="n">msb_diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetBucketPageId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_bucket_page_id</span><span class="p">);</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetLocalDepth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_local_depth</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">new_bucket_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">directory</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">msb_diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetBucketPageId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_bucket_page_id</span><span class="p">);</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetLocalDepth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_local_depth</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-task2-的调试与解析">4.2 task#2 的调试与解析</h3>

<h4 id="getvalue-和-remove">GetValue 和 Remove</h4>

<p>这两个函数的接口都是 <code class="language-html highlighter-rouge">key</code>， 说明有时候可能这个 <code class="language-html highlighter-rouge">key</code> 是不存在于 BufferPool 的， 我们需要在获取 directory index 的时候就可以判断， 如果 directory_idx 为 <code class="language-html highlighter-rouge">INVALID_PAGE_ID</code> 可以提早返回结果， 因为这个 <code class="language-html highlighter-rouge">key</code> 并不存在。</p>

<p>另外注意 Fall 2023 版本是 unique-key， 不存在一个 key 对应多个值的情况。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">GetValue</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">Transaction</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">Remove</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">Transaction</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="insert">Insert</h4>

<p><code class="language-html highlighter-rouge">Insert</code> 中在 directory 的 page_id 为 <code class="language-html highlighter-rouge">INVALID_PAGE_ID</code> 时调用 <code class="language-html highlighter-rouge">InsertToNewDirectory</code>， 在 <code class="language-html highlighter-rouge">InsertToNewDirectory</code> 中调用 <code class="language-html highlighter-rouge">InsertToNewBucket</code>， 这是这两个函数的使用方式。</p>

<ul>
  <li>如果发现 directory 索引超过了 header 的最大限制， 需要直接返回 false。</li>
  <li>判断当前需要插入的 bucket 的情况， 如果没有满则可以直接调用 bucket 的 Insert 函数， 如果满了则调用 <code class="language-html highlighter-rouge">SplitInsert</code> 函数。</li>
</ul>

<h4 id="splitinsert">SplitInsert</h4>

<p>这个函数不进行任何插入操作， 插入操作仅在 <code class="language-html highlighter-rouge">Insert</code> 中进行， 因而在该函数完成对 global_depth 和 local_depth 的扩容后， 需要再次调用 <code class="language-html highlighter-rouge">Insert</code> 完成数据插入。</p>

<p><strong>需要注意以下几点</strong>：</p>

<ol>
  <li>当前的 bucket_idx 获取的 local_depth 已经与传入的 <code class="language-html highlighter-rouge">directory_max_depth_</code> 相等了， 说明 directory 已经扩容到最大， bucket 也扩容到最多， 无法继续扩容， 直接返回 <code class="language-html highlighter-rouge">false</code>。</li>
  <li>如果上述条件不满足， 说明还可以继续扩容， 如果 local_depth 已经和 global_depth 相等了， 先增加 global_depth。</li>
  <li>增加 local_depth。</li>
  <li>调用 <code class="language-html highlighter-rouge">MigrateEntries</code> 以及 <code class="language-html highlighter-rouge">UpdateDirectoryMapping</code>（有两次） 完成扩容。</li>
  <li>重新尝试 <code class="language-html highlighter-rouge">Insert</code>。</li>
</ol>

<h4 id="merge">Merge</h4>

<p>需要注意的是 Recursive Merge， 因为很可能一次 Merge 后还能够接着下一次 Merge 直到最小单位。 由于 Merge 的时候会将当前的 bucket 指向 image bucket 以达到 Merge 的目的， 所以如果要递归进行 Merge， 就要以 image_bucket_idx 和 new_local_depth 生成新的 bucket_idx 进行下次 Merge 的调用。</p>

<p><strong>另外注意 Merge 的几个先后条件</strong>：</p>

<ol>
  <li>local_depth 为 0， 说明已经到达 Merge 的极限了， 直接返回。</li>
  <li>当前的 bucket_idx 得到的 local_depth 和镜像的 image_bucket_idx 得到的 image_local_depth 不一致， 深度不一致则不能 Merge， 也需要直接返回。</li>
  <li>我们需要在 Merge 的过程中对 bucket_idx 再进行一次 <code class="language-html highlighter-rouge">IsEmpty</code> 的判断， 如果非空直接返回。 这是因为在 <code class="language-html highlighter-rouge">Remove</code> 函数中我们判断 bucket 为空后， 释放 latch 的瞬间这个 latch 被 Insert 拿走了， 这个 bucket 可能又被塞入了新的值， 后续 Merge 函数获取到锁的时候就可能看到的是这个新值了。</li>
  <li>删除 bucket_idx 对应的 Page 后要将之前所有指向这个 bucket_idx 存储的 Page 的那些 buckets 重新直线新的 image_bucket 对应的 Page 以及设置新的 local_depth。</li>
  <li>需要循环调用 <code class="language-html highlighter-rouge">CanShrink</code> 缩小 global_depth。</li>
</ol>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="cm">/* recursive merge */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">directory_write_page</span><span class="o">-&gt;</span><span class="n">GetGlobalDepth</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">next_bucket_idx</span> <span class="o">=</span> <span class="n">image_bucket_idx</span> <span class="o">&amp;</span> <span class="n">new_local_depth</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">next_image_bucket_idx</span> <span class="o">=</span> <span class="n">directory_write_page</span><span class="o">-&gt;</span><span class="n">GetSplitImageIndex</span><span class="p">(</span><span class="n">next_bucket_idx</span><span class="p">);</span>


    <span class="n">Merge</span><span class="p">(</span><span class="n">directory_idx</span><span class="p">,</span> <span class="n">next_bucket_idx</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
    <span class="n">Merge</span><span class="p">(</span><span class="n">directory_idx</span><span class="p">,</span> <span class="n">next_image_bucket_idx</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="5-task4--concurrency-control">5. task#4  Concurrency Control</h2>

<p>实现的时候给 <code class="language-html highlighter-rouge">Insert</code>， <code class="language-html highlighter-rouge">Remove</code> 以及自定义的一些会更改 directory 或 bucket 的函数都加上了一把 latch， 在 return 或进入另一个函数前释放 latch， 能完美通过测试。</p>

<h2 id="6-写在最后">6. 写在最后</h2>

<p>不枉这一个星期的努力， P2 顺利收官了！</p>

<p>虽然最后成功通过了 P2 的所有测试， 但整个 Project 并没有完全独立完成， 设计上也有参考前述的 2021 年的 Extendible Hash Index 的实现。 除了所给函数没注释导致对其功能的理解上的缺失， 还有阅读 Specification 和代码注释不仔细， 对 Extendible Hash Index 的原理以及概念不熟悉不透彻。 对于 Debug 目前能用的就是 <code class="language-html highlighter-rouge">LOG_DEBUG</code> 以及配置 VSCode 的 CodeLLDB 实现图形化调试， 一旦遇到多线程的情况， 大多只能依赖 <code class="language-html highlighter-rouge">LOG_DEBUG</code>， 可想而知 P4 将是个令人望而生畏的任务。</p>

<div align="center">
    <img src="/norobots/images/2023-11-28-cmu15445-fa23-p2/p2-leaderboard-rank.png" alt="Project2 LeaderBoard Rank, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Project2 LeaderBoard Rank, HangX-Ma</u></font>
</div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cmu15-445" /><summary type="html"><![CDATA[学习 CMU15-445 Fall 2023， 该章与 Extendible Hash Index 相关， 介绍 Extendible Hash 的原理与实施细节]]></summary></entry><entry><title type="html">Cpp-Quiz</title><link href="https://hangx-ma.github.io/2023/11/14/cpp-details.html" rel="alternate" type="text/html" title="Cpp-Quiz" /><published>2023-11-14T00:00:00+08:00</published><updated>2023-11-14T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/11/14/cpp-details</id><content type="html" xml:base="https://hangx-ma.github.io/2023/11/14/cpp-details.html"><![CDATA[<p>Google 搜到了 Knatten 大佬开发的 <a href="https://github.com/knatten/cppquiz">cppquiz</a> 题库， 题库网址是 <a href="http://cppquiz.org">http://cppquiz.org</a>。 很多问题都是依据比较新的 C++17 的标准出的， 短小精悍而且有详细的解析， 很有当时做 Rust Quiz 的感觉， 但这个题库的使用体验可好多了， 能很好考察梳理自己对 C++ 语法以及执行细节的掌握程度！</p>

<blockquote>
  <p>解析的依据是 <a href="https://timsong-cpp.github.io/cppwp/">Working Draft: Programming Languages — C++</a></p>
</blockquote>

<h2 id="question-list">Question List</h2>

<p>不贴源代码， 只记录问题解析中的重点。</p>

<h3 id="question-14"><a href="https://cppquiz.org/quiz/question/14?result=OK&amp;answer=abcBCA&amp;did_answer=Answer">Question 14</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/basic.start.dynamic#4">basic.start.dynamic</a> 做了相关的解释， 对于 <strong>non-local</strong>， <strong>non-inline</strong> 的 <strong>static storage</strong> 变量， 其初始化过程是 dynamic 的， 要么在 <code class="language-html highlighter-rouge">main()</code> 之前， 或者推迟到进入 <code class="language-html highlighter-rouge">main()</code> 函数之后但先于任何在 <code class="language-html highlighter-rouge">main()</code> 函数中的构造函数。 而具备 <strong>static storage</strong> 属性的变量， 如全局变量， 声明为 static 的变量的析构发生在正常变量之后， 且 <strong>先构造的后释放(reverse order)</strong>。</p>

<h3 id="question-16"><a href="https://cppquiz.org/quiz/question/16?result=OK&amp;answer=abBA&amp;did_answer=Answer">Question 16</a></h3>

<p>成员函数的初始化在构造函数之前， 析构函数在任何成员函数析构之前。</p>

<h3 id="question-48"><a href="https://cppquiz.org/quiz/question/48?result=OK&amp;answer=z&amp;did_answer=Answer">Question 48</a></h3>

<p>TODO</p>

<h3 id="question-126"><a href="https://cppquiz.org/quiz/question/126?result=OK&amp;answer=11&amp;did_answer=Answer">Question 126</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.unqual#13">basic.lookup.unqual</a> 做了相关解释， 其本意表示 class 或 struct 中的静态成员变量会优先使用定义在该 class 或 struct 中的静态成员函数， 即便外部有同名的函数存在。</p>

<h3 id="question-312"><a href="https://cppquiz.org/quiz/question/312?result=CE&amp;answer=&amp;did_answer=Answer">Question 312</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/class.access.base#1">class.access.base</a>，<a href="https://timsong-cpp.github.io/cppwp/n4659/class.access.base#2">class.access.base</a> 介绍了继承相关的内容。 class 和 struct 在多继承中的默认继承类型和 class 以及 struct 默认成员函数和成员变量类型是一致的， class 中默认的都是 <code class="language-html highlighter-rouge">private</code> 而 struct 都默认 <code class="language-html highlighter-rouge">public</code>。</p>]]></content><author><name>HangX-Ma</name></author><category term="C++" /><summary type="html"><![CDATA[做 C++ Quiz 遇到一些有意思的语法细节记录，钻牛角尖的那种。]]></summary></entry><entry><title type="html">cs61b Proj3-BYoW</title><link href="https://hangx-ma.github.io/2023/10/21/cs61b-proj3.html" rel="alternate" type="text/html" title="cs61b Proj3-BYoW" /><published>2023-10-21T00:00:00+08:00</published><updated>2023-10-21T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/10/21/cs61b-proj3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/10/21/cs61b-proj3.html"><![CDATA[<p><strong>Github Repo:</strong> <a href="https://github.com/HangX-Ma/cs61b-sp21">https://github.com/HangX-Ma/cs61b-sp21</a></p>

<p>在实现这个项目之前自己先尝试摸索着做了一些工作， 构思了一下工程结构， 但确实由于项目经验较少， 很难做到 Josh Hug 课上说的 Strategic Programming， 刚开始就对 <code class="language-html highlighter-rouge">interactWithInputString</code> 的字符串处理部分重构了多次。 既然没办法避免 Tactical Programming， 我的想法是先看看别人实现的文件架构以及构建框架， 这样能够有个比较清晰的实现脉络。</p>

<p>我参考的是 <a href="https://github.com/YinY1/CS61B-sp21">YinY1</a> 的 Proj3 实现， 但我认为具体的细节是需要自己去思考的， 文件结构的设计已经给了我足够的启发。 这篇文章就详细介绍一下地图的生成， 这块难度比较高， Phase2 关于游戏交互的我就完成了基础功能没啥好说的。</p>

<blockquote>
  <p>最近有些焦虑， 感受到末尾保研和前位保研的差距了， 同届的同学已经参加过之江实验室的项目， 以及百度 Paddle 的夏令营， 现在在延续他的夏令营开源项目担任助教。 而对自己来说， 规划的一整个研一时间和半个研二时间是拿来补基础课程的， 毕竟平时还有实验室任务。 不过人家确实也很认真， 每天留到快 23:00 才回宿舍。 且不说了， 之后还有一门数据库的课程要补上。</p>
</blockquote>

<h2 id="1-文件目录">1. 文件目录</h2>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>byow
  ├─Core
  │  │  Engine.java
  │  │  Main.java
  │  │  Pair.java
  │  │  Point.java
  │  │  Property.java
  │  │  RandomUtils.java
  │  │  Utils.java
  │  │  World.java
  │  │
  │  ├─Avatar
  │  │      Avatar.java
  │  │      Tofu.java
  │  │
  │  ├─HUD
  │  │      Frame.java
  │  │
  │  └─Maps
  │          Road.java
  │          Room.java
  │          Wall.java
  │
  ├─InputDemo
  │      DemoInputSource.java
  │      InputSource.java
  │      KeyboardInputSource.java
  │      RandomInputSource.java
  │      StringInputDevice.java
  │
  ├─lab12
  │      BoringWorldDemo.java
  │      HexWorld.java
  │      project3prep.md
  │      RandomWorldDemo.java
  │
  ├─lab13
  │      MemoryGame.java
  │
  ├─Networking
  │      BYOWClient.java
  │      BYOWServer.java
  │
  └─TileEngine
          TERenderer.java
          TETile.java
          Tileset.java
</code></pre></div></div>

<h2 id="2-phase1-world-generation">2. Phase1: World Generation</h2>

<p>Phase1 要求生成随机的地图， 地图要求由不同大小的 Rooms 以及联通这些 Room 的通道构成。 一般的实现办法就是生成多个 Rooms 的区块， 然后将这些 Rooms 通过 Path 联通起来， 而如何生成 Path 真的非常考验人。 我自己尝试过用类似 Hexagon World 中扫描的方式， 让每个 Rooms 紧贴着生成， 也尝试过生成 Rooms 后用生成迷宫的方式去生成 Path， 但这些方法都不能很好的做到和 Josh Hug 给出的样例类似。</p>

<p>花了一天的时间考虑算法， 闭门造车真的不行， 有幸刷到了这样一篇知乎 <a href="https://zhuanlan.zhihu.com/p/30724817">【游必有方】一种 RogueLike 地图生成算法</a> 作者对原文 <a href="https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/">Rooms and Mazes: A Procedural Dungeon Generator</a> 进行了简化和翻译。 第一次了解到这种 2D 场景的类似的游戏被称为 <strong>RogueLike Game</strong>， 文章介绍的内容和 Proj3 所介绍的需求非常类似。</p>

<p>生成地图的主要步骤：</p>

<ul>
  <li>在给定大小的地图区域内随机生成一些房间；</li>
  <li>将除房间以外的区域用随机生成的迷宫填充；</li>
  <li>将所有房间和迷宫通过少数节点连接起来；</li>
  <li>删除不必要的迷宫死胡同，降低地图复杂度。</li>
</ul>

<p>对我来说链接迷宫和房间并降低地图复杂度这块是最为困惑的和不解的， 迫不及待想要了解作者的巧妙构思了。 其实这块自然而然会想到课上介绍的 Union 的概念， 尤其是一提到联通路径的时候， 就会想到 Prim 和 Kruskal 这两个最小生成树算法。 <a href="https://www.cnblogs.com/shiroe/p/15506909.html">【UE4 C++】迷宫生成——DFS、Prim、Kruskal算法实现</a> 这篇文章介绍了几种算法在生成 Maze 时的区别， 当时我自己实现了 kruskal 的迷宫， 但效果和课程所给的相去甚远。</p>

<h3 id="21-创建独立的-room-areas">2.1 创建独立的 Room Areas</h3>

<p>按照文章所述， 算法需要保证地图的宽高尺寸， 以及房间尺寸， 房间所在位置均为奇数， 这样能与生成的 Maze 路径对齐， 保证 Maze 所经过的路径与 Rooms 仅有一个 tile 的距离， 这样能够保证后续连接 Rooms 和 Maze Path 的时候的便利。</p>

<p>至于创建随机且不重叠的 Room Areas 的思路也很粗暴， 随机生成 Room 的尺寸以及位置， 判断生成区块是否与已存在的 Room 存在重叠， 迭代一定次数即可。 对于一个有限地图而言， 没必要迭代太多次， 越往后重叠的概率越大反倒浪费资源。 这里需要注意的一个点是, Room 之间是需要留有一个 tile 的空隙的。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/room_and_maze.png" alt="Rooms and maze, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Room and maze, HangX-Ma</u></font>
</div>

<p>对于 Rooms 生成我用了 <strong>Inflation</strong> 的思想， 既然需要留有一个 Tile 的间隔， 不如在生成 Rooms 时将原点位置向左下移动一个单位， 将宽和高都扩大两个单位， 想象一下一个 5x5 的格子， 膨胀为 7x7 的格子。</p>

<h3 id="22-剩余空间填充迷宫墙">2.2 剩余空间填充迷宫墙</h3>

<p>原作者基于 <a href="http://www.odedwelgreen.com/karcero/">Karcero</a> 尝试生成迷宫墙以及前述的房间， 发现 <strong>Room then maze</strong> 的方式会更加高效， 其实道理也非常明晰， 先生成 Maze 并进行裁剪留下的空间用以生成 Rooms 其实极大限制了 Rooms 的生成区域， 而 maze 的填充仅占用 1 个 tile， 相比较动辄几十个 pixel 开销的 Rooms 区域而言， 其发生碰撞的概率会小很多。</p>

<p>作者生成 Maze 的方式用了图形学中常用的 <strong>Flood Fill</strong> 算法（似乎之前听过， 但第一次系统学完数据结构还没用过）。 从一个合格的节点出发，生成迷宫， 直到这段迷宫不能继续生长为止。 然后换个合格节点继续生成， 直到整个地图被迷宫填充。</p>

<p>这块比较困惑的地方是如何生成用以生长 Maze Path 的节点， 作者的思路很巧妙， 他规定了整个地图的尺寸是奇数的 <strong>W x H</strong> 大小， 同样也规定了生成的 Rooms 的尺寸也是奇数的， 且 Rooms 的原点位置也是奇数， 这样在我们遍历整个地图的时候， 只要将奇数位置填充为 <strong>Wall</strong> 类型， 就能够创建潜在的生成 Maze Path 的节点， 这些节点都能够和相邻的 Rooms 对齐且相聚一个 Tile 距离， 这是非常重要的一个属性。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/maze_path_tiles.png" alt="Essential maze path tiles, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Essential maze path tiles, HangX-Ma</u></font>
</div>

<p>在我们遍历完整个地图后， 就能够得到充满这些潜在可能转为 Maze Path 的 Wall Tile， 此时运用 <strong>Flood Fill</strong> 算法就能生成填充 Rooms 之间间隙的 Maze Path 了。 这里的思路也是遍历整张图找之前设定的 <strong>Wall Tile</strong>， 找到之后我们在该点的上下左右四个方向中找到沿该方向行进 2 格的 Tile（保证奇数这个属性）， 这个 Tile 的属性是 Wall， 并且落在设定的地图范围内。 连接当前点和目标点时， 我们设定这些 Tiles 的属性为 Floor， 这样在遍历完整个地图后就能得到 Maze Path。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/rooms_with_maze_path_without_connection.png" alt="Rooms with maze path but no connections, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Rooms with maze path but no connections, HangX-Ma</u></font>
</div>

<h3 id="23-连接-rooms-和-paths">2.3 连接 Rooms 和 Paths</h3>

<p>此时一个重要的问题落在了面前， 如何连接 Rooms 和 Paths 使得整个地图联通。 一般来说我们都会想到用 Union 来解决这个问题， 但这里有个 trick， 我们需要将之前的各个独立的 Maze Path 视作一个单位而不单独去考虑组成 Maze Path 各个 Tiles， 所以在生成 Maze Path 的时候， 用 Kruskal Union 算法将这些组成 Paths 的 Tiles 加入联通集中， 对于 Rooms 中的 Tiles 也要进行相同的操作。 当然现在又有一个问题， 如何找到这些潜在的可成为 Passage 的 Tile？</p>

<p>其实和之前的思路很类似， 也是要扫描整个图， 当扫到 Rooms 和 Paths 之前的空白区域的时候我们就开始进行筛选， 检查这个节点的上下左右四个方向的相邻节点是不是不为 Nothing 属性， 如果符合条件的相邻节点的数量大于两个， 说明这是一个潜在的 Passage Tile， 加入候选的集合中。</p>

<p>之后我们就随机选取潜在的 Passage Connector， 如何该 Tile 还不在 Kruskal Union 中， 就将该 Tile 加入 Kruskal Union 中。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/rooms_with_maze_path_and_connection.png" alt="Rooms with maze path and connections, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Rooms with maze path and connections, HangX-Ma</u></font>
</div>

<h3 id="24-优化生成的地图">2.4 优化生成的地图</h3>

<ul>
  <li>
    <p>地图过于拥挤</p>

    <p>现在生成的地图和样例所给的相去甚远， 太拥挤了， 有没有办法将生成的 Maze Path 缩小一些？ 我的比较粗浅的想法就是限制之前的 Wall Tiles 锚点的位置， 在判断是否落在地图范围内的时候就直接缩小地图的比例， 例如设定一个 <code class="language-html highlighter-rouge">GEN_RATIO</code> 的系数约束生成区域。</p>
  </li>
  <li>
    <p><strong>Dead End</strong> 过多</p>

    <p>地图中出现很多死胡同是很糟心的， 这也是之前的 Maze Path 的一个重要问题， 需要一种算法去优化生成的 Maze Path 以减少死胡同的数量。 得益于之前地图的奇数尺寸的设定， 判断死胡同的方式很简单， 只需要检查这个点的邻居点是否有 3 个 Tile 的属性都是 Nothing， 这说明这个 Tile 没能够与另一个区域直接相连。</p>

    <p>那么， 在遍历整张图找相应的 Dead End 的时候， 我们可以将其邻居点中不为 Nothing 的点作为下一个检查点或以此为下个检查方向， 直到死胡同消失或者达到我们设定的处理次数限制后， 我们再继续遍历地图。</p>
  </li>
  <li>
    <p>生成地图的墙</p>

    <p>前面将 Rooms 以及 Paths 都生成并优化了， 却发现有些灵魂缺失， 原来是关键的墙体没有生成。 再来一次暴力全图搜索， 找到不是空白的 Tile， 这次我们需要检查这些 Tile 的八邻居节点， 将这些节点中为 Nothing 属性的 Tile 设置为 Wall 属性。</p>
  </li>
</ul>

<p>最后生成的地图如下所示：</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/optimized_world.png" alt="Optimized world, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Optimized world, HangX-Ma</u></font>
</div>

<h2 id="3-写在最后">3. 写在最后</h2>

<p>原来是想边写 Blog 边做 Proj3 的， 结果人懒了硬是拖了两个星期才写写成了总结。 感觉整个设计如果深挖还会遇到很多未知的困难， 但就是这样一个初具雏形的游戏却让我在初期感到束手无措， 这种感觉做 Proj2 的时候也有。 但相较于 Proj2 的严格要求， Proj3 的发挥空间和余地都很足， 难度上也简单一些。 虽然这俩 Proj 为了提升效率我都去借鉴了别人的框架， 虽然都很有收获， 但思考的机会少了。</p>

<p>总的来说， cs61b 给我的提升非常大， 在数据结构基础这块至少已经有了一个底子， 最近刷 LeetCode 的时候就明显感觉到学的内容能用得上， 并且很多设计思路都在实际使用的时候得到了思维上的强化。 cs61b 虽然学了很久， 但确实是一门不能急躁的课， 每个 slides 都要仔细阅读， discussion 以及 examprep 有精力有时间一定得自己独立去做， 这样印象会很深！</p>

<blockquote>
  <p>说一句题外话， 有些同学可能看到 cs61b 用的是 java 语言就觉得生疏， 或者日后用不着就不想学。 其实每个语言都有其各自的特性， 我有一个很明显的感受， 学完 java 的基础特性之后对面向对象的很多概念有了很深的理解， 尤其是 discussion 讲基类和子类的函数调用那块。 甚至我觉得最近很火的 Rust 有很多特性也是借鉴了 java。 当然语言这块在精不在多， 能博采众长是好事， 也需要潜心钻研不断深耕。</p>
</blockquote>

<p>就写到这儿， 日后再多复习复习课件， 温故而知新！</p>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs61b" /><category term="Java" /><summary type="html"><![CDATA[UCB cs61 spring 2021 Proj3-BYoW 设计思路与记录]]></summary></entry><entry><title type="html">miniFOC 原理阐述与多模式应用</title><link href="https://hangx-ma.github.io/2023/07/28/miniFOC-concept.html" rel="alternate" type="text/html" title="miniFOC 原理阐述与多模式应用" /><published>2023-07-28T00:00:00+08:00</published><updated>2023-07-28T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/28/miniFOC-concept</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/28/miniFOC-concept.html"><![CDATA[<p>还是遇到一些需要记录的地方， 毕竟电机控制这部分仅仅在 <em>运动控制技术</em> 这么课听过一点点（老师不咋讲， 学生不咋听）， 实践的时候和理论还是有已经的距离的。</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://space.bilibili.com/382415040/channel/collectiondetail?sid=1401820">电机FOC软硬件一条龙服务【STM32、自制IPM驱动板】 - 热心市民翔先生 Bilibili</a></li>
  <li><a href="https://blog.csdn.net/loop222/article/details/121201638">SimpleFOC、ODrive和VESC 教程链接汇总 - loop222 CSDN</a></li>
  <li><a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">【开源】自制超级无敌宇宙超迷你FOC磁场定向控制的无刷伺服电机矢量控控制器【烂核】 - 小男孩gugugu Bilibili</a></li>
  <li><a href="https://wwjk.lanzoub.com/igCqS0jx5fwf">mini_FOC - 小男孩gugugu Bilibili</a></li>
</ul>

<h2 id="x1-零点标定">X1. 零点标定</h2>

<div align="center">
    <img src="/norobots/images/2023-07-28-miniFOC-concept/zero_angle.png" alt="Zero angle concept, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Zero angle concept, HangX-Ma</u></font>
</div>

<p>标定初始电角度的原因在于， 一般情况下我们会将转子磁场方向与 \(\alpha\) 正向重合的方向作为转子的零点位置（转子角度为 \(0^{\circ}\)）。 但是， 上电的时候电机还为经过电角度标定， 转子的位置对于控制器而言是未知的， 如果转子此时正好与 \(\beta\) 轴重合， 即以前述定义描述此时的转子角度已经处于 \({90}^{\circ}\)， 而控制器以为其仍处于 \(0^{\circ}\) 位置而产生了一个超前 \({90}^{\circ}\) 的 \(I_{q}\)， 那么 \(I_{q}\) 与转子此时完全重合。 只有 \(I_{q}\) 与转子存在角度差才能在切向产生力做功， 而此时重合的情况就会导致电机卡死不动。</p>

<p>零点标定的原理就是进行一个开环控制， 给定一个 \(\alpha\) 轴的电流， 使得电机转子转向并固定在 \(\alpha\) 轴， 此时的电角度就是需要标定的电角度偏移量。 因而有如下条件成立：</p>

\[\begin{equation*}
  \begin{aligned}
    U_{\alpha} &amp;= Const \\
    U_{\beta} &amp;= 0 \\
  \end{aligned}
\end{equation*}\]

<p>经过 Park 变换后可以得到如下结果：</p>

\[\begin{equation*}
  \begin{aligned}
    U_{q} &amp;= 0                          \qquad U_{d} = \alpha                   \qquad electrical\_angle = 0 \\
    U_{q} &amp;= \alpha                     \qquad U_{d} = 0                        \qquad electrical\_angle = -\pi/2 \\
    U_{q} &amp;= \frac{\sqrt{2}}{2}\alpha   \qquad U_{d} = \frac{\sqrt{2}}{2}\alpha \qquad electrical\_angle = -\pi/2 \\
  \end{aligned}
\end{equation*}\]

<p>一般来说第二条比较方便， 需要注意的是这个初始给的 \(U_{q}\) 不能太大， 小电机 0.5 V 开始网上调能带动就行。 我们可以通过开环状态下， 多次循环 <code class="language-html highlighter-rouge">set_phase_voltage(float Uq, float Ud, float e_angle)</code> 以达到固定角度的目的。</p>

<h2 id="x2-角度对齐与极对数计算">X2. 角度对齐与极对数计算</h2>

<p>角度对齐是基于电角度与机械角度方向需要一致的需求， 若电角度和机械角度相反， 电机会发生原位卡死的问题。 已经解决零点标定问题， 我们只需要让电机从零点开始以 \(2\pi\) 电角度为偏移量进行转动， 通过中间角度的正负值即可判断电机的转动方向（因为我们转动后还需要转回原来的零点位置， 所以这个 \(2\pi\) 角算是中间角）。 这里需要注意 <code class="language-html highlighter-rouge">电角度 = 机械角度 * 极对数</code>， \(2\pi\) 的电角度不会导致电机转一整圈， 现在的 PMSM 一般都有 6 个极对数。</p>

<p>此时我们还能进行极对数的计算， 因为转动 \(2\pi\) 后我们能读到一个机械角度量， 而电角度是机械角度的极对数倍（也就是整数倍）， 进行涉入取整计算即可得到极对数。</p>

<blockquote>
  <p><a href="https://www.bilibili.com/video/BV1C44y1j77b/?spm_id_from=333.788&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">project_3 实现角度反馈及电机力矩控制 - 热心市民翔先生</a>
<a href="https://blog.csdn.net/loop222/article/details/120471390">SimpleFOC移植STM32（四）—— 闭环控制 - loop222 CSDN</a></p>
</blockquote>

<h2 id="x3-foc-多应用模式">X3. FOC 多应用模式</h2>

<h3 id="x31-ratchet-棘轮模式">X3.1 Ratchet 棘轮模式</h3>

<p>棘轮模式目的是通过 FOC 力矩反馈使人感触到棘轮齿的一种力矩控制模式。 由于我的 miniFOC 的电流环调试效果并不好， 低速状态下存在抖动， 因而用 <code class="language-html highlighter-rouge">Uq</code> 电压直接控制力矩大小。 棘轮模式的主要原理就是人为设定几个 <strong>引力点（Attractor）</strong>， 利用当前机械角度与引力点之间的位置误差， 控制输出的力矩大小， 一般来说我们可以直接使用 PID 中的比例控制直接决定输出力矩的以模拟棘轮的不同刚度。</p>

<p>可参阅如下代码， 例如我们将机械角度 360° 等分为 6 份， 也就是设定每 60° 会有一个吸引点， 当前的电机转轴机械角度为 <code class="language-html highlighter-rouge">shaft_angle</code>， 那么与 <code class="language-html highlighter-rouge">attract_angle</code> 之间的角度误差为 <code class="language-html highlighter-rouge">attract_angle - shaft_angle</code>， 就可以将该误差项作为输入给到力矩控制器， 力矩控制器会进行比例调整， 并对输出的电压或电流进行限幅。 每个控制周期我们都需要重新确认邻近的棘轮引力点以保证棘轮感触的位置的正确性。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// attractor angle variable</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">attract_angle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
<span class="c1">// distance between attraction points</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">attractor_distance</span> <span class="o">=</span> <span class="mi">60</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">/</span> <span class="mi">180</span><span class="p">.</span><span class="n">f</span> <span class="o">*</span> <span class="n">_PI</span><span class="p">;</span> <span class="c1">// dimp each 45 degrees</span>

<span class="kt">float</span> <span class="nf">find_attractor</span><span class="p">(</span><span class="kt">float</span> <span class="n">angle</span><span class="p">){</span>
    <span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">qfp_fadd</span><span class="p">(</span><span class="n">qfp_fdiv</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">attractor_distance</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">qfp_fmul</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">idx</span><span class="p">,</span> <span class="n">attractor_distance</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ratchet_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g_tor_ctrl</span><span class="p">.</span><span class="n">target_torque</span> <span class="o">=</span> <span class="n">attract_angle</span> <span class="o">-</span> <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">;</span>
    <span class="n">attract_angle</span> <span class="o">=</span> <span class="n">find_attractor</span><span class="p">(</span><span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下图是参阅博客园对棘轮模式原理的电压与角度关系图， 这里设定的棘轮角度为 45°， 可以看到棘轮的作用力的分界点在 <code class="language-html highlighter-rouge">45°/2 = 22.5°</code> 的位置。</p>

<p>这很容易理解， 这个点是两个棘轮齿的中心点， 若 <code class="language-html highlighter-rouge">shaft_angle &gt; 22.5°</code> 则 <code class="language-html highlighter-rouge">find_attractor</code> 会找到下一个棘轮位置， 反之则仍是当前的棘轮位置。 我们知道闭环负反馈的作用是使作用对象稳定在目标位置， 在 <code class="language-html highlighter-rouge">[0;22.5°]</code> 之间， 越靠近中心点 <code class="language-html highlighter-rouge">22.5°</code> 距离误差越大， 受到反向的力矩越大； 而一旦跨过中心点位置， 棘轮齿更新为下一个位置， 此时的距离误差方向就与原来的相反了， 因而受到的是正向力矩的推力， 这里会有一个明显的电压的方向的改变， 力矩方向顺应改变， 这是人感受到棘轮齿的重要原因。</p>

<div align="center">
    <img src="/norobots/images/2023-07-28-miniFOC-concept/ratchet_mode.png" alt="Ratchet mode Voltage-Angle relationship, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Ratchet mode Voltage-Angle relationship, HangX-Ma</u></font>
</div>

<blockquote>
  <p><a href="https://www.cnblogs.com/21207-iHome/p/16898471.html">无刷电机力矩控制模拟棘轮 - XXX已失联 博客园</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 相关的原理， 包括 FOC， SVPWM， 零点检测等， 主要记录自己不熟悉的部分， 另外也记录一些基于 FOC 实现的有趣的应用。]]></summary></entry><entry><title type="html">STM32F103 Vofa+ 配置与调试指南</title><link href="https://hangx-ma.github.io/2023/07/19/vofaplus.html" rel="alternate" type="text/html" title="STM32F103 Vofa+ 配置与调试指南" /><published>2023-07-19T00:00:00+08:00</published><updated>2023-07-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/19/vofaplus</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/19/vofaplus.html"><![CDATA[<p>为了阐述清晰和 miniFOC 的开发进行的区分， 单独一章讲一讲这个上位机调试工具 <a href="https://www.vofa.plus/">Vofa+</a>， 当时是看到 B 站 Up <a href="https://space.bilibili.com/662875973">mandzy</a> 的视频以及 Vofa+ 精致的界面感觉这个工具能够帮上不少忙。 目前 Vofa+ 支持三种传输协， <em>FileWater</em>， <em>JustFloat</em>， <em>RawData</em>。 对于电机控制而言， 传输波形的数据需要用到浮点， 第二个传输浮点数据的协议就比较合适了， 具体选用哪种协议示情况而定。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_demo.png" alt="Vofa+ demo, HangX-Ma" width="800" />
    <br />
    <font size="2" color="#999"><u>Vofa+ demo, HangX-Ma</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://www.vofa.plus/">Vofa plus</a></li>
  <li><a href="https://www.vofa.plus/downloads/?index=1&amp;plugin_index=2">Vofa plus - plugins</a></li>
  <li><a href="https://www.bilibili.com/video/BV1DP411C7Xe/?spm_id_from=333.999.0.0&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32使用HAL库生成USB虚拟串口连接VOFA+输出波形 - mandzy Bilibili</a> <a id="vofa_demo"></a></li>
  <li><a href="https://www.bilibili.com/video/BV15V411T7Gg/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32F4使用DMA串口通信连接VOFA软件进行电机调试和波形显示 - mandzy Bilibili</a></li>
  <li><a href="https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">ST RM0008 Reference manual</a></li>
</ul>

<h2 id="1-stm32-virtual-serial-port">1. STM32 Virtual Serial Port</h2>

<p>本质上是用 USB 虚拟串口进行数据收发， 没想到 F103 系列也支持， 但是后来看了看 F103 虚拟串口没有 DMA 功能， 这个就比较致命了。 按照现有设计， 除了进行指令的交互， MCU 还需要通过串口向上位机传输数据， 如果直接交由 CPU 进行处理会极大浪费计算资源， 一般来说需要通过 DMA 规避 CPU 对这些数据的处理。 所以， 对于 F103 系列还是老老实实用 USARTx + DMA 的组合比较合适。</p>

<h2 id="2-vofa-justfloat-protocol">2. Vofa+: JustFloat Protocol</h2>

<p>具体的协议内容可以看官网的 <a href="https://www.vofa.plus/plugin_detail/?name=justfloat">JustFloat</a> 说明， 除了采样数据解析外， 该协议还能进行图像解析。 目前我只用到了数据采样解析部分， 搞懂这个也就一通百通了， 可以看到滚放定义的数据帧如下所示， 帧尾是一个 4 字节的特定数据 <code class="language-html highlighter-rouge">0x00, 0x00, 0x80, 0x7f</code>， 这是小端的顺序， 大端需要调换一下数据的存储顺序。 也就是说， 我们在发送完希望传输的数据后， 需要紧跟在这些数据后面发送一个尾帧， 才能让 Vofa+ 识别数据帧的内容并进行可视化以及文本打印。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CH_COUNT 通道数量
</span><span class="k">struct</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">fdata</span><span class="p">[</span><span class="n">CH_COUNT</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tail</span><span class="p">[</span><span class="mi">4</span><span class="p">]{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>一般来说， 串口是无法接收 float 类型的数据的， 但 float 类型在 STM32 中占据 4 个字节， 因而我们可以定义这样一个 union 联合体结构解决 float 数据传输的问题。 <code class="language-html highlighter-rouge">fdata</code> 和 <code class="language-html highlighter-rouge">chars</code> 共用一块内存区域并且都占据 4 个字节， 这样在使用串口发送数据的时候就能将 <code class="language-html highlighter-rouge">fdata</code> 拆分成 4 个 <code class="language-html highlighter-rouge">chars</code> 进行发送。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief Use union to decompose the float_data into 4 bytes char.
 *        Because the USART only transfer bytes.
 */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">Format</span><span class="p">{</span>
    <span class="kt">float</span>    <span class="n">fdata</span><span class="p">;</span>    <span class="c1">// little-endian float</span>
    <span class="kt">uint8_t</span>  <span class="n">chars</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Format_Typedef</span><span class="p">;</span>

<span class="n">Format_Typedef</span> <span class="n">send_data</span><span class="p">[</span><span class="n">VOFA_SEND_CH_COUNT</span><span class="p">];</span>
<span class="n">Format_Typedef</span> <span class="n">recv_data</span><span class="p">[</span><span class="n">VOFA_RECV_CH_COUNT</span><span class="p">];</span>
</code></pre></div></div>

<p>这样， 根据这个协议， 我们仅需要定义两个数据就能完成 USART 的收发， 将这两个数组的地址分别配置为发送部分 DMA 的内存地址， 以及接收部分的内存地址。 当然， 在设置 DMA 的传输数据总量的时候也需要考虑到末尾 4 个字节的特定数据帧。</p>

<p>具体的配置可以查看 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Inc/vofa_usart.h">vofa_usart.h</a> 和 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Src/vofa_usart.c">vofa_usart.c</a> 这两个文件。</p>
<blockquote>
  <p>特别感谢 B 站 mandzy Up 提供的代码参考！</p>
</blockquote>

<h2 id="3-vofa-components">3. Vofa+ Components</h2>

<p>Vofa+ 还提供了一系列控件方便我们进行对下位机的调试， 这里以这个 <code class="language-html highlighter-rouge">ExtraButtonToggle</code> 控件为例。</p>

<p>将这个控件拖出到新的 Tab 中， 右击可以看到一个 <code class="language-html highlighter-rouge">事件与参数</code> 的选项， 这是表示按钮在 <strong>激活</strong> 以及 <strong>关闭</strong> 的时候会发送的指令。 如果我们的下位机协议非常简单， 配置这个控件的这个选项的参数就能实现功能， 但我们经常会需要对指令包装一个帧头以区分不同功能的指令， 并在解析帧头后继续接收数据， Vofa+ 提供了一个 <code class="language-html highlighter-rouge">命令</code> 区块方便我们发送 <strong>帧头+数据</strong> 这种组合。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_components.png" alt="Vofa+ components, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Vofa+ components, HangX-Ma</u></font>
</div>

<p>以上图为例， 我定义了一段命令的内容为 <code class="language-html highlighter-rouge">AA FF 00 01</code> <code class="language-html highlighter-rouge">%% 00 00 00</code>， 前半部分是我定义的帧头数据， 只有识别到 <code class="language-html highlighter-rouge">AA</code> 和 <code class="language-html highlighter-rouge">FF</code> 我才会继续解析指令， 将末尾的 <code class="language-html highlighter-rouge">01</code> 作为区分不同指令的具体标识。</p>

<p>而后半段则是我定义的数据帧， <code class="language-html highlighter-rouge">%%</code> 标识占位符， 这样一组 <code class="language-html highlighter-rouge">%%</code>占位一个字节， 我在这个按钮控件的 <code class="language-html highlighter-rouge">事件与参数</code> 部分设置了激活态发送 <code class="language-html highlighter-rouge">01</code>， 关闭态发送 <code class="language-html highlighter-rouge">02</code>， 这样在我按下按钮后， 根据当前按钮的状态， <code class="language-html highlighter-rouge">%%</code> 会被替换为 <code class="language-html highlighter-rouge">01</code> 或者 <code class="language-html highlighter-rouge">02</code>。 这样， 每次按下按钮后， Vofa+ 都会向 STM32 发送 <code class="language-html highlighter-rouge">AA FF 00 01</code> <code class="language-html highlighter-rouge">01 00 00 00</code> 或者 <code class="language-html highlighter-rouge">AA FF 00 01</code> <code class="language-html highlighter-rouge">02 00 00 00</code>。</p>

<p>可以结合我在 USART 中 DMA 接收部分对数据的解析方式进行理解。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">USARTx_DMA_RX_IRQHandler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If data receiving complete, clear the TC5 flag</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LL_DMA_IsActiveFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LL_DMA_ClearFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">);</span>
        <span class="c1">// receive frame header: 0xAA 0xFF</span>
        <span class="n">Format_Typedef</span> <span class="n">recv_header</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xAA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="n">Format_Typedef</span> <span class="n">recv_data</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mh">0x01</span><span class="p">:</span>                         <span class="c1">// control motor start/stop</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// start</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">start_pwm</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// stop</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">stop_pwm</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x02</span><span class="p">:</span> <span class="c1">// set velocity</span>
                <span class="n">g_target_motor_vel</span> <span class="o">=</span> <span class="n">recv_data</span><span class="p">.</span><span class="n">fdata</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// we need to disable dma rx channel and reset the transfer length</span>
        <span class="n">usart_rx_dma_reload</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>这里为什么设置的发送帧为 8 个字节？ 这是因为目前使用的是 <strong>JustFloat</strong> 协议， 协议发送和接收都是依据 float 的格式与大小进行的。 而我定义了接收帧为大小为 2 的 <code class="language-html highlighter-rouge">Format_Typedef</code> 数组， 正好是 2 个 float， 8 个字节大小。 若是不理解可以看看 mandzy 的相关 <a href="#vofa_demo">视频</a>。</p>
</blockquote>

<h2 id="4-调试记录">4. 调试记录</h2>

<p>一个简单的 USART + DMA 配置， 结果配完 USART1 后发现没有数据发送出来， 也没有数据接收到。</p>

<ul>
  <li>将 USART1 更换为 USART2 以及 USART3 都是一样的情况。</li>
  <li>检查了 DMA 的配置， 发现 <code class="language-html highlighter-rouge">recv_frame</code> 和 <code class="language-html highlighter-rouge">send_frame</code> 的地址忘记写目标地址上了， 但是还是不行。</li>
  <li>单独测试收的过程， 在指令中加入一个翻转 LED 的命令， 无效， cortex-debug 也接收不到中断。</li>
  <li>主程序可以跑通， 加入 LED 翻转指令有效， 通过 cortex-debug 插件也没有发现数据有问题。</li>
  <li>用自己之前写的可以工作的 USART1 的程序进行回环测试， 无效， 基本确定 CH340 硬件坏了。</li>
  <li>用逻辑分析仪测了一下输出脚 <em><strong>PB6(Tx)</strong></em> 有不同的输出波形， 说明 DMA 通信不成问题了， 协议部分还不清楚， 但 CH340 肯定坏了。</li>
  <li><code class="language-html highlighter-rouge">JustFloat</code> 协议测试可用。</li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="C" /><category term="STM32" /><summary type="html"><![CDATA[上位机调试工具 Vofa+ 食用指南， 结合电机调试进行说明， 感谢 Bilibili 大学。]]></summary></entry><entry><title type="html">OOP C Programming</title><link href="https://hangx-ma.github.io/2023/07/18/oopc.html" rel="alternate" type="text/html" title="OOP C Programming" /><published>2023-07-18T00:00:00+08:00</published><updated>2023-07-18T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/18/oopc</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/18/oopc.html"><![CDATA[<p>研究这部分内容的动机主要还是编写 STM32 的 C 代码的时候， 期望有一个固有的类能够管理其方法， 这样能够比较清晰的管理这些同属于一类的代码结构。 其实这里就涉及到了 <strong>面向对象</strong> 的编程思想， 将数据抽象为 <strong>类</strong> 和 <strong>方法</strong>， 类能表征数据的属性， 而方法则是数据属性及状态改变的一种行为。</p>

<p>之前在接触 Linux 驱动的时候其实就浅浅地接触到了 C 面向对象的思想， 例如 MTD 层抽象接口提供给 Block， 我们直接从顶层通过代码索引的方式是没办法找到具体的 Block 调用方法的。 我们只能看到 MTD 抽象出来的接口， 这一定程度上提供了数据的私有化的能力。</p>

<p>网上的相关文章众说纷纭， 但目前看来就是 <em><strong>C 现代编程</strong></em> 这本书讲的最清晰最明白， LW_OOPC 则是 高焕堂 以及其团队 MISOO 设计的方便 C 面向对象的宏定义模块， 能方便相关的开发。 其实这些文章读过来， 主要还是需要开发者用好 <code class="language-html highlighter-rouge">struct</code>， <code class="language-html highlighter-rouge">Macro</code>， <code class="language-html highlighter-rouge">pointer</code>  这三类资源。 <code class="language-html highlighter-rouge">struct</code> 可谓是重中之重， 可以看到在 C++ 中的 struct 和 class 仅在数据接口的私有性上存在差异， 而在 Rust 中则直接删除了 class 的定义， 转向了 struct + trait 的编程模式。</p>

<p>这篇文章不定期更新 OOP C 的一些想法， 其实读 <em><strong>C 现代编程</strong></em> 还是有很多疑惑的， 但是没用到就没太深刻的印象， 有问题再好好研究记录！</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://pan.baidu.com/s/1qf2VAPh5zU8PAToU9RHbCg?pwd=l9ry">C 现代编程 - 百度网盘</a>
    <blockquote>
      <p>这本书最关键， 下面的感觉写的都不如这本书详细清晰。</p>
    </blockquote>
  </li>
  <li><a href="https://pan.baidu.com/s/1bda2tBK7KZxSOlMUcWMccQ?pwd=secu">UML+OOPC嵌入式C语言开发精讲 - 百度网盘</a></li>
  <li><a href="https://github.com/Akagi201/lw_oopc/tree/master">lw_oopc - Github</a></li>
  <li><a href="https://ooc-coding.sourceforge.net/">Object Oriented C - ooc</a></li>
  <li><a href="https://mp.weixin.qq.com/s/V8xil48IoQE6QB82_5o2_w">真的可以，用C语言实现面向对象编程OOP - 李肖遥 WeChat</a></li>
  <li><a href="https://www.cnblogs.com/kendoziyu/p/c_object-oriented_programming_example_by_struct.html">C语言使用结构体面向对象编程举例讲解 - 极客子羽 博客园</a></li>
</ul>

<h2 id="1-使用-struct-模块化编程">1. 使用 struct 模块化编程</h2>

<p>主要想法还是利用 struct 管理方法函数， 利用 <code class="language-html highlighter-rouge">static</code> 对 <code class="language-html highlighter-rouge">.c</code> 文件中的函数进行私有化处理防止命名冲突。</p>

<p>另外， struct 也能起到虚函数的功能， 如下定义了一个 <code class="language-html highlighter-rouge">page_t</code> 的结构体， 这个结构体规定了其内实现的方法函数的接口。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">painter</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">page_t</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="2-跨文件的全局变量">2. 跨文件的全局变量</h2>

<p>另外在整个工程中会需要跨文件使用相关的变量， 例如我在 <code class="language-html highlighter-rouge">encoder.h</code> 定义了一个 <code class="language-html highlighter-rouge">struct Encoder</code> 作为编码器类， 而我希望通过一个 <code class="language-html highlighter-rouge">g_encoder</code> 变量作为跨文件的全局变量被不同文件使用。 例如在 <code class="language-html highlighter-rouge">encoder.c</code> 中初始化方法函数， 而在其他文件中调用这些方法， 此时通过一个全局的变量就非常方便了。 这里需要区分 <strong>声明</strong> 和 <strong>定义</strong> 这两个概念。</p>

<dl>
  <dt>声明</dt>
  <dd>向编译器说明一个变量或函数的信息，包括：名字、类型、初始值等，即声明变量、函数的属性细节， 包含该声明的模块在连接阶段从其它模块寻找外部函数和变量。</dd>
  <dt>定义</dt>
  <dd>指明变量、函数存储在哪里，当定义发生时，系统为变量或函数分配内存单元。</dd>
</dl>

<p>我在这里是这样构想的， 对于特定功能的类， 例如 <code class="language-html highlighter-rouge">Encoder</code> 编码器类， 则直接在 <code class="language-html highlighter-rouge">encoder.c</code> 中定义一个这个类型的变量 <code class="language-html highlighter-rouge">g_encoder</code>， 在 <code class="language-html highlighter-rouge">encoder.h</code> 中则通过 <code class="language-html highlighter-rouge">extern</code> 声明 <code class="language-html highlighter-rouge">g_encoder</code>。 这样， 任何包含 <code class="language-html highlighter-rouge">encoder.h</code> 的文件都能直接使用这个变量。 而一些影响设备属性的 primitive 类型的变量则通过 <code class="language-html highlighter-rouge">config.h</code> 以及 <code class="language-html highlighter-rouge">config.c</code> 进行声明和定义。 这样能够分离文件的职能， 不会导致 <code class="language-html highlighter-rouge">config.h</code> 这个管理全局变量的文件不断 include 各种子设备而导致文件管理过于繁杂和臃肿。 但我需要在 <code class="language-html highlighter-rouge">config.h</code> 用注释说明这些全局变量的位置以及功能， 方便后续进行查阅检索。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Encoder</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Encoder</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://www.cnblogs.com/wangh0802PositiveANDupward/archive/2012/08/06/2624827.html">C语言：全局变量在多个c文件中公用的方法 - 奔流聚海 博客园</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="C" /><summary type="html"><![CDATA[结合 OOP 思想进行 C 语言编程， 这篇文章并不从头介绍相关的知识， 而是记录个人学习的疑难点以及参考资料等资源。]]></summary></entry><entry><title type="html">miniFOC Driver Development</title><link href="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html" rel="alternate" type="text/html" title="miniFOC Driver Development" /><published>2023-07-17T00:00:00+08:00</published><updated>2023-07-17T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/17/miniFOC-dev</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html"><![CDATA[<p>研 0 的时候不知好歹自己做了一块驱动板， 但是没有任何经验也不知道怎么开发， 结果上电就烧。 直到最近看到了 B 站 Up <a href="https://space.bilibili.com/382415040">热心市民翔先生</a> 发的 FOC 开发的系列视频感觉这个项目是有救了。 这也算是圆了自己 STM32 开发的愿望， 之前只学习做过一些 demo， 导师甚至把 MCU 称之为玩具（相对他高大上的嵌入式 Linux 而言确实如此）。 但无论如何， 学习的过程中总是会有收获的， 我不认为他们口中简单的东西在没有接触之前都是简单的， 至少我需要这个开发经历。</p>

<blockquote>
  <p>目前板子设计借鉴了 <a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">小男孩gugugu</a> Up 的这部分内容（视频标题太长啦！）， 不想自己从头找元件然后再一个个建模搭了， 太费时间了这样就本末倒置了。</p>
</blockquote>

<ul>
  <li><strong>MCU:</strong> STM32F103C8T6, 64K Flash, 20K SRAM</li>
  <li><strong>Dev Tool:</strong> CMake, OpenOCD, STLink-v2, STM32CubeMX</li>
  <li><strong>Serial Communication:</strong> Vofa+</li>
  <li><strong>PCB Design:</strong> Altium Designer 23</li>
  <li><strong>Editor:</strong> VSCode</li>
  <li><strong>Debugger:</strong> Cortex-Debug</li>
  <li><strong>Third Party Library:</strong>
    <ul>
      <li>Float-point Calculation Optimization: Qfplib-M3</li>
      <li>OLED Display: u8g2</li>
    </ul>
  </li>
</ul>

<p>项目地址 <a href="https://github.com/HangX-Ma/miniFOC">HangX-Ma/miniFOC</a>， 项目将持续更新， 这次挺有信心的！</p>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/miniFOC.svg" alt="miniFOC design, HangX-Ma" width="800" />
    <br />
    <font size="2" color="#999"><u>miniFOC design, HangX-Ma</u></font>
    <br />
    <br />
</div>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/all-components.png" alt="miniFOC driver board and other components, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>miniFOC driver board and other components, HangX-Ma</u></font>
</div>

<h2 id="1-sc60228-磁编码器">1. SC60228 磁编码器</h2>

<p>SC60228 是一款非接触式高精度磁编码器芯片， 芯片中心内置了霍尔感应点矩阵， 可用以测量无刷电机的转子角度。 通过 PWM 或 SPI 的方式输出 12 bit 绝对式位置信息， 检测速率可达 20K rpm， 不难得知该款芯片能检测一周最多 4096 个位置。 相较读取 PWM 输出计算角度而言， 使用 SPI 协议读取数据的精度会更高， 代码编写也比较方便且具备通用性。</p>

<blockquote>
  <p>用这款芯片也是历史遗留问题了， 当时做了这个板子不忍心浪费， 网上有 Simple FOC 提供的 <a href="https://github.com/simplefoc/Arduino-FOC-drivers/tree/master/src/encoders/sc60228">SC60228 SimpleFOC driver</a> 可参考代码部分， 虽然看起来事情不多， 但理解数据手册进行配置和代码编写也对学习很有帮助。</p>
</blockquote>

<h3 id="11-时序图与-spi-基本配置">1.1 时序图与 SPI 基本配置</h3>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/encoder-spi-time-diagram.png" alt="Encoder SPI time diagram, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI time diagram, HangX-Ma</u></font>
</div>

<p>这款芯片只需要配置 SPI 口在主机接收 <strong>(Receive Only Master)</strong> 数据即可， 不涉及双向数据传输。 我原来计划使用 DMA 传输 SPI 的数据， 但实际上 DMA 在小数据量以及高速读取的情况下并不合适， 这里的位置信息仅 16 位， 有些多此一举了。</p>

<p>可以看到上图数据手册提供的读取绝对式角度数据的时序表， 根据 SPI 协议 SCLK 空闲时低电平， 另外根据数据手册， 在 SCLK 上升沿之后需要保持 \(t_{DO}\) 时间以使得 MISO 数据有效， 那么只能在下降沿进行数据采样。 不难确定 SPI 协议的 <strong>CPOL(Clock Polarity)</strong> 为 <strong>Low</strong>， <strong>CPHA(Clock Phase)</strong> 为 <strong>Second Edge</strong>。</p>

<p>另外， 手册指出 <strong>\(t_{CLK}\)（SCLK 周期）</strong> 最小需要 100ns， 这里我查了一下 STM32CubeMX 配置中的 Baud Rate 的含义， 如果没理解错就相当于 SPI 中的 SCLK。 对于预设 72MHz 时钟频率的板子， 8 分频 9.0 MBits/s ≈ 111 ns， 另外 <strong>\(t_{DO}\)（SCLK 的上升沿到 MISO 数据有效之间的时间）</strong>_ 其值最大能达到 50 ns， 那么当前算是极限的速率配置了。 为了保险起见我选择设置 16 分频约 222 ns 周期， 防止数据出现丢失以及未定义的情况。</p>

<blockquote>
  <p>这里配置的是 SPI1 的， 我后面改成 SPI2 之后由于总线的时钟频率不一样， SPI2 只需要 8 分频。 改这个总线的原因还是因为 SPI2 的 DMA 通道给 USART1 给占了， 想玩玩 OLED 得用 SPI + DMA 的方式速率才能跟得上， 虽然最后可能会因为计算资源问题不上 OLED。</p>
</blockquote>

<p>除此之外数据手册中的 \(t_{L}\)， \(t_{H}\)， \(t_{CS}\) 这几个关键量需要在编程时在特定位置延时。 LL 库仅定义了毫秒级的延时， 一个简单的办法实现 us 级的延时就是通过 <code class="language-html highlighter-rouge">__NOP</code> 指令， 这样至少不会浪费定时器资源而且目前也不需要这么高精度的延时（64 个 <code class="language-html highlighter-rouge">__NOP</code> 就足够了。 72MHz 主频一个 <code class="language-html highlighter-rouge">__NOP</code> 为 1/72 us）。</p>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/spi1-parameter-settings.png" alt="Encoder SPI1 parameter settings, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI1 parameter settings, HangX-Ma</u></font>
</div>

<blockquote>
  <p>后续测试若有问题则可将分频倍数调得更高一些， 400 ns 应该也是能接受的， 手册说明最大转速可测 20K rpm， 小电机能有 5K rpm 也不得了了。</p>
</blockquote>

<p>另外 16-bits 的数据中， 除了 MSB 开始的 <code class="language-html highlighter-rouge">[D11..D0]</code> 角度数据， 后续有用的还有 <code class="language-html highlighter-rouge">ERR</code>， 能够识别磁铁安装位置是否合适， 在装机的时候非常有用。 <code class="language-html highlighter-rouge">PARC</code> 用以进行奇偶校验， 该位需要和前 15 位数据保持奇数特性。</p>

<p>另外配置片选引脚的时候需要默认输出为高并且将其配置为上拉模式， 这是根据时序图所示， 芯片是在 CS 脚为低的时候工作的， 这样能保证在必要的时候选中相应的片选脚进行数据传输。</p>

<blockquote>
  <p><a href="https://www.cnblogs.com/blogernice/articles/12531133.html">详解SPI中的极性CPOL和相位CPHA - blogernice 博客园</a><br />
<a href="https://zhuanlan.zhihu.com/p/26509678">秒懂 奇偶校验码 - 车卡门 知乎</a><br />
<a href="https://blog.csdn.net/ftswsfb/article/details/104321901">奇偶校验原理及C实现 - ftswsfb CSND</a><br />
<a href="https://blog.csdn.net/weixin_43593122/article/details/119253544">硬件探索——STM32F4通过SPI总线读取GMR（磁编码器） - 123-wqy CSDN</a><br />
<a href="https://zhuanlan.zhihu.com/p/632955358">STM32——DMA数据转运 - 柯宝最帅 知乎</a><br />
<a href="https://blog.51cto.com/u_13682052/4990083">stm32利用通用定时器实现函数运行时间精确测量 - biao2488890051 51CTO</a></p>
</blockquote>

<h3 id="12-spi-片选的说明">1.2 SPI 片选的说明</h3>

<p>SPI 片选对 SPI 设备是通用的， 不管是从机还是主机， 都需要配置片选引脚。 我在 CubeMX 中看到 NSS 引脚分为硬件和软件两种， NSS 就是平常所说的片选脚， 对于主机而言片选脚需要拉高的， 这样才能保证主机 SPI 处于工作状态。 如果选择软件配置， 那么在我们选择 STM32 作为主机的时候， LL 库自动帮我们配置了 SSI 引脚作为主机的片选。 而硬件配置则会根据芯片特定的 NSS 引脚决定相应的状态。</p>

<p>而 SPI 主机硬件配置时可以将 Hardware NSS Signal 配置为 <strong>Hardware NSS Output Signal</strong>， 这样 NSS 脚就能自动输出低电平使能从设备。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_44509533/article/details/104110454">STM32 SPI的NSS引脚配置 - 星水天河 CSDN</a><br />
<a href="https://blog.csdn.net/m0_46272475/article/details/121152512">STM32 SPI 软件NSS和硬件NSS解读 - fanyuandrj CSND</a></p>
</blockquote>

<h3 id="13-关于磁编码器的一些建议">1.3 关于磁编码器的一些建议</h3>

<ul>
  <li>一般来说磁编码器就只需要 1 或 2 个滤波电容外加芯片就行， 设计起来很方便， 时间成本允许就自己打样， 还能针对电机安装孔进行定制化设计。</li>
  <li>SPI 在芯片上的顺序一般都是 <code class="language-html highlighter-rouge">CS</code>, <code class="language-html highlighter-rouge">SCLK</code>, <code class="language-html highlighter-rouge">MISO</code>, <code class="language-html highlighter-rouge">MOSI</code>， 顺序搞错接线会很麻烦。</li>
  <li>磁编码器似乎不是特别耐高温， 我自己把之间用热风枪吹上的芯片拆下来又装到新板子， 老会出毛病， 如果一直出现返回 error 指不定是编码器坏了。</li>
  <li>磁铁需要买径向磁铁， <em>N 极</em> 和 <em>S 极</em> 对向水平分布。</li>
  <li>为了安装磁铁买了 AB 胶， 非常管用， 但除此之外还买了 3mm 轴套增加安装接触面积（热胶枪装不上）。</li>
</ul>

<h2 id="2-cortex-m3-浮点计算优化">2. Cortex-M3 浮点计算优化</h2>

<p><strong><a href="https://www.quinapalus.com/qfplib.html">Qfplib: a family of floating-point libraries for ARM Cortex-M cores</a></strong></p>

<p>一年前就找到了这个库了， 一直没尝试用过。 在 miniFOC 的项目中我是将所有的外部库都放到了 <code class="language-html highlighter-rouge">Driver</code> 这个文件夹下面， 我创建了一个 <code class="language-html highlighter-rouge">Qfplib-M3</code> 的文件夹存储浮点计算的库文件， 只需要在 <code class="language-html highlighter-rouge">CMakeLists.txt</code> 中添加这个库的路径就能使用了。 经过测试， 使用这个浮点库对计算性能有非常大的提升， 在单步调试的时候， 普通的浮点数除法比利用 qfplib 的浮点数除法有肉眼可见的差距。</p>

<h2 id="3-u8g2-库的使用">3. u8g2 库的使用</h2>

<p>u8g2 库的使用参考了两份代码（用的是 SSD1306 驱动芯片）， 但实际上这两篇文章都没有解决我使用 LL 库配置 SPI + DMA 进行数据传输的问题。 很遗憾我没解决这个问题， 最后使用了普通的 SPI 传输的办法， 这是因为我在几个论坛上发现很多人用了 SPI + DMA 就无法做到数据的正常传输， 必须等到 SPI + DMA 的数据传输完成后才能进行下一次传输， 而这需要通过 while 循环不断检查是否传输完毕。 既然需要 CPU 的参与， 不如直接用 SPI 还更省心。</p>

<ul>
  <li>SPI 发送数据， 需要通过 <code class="language-html highlighter-rouge">LL_SPI_IsActiveFlag_TXE(SPI1)</code> 检查当前传输是否完成， 当前字节传输完成后才能开启下一次传输。</li>
  <li>除此之外， u8g2 将 CS 引脚拉高之前 （Deselect）， 需要确认 SPI 的传输已经结束， 否则会造成数据错误。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nf">u8x8_byte_4wire_hw_spi</span><span class="p">(</span>
    <span class="n">U8X8_UNUSED</span> <span class="n">u8x8_t</span> <span class="o">*</span><span class="n">u8x8</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">msg</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">arg_int</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">arg_ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_SEND</span><span class="p">:</span> <span class="c1">// Use SPI to send 'arg_int' bytes</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arg_int</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LL_SPI_TransmitData8</span><span class="p">(</span><span class="n">SPI1</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">__NOP</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_END_TRANSFER</span><span class="p">:</span>  <span class="c1">// Software CS is needed. (deselect)</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_BSY</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SET</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__NOP</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">gpio_and_delay_cb</span><span class="p">(</span><span class="n">u8x8</span><span class="p">,</span> <span class="n">U8X8_MSG_DELAY_NANO</span><span class="p">,</span> <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">display_info</span><span class="o">-&gt;</span><span class="n">pre_chip_disable_wait_ns</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">LL_GPIO_SetOutputPin</span><span class="p">(</span><span class="n">OLED_CS_SCK_MOSI_GPIO_PORT</span><span class="p">,</span> <span class="n">OLED_CS_PIN</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/AagsAags/stm32f103c8t6_u8g2_hw_spi">AagsAags/stm32f103c8t6_u8g2_hw_spi - Github</a><br />
<a href="https://www.izilzty.com/?post=15">在STM32上使用U8g2图形库并配合DMA发送显示数据（LL库） - izilzty的小窝</a></p>
</blockquote>

<h2 id="4-oled-菜单与动画">4. OLED 菜单与动画</h2>

<p>调完 FOC 之后开始不务正业了， 不过实现一个丝滑的 OLED 菜单确实帅得优雅， 也为之后做一个集成主控芯片以及按钮的 FOC 驱动板打下基础。 我在 B 站也找了一些参考， 目前来说 <a href="https://www.bilibili.com/video/BV1wA411o7VJ/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32 稚晖君丝滑菜单 - uYanki Bilibili</a> 的实现是比较符合我目前的工程需求的， 不过他提供的 <a href="https://github.com/uYanki/board-stm32f103rc-berial/tree/main/7.Example/hal/gui/u8g2/02_menu">menu</a> 的库的仓库还包含了一堆其他的东西， 真的是非常庞大。</p>

<p>我第一步想实现的就是简单的菜单动画， 但在查看他编写的代码的时候， 发现这些实现需要基于 easing 这个类。 于是， 我上网找了一圈， 发现这其实是一个补间动画相关类， <a href="https://easings.net/zh-cn">easings.net</a> 网站提供了基于各种缓动函数的动画样例， 非常直观清晰。 另外， tween.js 是有详细的文档说明的， 可以进行查阅。 为了移植方便， 我在网上找到了几个 C/C++ 版本的 tween.js 的实现， 参照这个 Up 的代码进行相关结构体的学习。</p>

<p>在我自己的工程里， 为了保证在 STM32F103 这类 Cortex-M3 内核的计算效率， 我会对 easing 的主体函数用 Qfplib-m3 库进行优化。</p>

<blockquote>
  <p><a href="https://easings.net/zh-cn">easings.net</a><br />
<a href="https://github.com/tweenjs/tween.js/blob/main/docs/user_guide_zh-CN.md">tween.js - wiki</a><br />
<a href="https://github.com/mobius3/tweeny">tweeny</a><br />
<a href="https://github.com/rynmth/ctween">ctween</a><br />
<a href="https://blog.csdn.net/siyacaodeai/article/details/113766006">C++实现缓动动画效果，使用Tween算法（含详细代码） - Coding14 CSDN</a>
<a href="https://www.jb51.net/article/135077.htm">tween.js缓动补间动画算法示例 - 李俊杰 脚本之家</a><br />
<a href="https://blog.csdn.net/S_clifftop/article/details/89490422">Tween动画及缓动函数 - S_clifftop CSDN</a></p>
</blockquote>

<h2 id="5-ina199x1-电流采样配置">5. INA199x1 电流采样配置</h2>

<p>这个配置是真的痛苦啊， 前后加起来快有一天了， 主要是对通过 TIM 定时器对 ADC 触发多通道转换这部分的含义不了解。 关于电流采样， 我设想通过 ADC1 完成多通道采样， 并通过定时器定时出发采样， 使用 DMA 对转换结果进行传输。 依据这个思路需要配置 TIM 的 PWM 以及 ADC 的外部触发。</p>

<p>在 STM32CubeMX 对 ADC 的配置中会看到 <code class="language-html highlighter-rouge">External Trigger Conversion Source</code>， 这个配置网上说啥的都有， 当时我参照 B 站 Up 在 FOC 的配置中选择的 <code class="language-html highlighter-rouge">Timer 2 Capture Compare 2 event</code> 照猫画虎， 配置完后发现根本没办法采到数据。 我发觉这个 Capture Compare 有点像比较器的输出部分， 而 TIM 中配置的则是 <code class="language-html highlighter-rouge">PWM Generation No Output</code>， 这显然对不上。</p>

<p>后续参考尝试了很多代码， 最后在 <a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a> 看到了对这几个参数的相关解释， 发现只有 ADC1 仅对 TIM3 有一个 <code class="language-html highlighter-rouge">Timer 3 Trigger Out event</code> 的选项。</p>

<ul>
  <li><strong>Regular Conversion launched by software:</strong> 规则的软件触发， 调用函数触发即可</li>
  <li><strong>Timer X Capture Compare X event:</strong> 外部引脚触发</li>
  <li><strong>Timer X Trigger Out event:</strong> 定时器通道输出触发， 需要设置相应的定时器设置</li>
</ul>

<p>根据 ADC 中的选项的字面意思， TIM3 中的 <code class="language-html highlighter-rouge">Trigger Event Selection</code> 配置为 <code class="language-html highlighter-rouge">Update Event</code>， 最后终于能采到数据了。</p>

<p>另外需要注意配置中的几个点：</p>

<ul>
  <li>DMA 配置需要在 ADC 配置之前。</li>
  <li>ADC 的外部触发需要定义为上升沿触发， 这一点可以在数据手册的 ADC 章节看到。 LL 库需要调用 <code class="language-html highlighter-rouge">LL_ADC_REG_StartConversionExtTrig</code> 函数。</li>
  <li>PWM 有 Mode 1 和 Mode 2 两种， 分别表示计数器在达到 ARR 值之有为有效电平， 以及在达到 ARR 后为有效电平。 因而对于上升沿触发的要求， 需要配置 PWM 的极性为 Mode 1 为 Low， Mode 2 为 High。 这样， Mode 1 有效电平为 Low， 而 Mode 2 有效电平为 High， 均能达到上升沿的效果。</li>
  <li>
    <p>ADC 校准的代码如下所示， 需要注意结合不同的型号进行差异化配置。 F103 要求在校准之前开启 ADC， 并且需要等待 ADC 的电压稳定。</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//* start ADC1</span>
  <span class="n">LL_ADC_Enable</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="c1">// wait until internal voltage reference stable</span>
  <span class="n">delay_nus_72MHz</span><span class="p">(</span><span class="n">LL_ADC_DELAY_TEMPSENSOR_STAB_US</span><span class="p">);</span>

  <span class="c1">// wait at least 2 ADC cycles after ADC power-on but before calibration</span>
  <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="c1">// wait until ADC calibration done</span>
  <span class="n">LL_ADC_StartCalibration</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">LL_ADC_IsCalibrationOnGoing</span><span class="p">(</span><span class="n">ADC1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><a href="https://blog.51cto.com/u_520887/5290076">STM32F0使用LL库实现DMA方式AD采集</a><br />
<a href="https://codeantenna.com/a/1MnFm9oX2G">STM32L476多通道TIM+DMA+ADC采样（LL库）</a><br />
<a href="https://blog.51cto.com/u_15456236/4801335">STM32 定时器触发 ADC 多通道采集，DMA搬运至内存</a><br />
<a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a></p>
</blockquote>

<h2 id="6-速度环调试">6. 速度环调试</h2>

<p>力矩环在电压控制的情况下就是开环的， 因而测试过后就调力矩环的外环电流环。 电流环遇到一个问题就是给定速度后， 电机转到某个位置就会发生明显的卡顿情况， 视觉上的感受就是这个地方电机遇到了一个非常大的阻力停顿了一下， 这在速度为 <code class="language-html highlighter-rouge">10 - 20 rad/s</code> 时非常明显， 整个电机都会因为这个卡顿而发生弹跳。 但一旦速度达到 <code class="language-html highlighter-rouge">40 rad/s</code> 及以上之后， 这种卡顿因为速度的提升会转变为一种高频且轻微的抖动， jitter。</p>

<p>用 PI 控制器几乎没办法解决这个问题， 凑巧的是我到 SimpleFOC 的官方文档看了看， 我发现他们的速度环实际上是用 PID 控制器实现的， 其中微分 Kd 仅为 0.001 大小。 微分的作用就是应对控制量的快速变化， 意识到这一点后我认为速度环电机的电角度的快速变化很可能让 PI 控制器没办法以较快的响应速度稳定到需要控制的角度， 因而产生了控制的滞后， 这在电机上的表现就是卡顿与抖动。 尝试加入了微小的微分量后， 电机的速度环果然稳定了下来并且表现优异。</p>

<h2 id="7-位置环调试">7. 位置环调试</h2>

<h3 id="71-关于位置环的比例控制">7.1 关于位置环的比例控制</h3>

<p>位置环需要对输出到速度环的电机转速进行限制。 另外我发现用 PI 控制器的位置环始终存在着稳态误差， 我在知乎上看到一则解答：</p>

<p><em>当位置环下还有速度环时，速度和位置是对同一个刚体运动的不同数学描述，在物理上其实是同一个量。它们之间只存在严格的数学关系，并没有实际的物理过程。这就意味着位置是速度的积分这一模型是绝对精确的，因此不会产生稳态误差，自然也就不需要积分环节。</em></p>

<p>当然除了对位置环仅需要比例控制外， 这则回答还解释了为什么速度环和电流环都需要积分环节去调节其中的非线性环节。 根据这则回答的指导， 我将 PI 控制转为了 P 控制后， 位置环的稳态误差几乎不存在了。 但是， 位置环在误差及其微小的状态下仍驱动电机在工作， 我认为在 12-bits 的位置反馈下精度过大是没有必要的， 因而我对位置环还引入了一个 <strong>死区</strong>， 限制在误差为 0.05 rad 机械角度以下的情况让位置环的比例控制输出始终为零， 不仅能对电机与电机芯片进行保护， 还能避免电机在某些情况下因为调节精度问题而产生的抖动问题。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// P controller</span>
<span class="kt">float</span> <span class="nf">PID_angle</span><span class="p">(</span><span class="kt">float</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">proportional</span><span class="p">,</span> <span class="n">output</span><span class="p">;</span>

    <span class="c1">// If the 'err' is too small, I don't want the motor to adjust itself.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// u_p  = P *e(k)</span>
    <span class="n">proportional</span> <span class="o">=</span> <span class="n">qfp_fmul</span><span class="p">(</span><span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">pid</span><span class="p">.</span><span class="n">Kp</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">proportional</span><span class="p">;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">velocity_limit</span><span class="p">,</span> <span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">velocity_limit</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="72-位置环与速度环切换的电机跳动问题">7.2 位置环与速度环切换的电机跳动问题</h3>

<p>位置环和速度环切换出现电机的跳动， 也就是切换之后电机基于当前的状态值会产生转动速度， 本质上的原因就是前一个环的状态量没有处理妥当。 如下代码所示， 我是这样解决的：</p>

<ul>
  <li>位置传感器仿照电机初始化时的流程， 让当前的从位置传感芯片的 SPI 获取到的 <code class="language-html highlighter-rouge">raw_angle_data</code> 赋值给 <code class="language-html highlighter-rouge">raw_angle_data_prev</code>， 那么在调用 <code class="language-html highlighter-rouge">get_angle</code> 的时候， 返回值会重新归零。</li>
  <li>获取转轴速度的时候是基于当前的角度以及与上次获取的角度差的， 因而重新更新 <code class="language-html highlighter-rouge">angle_prev</code> 为当前的角度， 那么后续获取 <code class="language-html highlighter-rouge">get_velocity</code> 的时候返回值就为零了， 那么电机的状态中的速度也就归零了。</li>
  <li>另外我们需要更新当前的机械角度值为 <code class="language-html highlighter-rouge">get_shaft_angle</code>， 这是叠加上 Sensor Dir 的机械角度值， 本质上是调用了 <code class="language-html highlighter-rouge">get_angle</code>， 此时的值也归零。</li>
  <li>最后设定位置环的目标位置 <code class="language-html highlighter-rouge">target_angle</code> 为当前的机械角度， 这样就不产生位置误差， 位置环能保持静止。 另外直接设定速度环的 <code class="language-html highlighter-rouge">target_speed</code> 为 0， 这样速度环也没有速度量的输出。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">encoder_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotation_turns_angles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">raw_angle_data_prev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">read_raw_angle</span><span class="p">();</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">angle_prev</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">();</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_speed</span> <span class="o">=</span> <span class="n">get_velocity</span><span class="p">();</span> <span class="c1">// must be zero</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span> <span class="o">=</span> <span class="n">get_shaft_angle</span><span class="p">();</span>
    <span class="c1">// Set current shaft angle as the target angle.</span>
    <span class="c1">// So the motor can stop after motion mode being switched.</span>
    <span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">target_angle</span> <span class="o">=</span> <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">;</span>
    <span class="n">g_vel_ctrl</span><span class="p">.</span><span class="n">target_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外需要注意， Sensor Dir 对机械方向的判断需要保留， 2023-07-30 晚上拆了一下设备重新装上之后， 突然转不起来了。 第二天早上 checkout 到之前的版本， 发现引入位置反馈都转不起来， 发现是 CW 和 CCW 没有设置对， 导致机械角度的方向和电角度方向不一致， 因而电机无法正常旋转。</p>

<blockquote>
  <p><a href="https://www.zhihu.com/question/294695335/answer/493495590">为什么伺服驱动器位置环只有比例控制? - 全力的一度狐的回答 知乎</a></p>
</blockquote>

<h2 id="8-电流环调试">8. 电流环调试</h2>

<p>电流环调试感觉非常困难， 目前没有彻底解决问题。 最开始发现电流环给出的反馈波形非常奇怪， Q 和 D 两轴的波形竟然都是带截止的。 后来一路查到 ADC 转换出来的值， 发现是 A 相的电流采样芯片的放大倍数以及中心点都发生了严重偏移， 更换芯片后两路采样都重新回到了 1.65 V 的参考电压在以正弦波波形在波动。</p>

<p>当时实际调试的时候， 设定 \(^{Q}K_{p}\) 和 \(^{D}K_{p}\) 的值为 0.6 的时候， 转矩设定为 0.6 以上电机才能够平稳旋转， 而这也直接导致套上速度环和位置环后， 在误差较小时电机的运行是不平稳的， 会产生抖动。 我原来想通过 Ki 弥补稳态误差， 但这个给定值非常难找， 经常导致电流环出现不收敛而发生电机转速疯狂飙升的情况。 目前暂时没有解决电流环的调试问题。</p>

<h2 id="x-stm32-ll-库配置踩坑">X. STM32 LL 库配置踩坑</h2>

<p>在网上搜了一番发现 STM32 用 LL 库开发的效率和配置寄存器差不多， HAL 库的封装太多层了， 虽然移植性比较好但效率显著低于 LL 库。 但是， LL 库资源少而且有坑， 不过对于爱折腾的人以及从 51 那套开始习惯读寄存器的人而言， 倒也不是太大的问题。</p>

<h3 id="x1-debug">X.1 Debug</h3>

<p>CubeMX 中的 <code class="language-html highlighter-rouge">SYS</code> 需要配置 <strong>Serial Wire</strong> 才能用 stlink-v2 进行调试。 但是我实际测试用 vscode 的 cortex-debug 插件， 开启这个设置会导致调试偏移到很奇怪的地方， 反倒是不用开也能调试。</p>

<h3 id="x2-tim1-配置-pwm-输出">X.2 TIM1 配置 PWM 输出</h3>

<p>LL 库通过 STM32CubeMX 生成的 TIM1 基础配置存在一定的问题。 见 <code class="language-html highlighter-rouge">Core/Src/tim.c</code> 中对 <code class="language-html highlighter-rouge">Prescaler</code> 以及 <code class="language-html highlighter-rouge">Autoreload</code> 的配置， 会把 <code class="language-html highlighter-rouge">36 - 1</code> 配置成 <code class="language-html highlighter-rouge">36 - LL_TIM_IC_FILTER_FDIV1_N2</code> 怀疑这个与 CubeMX 不支持配置中运算有关系。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Core/Src/tim.c</span>
<span class="kt">void</span> <span class="nf">MX_TIM1_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Prescaler</span> <span class="o">=</span> <span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Autoreload</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 要使能 TIM1 的输出， <code class="language-html highlighter-rouge">LL_TIM_CC_EnableChannel</code>， <code class="language-html highlighter-rouge">LL_TIM_EnableCounter</code>， <code class="language-html highlighter-rouge">LL_TIM_EnableAllOutputs</code> 这几条函数必须逐个使用， 具体含义可以参考 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj4k_zr4ZWAAxUKAt4KHS_0D60QFnoECBwQAQ&amp;url=https%3A%2F%2Fwww.st.com%2Fresource%2Fen%2Fuser_manual%2Fum1850-description-of-stm32f1-hal-and-lowlayer-drivers-stmicroelectronics.pdf&amp;usg=AOvVaw1DzMCa42sT0JPpOP1EH-0j&amp;opi=89978449">ST - Description of STM32F1 HAL and low-layer drivers</a></p>

<blockquote>
  <p><a href="https://www.cnblogs.com/yhpbook/p/yhp_stm32_tim.html">关于STM32CubeMX使用LL库设置PWM输出</a></p>
</blockquote>

<h3 id="x3-spi">X.3 SPI</h3>

<p>需要增加 <code class="language-html highlighter-rouge">LL_SPI_Enable</code> 函数使能相关的 SPIx 设备。</p>

<p>另外发现一个问题， SPI 的收发需要共用一个函数（纯发送不用， 我在 OLED 中测试过）， 这是因为 SPI 从机没有自己的 SCLK 时钟， 这就需要主机提供。 而双工 SPI 的接收和发送是用两套缓存空间的， 因而可以通过主机向从机发送相应的字节提供 SCLK 时钟， 才能进行同步进行数据接收。 因而， 磁编码器的 SPI 接收函数是这样的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">spi2_transmit_rw</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">outdata</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// wait until the SPI Tx buffer to be empty</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">LL_SPI_TransmitData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">,</span> <span class="n">outdata</span><span class="p">);</span>
    <span class="c1">// wait for 16 bits data receiving complete</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_RXNE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">LL_SPI_ReceiveData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可算是懂了为什么磁编码器的数据手册里面 MOSI 是全 0 的数据了。 不过忘记买磁铁了， 调了半个晚上以为电机轴承那边是有磁性的， 结果一直读到 error 的数据， 后来问了好兄弟才知道那块地方是钢， 他推荐我实现 <strong>无感 FOC</strong>， 外贴磁铁会影响电机的磁场可能会有问题。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_42832780/article/details/96424775">STM32 SPI发送与接收用一个函数实现的问题 - VX13260562029 CSDN</a></p>
</blockquote>

<h3 id="x4-dma">X.4 DMA</h3>

<p>DMA 的配置需要在任何主配置， 如 USART， SPI 这些配置之前完成， 当时 USART 接收有问题， 看网上资料把 DMA 的配置放到了 USART 配置之前就解决问题了。</p>

<h4 id="x41-usart-dma">X.4.1 USART DMA</h4>

<p>USART 的 DMA 开启有几个 LL 库的函数需要注意：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Enable DMA Mode for reception</span>
<span class="n">LL_USART_EnableDMAReq_RX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
<span class="c1">// Enable DMA Mode for transmission</span>
<span class="n">LL_USART_EnableDMAReq_TX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
</code></pre></div></div>

<p>除此之外， 对于配置了 <code class="language-html highlighter-rouge">NORMAL</code> 类型的 DMA 传输， 需要在下一次 DMA 传输开启之前重新配置 <strong>传输的内存地址</strong> 以及 <strong>传输的数据大小</strong>。 值得注意的是， 在配置之前需要 <strong>失能</strong> 相关的 DMA 通道， 另外 <strong>传输的数据大小</strong> 和该传输方向定义的数据宽度相关。 也就是说， 如果此时我定义了 DMA 从外设到内存的传输数据宽度为 <code class="language-html highlighter-rouge">Byte</code>， 那么这个传输的数据大小若设置为 4 则表示传输 4 个字节。 若定义的数据宽度为 <code class="language-html highlighter-rouge">HalfWord</code>， 则传输的数据大小为 4 表示传输 4 个半字 （2 个字节）。</p>

<h3 id="x5-重定向-printf">X.5 重定向 printf</h3>

<p>还得是知乎大佬 <a href="https://zhuanlan.zhihu.com/p/369380259">STM32用gcc编译printf重定向到串口 - gyx鑫 知乎</a> 这篇文章， 除了如下更改还需要在串口初始化的时候调用 <code class="language-html highlighter-rouge">setvbuf(stdout, NULL, _IONBF, 0)</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">__io_putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_USART_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">LL_USART_TransmitData8</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span> <span class="c1">// avoid unused warning</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__io_putchar</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="x6-printf-浮点输出">X.6 printf 浮点输出</h3>

<p>但是这种办法还不能输出 float 浮点数， 这是因为 STM32 默认是关闭浮点输出的， STM32 社区论坛有一条帖子说明， 通过如下链接指令打开 GCC 中的浮点打印的编译。 但是， 我自己测试之后还是无法输出 float 类型， 即便将优化等级调整为 <code class="language-html highlighter-rouge">-O0</code>。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_link_options</span><span class="p">(</span>LINKER:-u _printf_float<span class="p">)</span>
</code></pre></div></div>

<p>尝试了很多办法， Vofa+ 上位机程序应该对接收进行了解析所以才能输出 float 类型数据， 直接通过串口一个个发 4 bytes 的 float 还得自己去转换太麻烦了， 干脆就转成整数相关类型输出算了。</p>

<p><em><strong>2023-08-04 UPDATE:</strong></em> 这个编译选项还是需要打开的， 我后来在 OLED 中使用 <code class="language-html highlighter-rouge">sprintf</code> 做浮点数转义的时候， 如果不开启这个编译选项是无法成功将 float 类型转为字符串类型的。</p>

<blockquote>
  <p><a href="https://community.st.com/t5/stm32-mcu-products/printf-and-float/td-p/108690">printf and float - ST Community</a><br />
<a href="https://community.st.com/t5/stm32cubeide-mcu/how-to-use-float-in-printf/td-p/323872/page/2">how to use float in printf? - ST Community</a><br />
<a href="https://stackoverflow.com/questions/28746062/snprintf-prints-garbage-floats-with-newlib-nano">snprintf() prints garbage floats with newlib nano - StackOverflow</a>\</p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 驱动板开发的记录， 涉及 STM32 配置， 所用器件， 以及相关通信协议。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 8</title><link href="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 8" /><published>2023-07-15T00:00:00+08:00</published><updated>2023-07-15T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/15/rcore-note-ch8</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html"><![CDATA[<blockquote>
  <p>这个章节整理完 Tutorial 还有一个与 I/O 设备管理相关的第九章， 准备之后慢慢琢磨然后不断扩展内核功能， 连续一个月高强度 rCore 的学习心理上有些浮躁了。 最近想把多年未竟的 FOC 项目捡起来好好研究一下， 顺带用上 FreeRTOS 用另一个角度看 OS。</p>
</blockquote>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第八章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/">[ch8]</a> <code class="language-html highlighter-rouge">TODO</code></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-thread-coroutine-os">1. Thread Coroutine OS</h2>

<p>Thread Coroutine OS 增加了在用户态管理的用户态线程/用户态协程， 以及在内核态管理的用户态线程。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/thread-coroutine-os-detail.png" alt="Thread Coroutine OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Thread Coroutine OS details, rCore</u></font>
</div>

<h3 id="11-线程">1.1 线程</h3>

<p><strong>线程</strong> 能够将一个进程内多个可并行执行的任务通过能细粒度的方式被操作系统调度， 实现进程内的并发执行。 进程是线程的资源容器， 线程成为了程序的基本执行实体。 一个进程可以包含多个线程， 同属于一个进程的线程能够共享进程的资源， 如地址空间， 文件等。 线程基本上由线程ID、 执行状态、 当前指令指针(PC)、 寄存器集合和栈组成。</p>

<p>线程能被操作系统或用户态调度器独立调度（Scheduling）， 分派（Dispatch）， 执行（Perform）， 并且由于同一个进程下多个线程同属于一块地址空间并共享资源， 相比较进程之间的 IPC 机制通信， 线程可以通过 <strong>共享内存</strong> 进程数据交互， 之前在做 CUDA 课程的大作业的时候深有感触， 用好线程 <strong>归约</strong> 能让计算效率几何倍提升。</p>
<blockquote>
  <p>基于 CUDA 语言的热扩散仿真模型： <a href="https://github.com/HangX-Ma/CUDA-HeatTransfer-3D">CUDA-HeatTransfer-3D</a>， 有兴趣的同学可以看看 <em>CUDA By Example</em> 这本书了解 CUDA 并行计算。</p>
</blockquote>

<p>但线程最大的问题就是需要 <strong>保持共享资源数据一致性</strong>， 修改数据可能会因为多个线程执行顺序的不可预知而产生 <strong>竞态条件（Race Condition）</strong>， 这是调度的不可控导致的， 而进程独享一片地址空间而不会与其他进程产生数据的地址交叉， 虽然也会被操作系统调度， 但不会遇到这样的问题。</p>

<p>为了解决访问与改写共享资源带来的问题， 操作系统需要提供一些保障机制， 如 <strong>互斥锁（Mutex Lock）</strong>， <strong>信号量（Semaphore）</strong>， <strong>条件变量（Condition Variable）</strong> 等， 这也是这个章节 rCore 所需要解决的第二个问题 —— 为线程提供上述保障。</p>

<h3 id="12-用户态的线程管理">1.2 用户态的线程管理</h3>

<p>用户态的线程管理不受操作系统的约束， 这种线程一般被称为 <strong>Green Threads</strong>， 这与协作式调度非常类似， 线程的管理权限全都交由用户。 rCore 这样设计了线程的基本结构：</p>

<ul>
  <li><strong>线程 ID</strong>： 用以标识与区分不同的线程。</li>
  <li><strong>执行状态</strong>： 同样分为 <strong>空闲（Available）</strong>， <strong>Ready（就绪）</strong>， 以及 <strong>Running（正在执行）</strong>。</li>
  <li><strong>栈</strong>： 为分配每个线程的运行函数栈。</li>
  <li><strong>上下文</strong>： 根据 RISC-V 的函数调用约定需要保存 Callee 寄存器， 同时需要保存 PC 指针以保证执行地址的正常切换。</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>            <span class="c1">// 线程ID</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>       <span class="c1">// 栈</span>
    <span class="n">ctx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>     <span class="c1">// 当前指令指针(PC)和通用寄存器集合</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span>         <span class="c1">// 执行状态</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">TaskContext</span> <span class="p">{</span>
    <span class="c1">// 15 u64</span>
    <span class="n">x1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//ra: return address，即当前正在执行线程的当前指令指针(PC)</span>
    <span class="n">x2</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//sp</span>
    <span class="n">x8</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s0,fp</span>
    <span class="n">x9</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s1</span>
    <span class="n">x18</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//x18-27: s2-11</span>
    <span class="n">x19</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">x27</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">nx1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//new return address, 即下一个要执行线程的当前指令指针(PC)</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">Available</span><span class="p">,</span> <span class="c1">// 初始态：线程空闲，可被分配一个任务去执行</span>
    <span class="n">Running</span><span class="p">,</span>   <span class="c1">// 运行态：线程正在执行</span>
    <span class="n">Ready</span><span class="p">,</span>     <span class="c1">// 就绪态：线程已准备好，可恢复执行</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 对用户态的线程管理通过如下几个函数完成：</p>

<ul>
  <li><strong>线程初始化</strong>
    <ul>
      <li><code class="language-html highlighter-rouge">Runtime::new</code>： 创建当前处于 <code class="language-html highlighter-rouge">Running</code> 的一个主线程， 并将剩余的线程资源初始化为 <code class="language-html highlighter-rouge">Available</code> 以向量的形式存储在 <code class="language-html highlighter-rouge">Runtime</code> 结构体中方便后续的资源线程创建和管理。</li>
      <li><code class="language-html highlighter-rouge">Runtime::init</code>： 传递 Runtime 对象的地址至全局变量 <em>RUNTIME</em>， 方便其他函数获取相应的资源线程。</li>
    </ul>
  </li>
  <li><strong>线程创建</strong>
    <ul>
      <li><code class="language-html highlighter-rouge">Runtime::spawn</code>： 在存储线程资源的向量中查找一个状态为 <code class="language-html highlighter-rouge">Available</code> 的空闲线程， 为调度准备 <em>old return address</em> 以及 <em>new return address</em> 并分配新的空间并设置栈顶的位置， 在返回前将该线程状态设置为 <code class="language-html highlighter-rouge">Ready</code>。
        <blockquote>
          <p>实际上这里的 <em>old return address</em> 被设置为了 <code class="language-html highlighter-rouge">guard</code> 函数的地址， 该函数内部调用了 <code class="language-html highlighter-rouge">t_return</code> 将当线程的状态重新设置为 <code class="language-html highlighter-rouge">Available</code> 后会调用 <code class="language-html highlighter-rouge">t_yield</code> 进行线程的切换。 这种设计的作用在讲述 <strong>线程切换</strong> 后再详细说明。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>线程切换</strong>
  线程切换应当是调度中最重要的一个模块， 主要功能由 <code class="language-html highlighter-rouge">Runtime::t_yield</code> 以及 <code class="language-html highlighter-rouge">switch</code> 这两个函数提供。 之前提及的 <code class="language-html highlighter-rouge">Runtime::t_return</code>， <code class="language-html highlighter-rouge">Runtime::guard</code> 以及 <code class="language-html highlighter-rouge">Runtime::yield_task</code> 都封装了 <code class="language-html highlighter-rouge">Runtime::t_yield</code> 以完成相应的调度的功能。</p>

    <ul>
      <li><code class="language-html highlighter-rouge">Runtime::t_yield</code>： 从当前位置开始查找一个状态为 <code class="language-html highlighter-rouge">Ready</code> 的线程， 没找到会返回 false。 如果当前的线程不是 <code class="language-html highlighter-rouge">Available</code>（说明在 <code class="language-html highlighter-rouge">Running</code>） 就将当前的线程重新放到 <code class="language-html highlighter-rouge">Ready</code> 数组中， 另外就是将找到的 <code class="language-html highlighter-rouge">Ready</code> 线程切换为 <code class="language-html highlighter-rouge">Running</code>。 最后调用 <code class="language-html highlighter-rouge">switch</code> 交换新旧线程的上下文。</li>
      <li>
        <p><code class="language-html highlighter-rouge">switch</code>： 完成对 <code class="language-html highlighter-rouge">Runtime::t_yield</code> 未进行切换的 <em>当前指令指针(PC)、 通用寄存器集合和栈</em> 的切换， 关键的任务切换在于如何对 PC 指针进行切换。 <code class="language-html highlighter-rouge">x1(ra)</code> 寄存器保存着当前 <code class="language-html highlighter-rouge">switch</code> 函数的返回地址， rCore 设计从 offset 为 0x00 到 0x68 的寄存器都按序存储， 其中也包括了 <code class="language-html highlighter-rouge">ra</code>。 而在 offset 0x70 的位置又存储了一次 <code class="language-html highlighter-rouge">ra</code>， 其作用也很明显， 后续 <code class="language-html highlighter-rouge">ld t0, 0x70(a1)</code> 这句指令载入了新的 Context 中的 <code class="language-html highlighter-rouge">ra</code>， 通过 <code class="language-html highlighter-rouge">jr t0</code> 就能在 switch 之后直接跳转到新的指令运行的位置。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[naked]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">switch</span><span class="p">(</span><span class="n">old</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// a0: _old, a1: _new</span>
    <span class="nd">asm!</span><span class="p">(</span>
        <span class="s">"
        sd x1, 0x00(a0)
        ...
        sd x1, 0x70(a0)

        ld x1, 0x00(a1)
        ...
        ld t0, 0x70(a1)

        jr t0
    "</span><span class="p">,</span>
        <span class="nf">options</span><span class="p">(</span><span class="n">noreturn</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>线程执行</strong>
    <ul>
      <li><code class="language-html highlighter-rouge">Runtime::run</code>： 用一个 while 循环调用 <code class="language-html highlighter-rouge">t_yield</code> 进行调度， 所有线程执行完后会退出。</li>
    </ul>
  </li>
</ul>

<p>从整体的 rCore 线程设计可以看出， 线程的调度几乎就是按序执行， 所以 <code class="language-html highlighter-rouge">Runtime::spawn</code> 会放入一个 <code class="language-html highlighter-rouge">guard</code> 函数地址作为 <em>old return address</em> 以释放线程资源， 因为当下一次线程位置又切换到这个线程的时候， 实际上该线程已处理完了。 这个设计只能等当前运行的线程主动让出处理器使用权后， 线程管理运行时才能切换检查。</p>

<p>具体实现细节不表了， rCore 在 <code class="language-html highlighter-rouge">user/src/bin/ch8b_stackful_coroutine.rs</code> 中实现了对用户态的线程管理。</p>

<h3 id="13-内核态的线程管理">1.3 内核态的线程管理</h3>

<p>内核态的线程管理扩展了时钟中断， 能基于时钟中断来直接打断当前用户态线程的运行， 实现对线程的调度和切换等。 rCore 在该章节对进程的结构进行了细化， 通过线程来表示对处理器的虚拟化， 使得进程成为了管理线程的容器。 虽然没有父子关系， 但多个线程中的第一个创建的线程一般被称为主线程， 并被分配 0 号进程标识符（TID）。</p>

<p>除了主线程仍然是从程序入口点开始执行， 其余的 <strong>线程的生命周期都与一个函数进行一次绑定</strong>， 从这个角度而言， 主线程其实和进程的声明周期绑定了。</p>

<p>除了具备前述用户态线程的基本特性， rCore 设计的线程模型额外具备如下功能：</p>

<ul>
  <li>线程有三种状态：就绪态、 运行态和阻塞态（阻塞这个知识点解答了我对 poll 函数的疑惑！）；</li>
  <li>线程可以被操作系统调度以分时占用 CPU；</li>
  <li>线程可动态创建与退出；</li>
  <li>线程能通过系统调用获得操作系统的服务， 但 <strong>进程系统调用</strong> 和 <strong>线程系统调用</strong> 不能混用。</li>
</ul>

<blockquote>
  <p>rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html">线程模型与重要系统调用</a> 章节对理解线程模型和设计非常关键。</p>
</blockquote>

<h4 id="131-线程系统调用">1.3.1 线程系统调用</h4>

<ul>
  <li>
    <p><strong>线程创建</strong> 的系统调用 <code class="language-html highlighter-rouge">sys_thread_create</code> 通过 <strong>TID(Thread Identifier)</strong> 区分不同线程， 与进程的 PID 设计很类似， 内核会为每个线程分配专属资源： 用户栈、 Trap 上下文还有内核栈， 前两个在进程地址空间中， 内核栈在内核地址空间中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_thread_create</span><span class="p">(</span><span class="n">entry</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong>线程管理</strong> 通过 TID， <code class="language-html highlighter-rouge">gettid</code> 系统调用能获取当前线程的 TID。</li>
  <li><strong>线程退出</strong> 通过 <code class="language-html highlighter-rouge">exit</code> 系统调用完成， 约定线程从绑定的函数返回的时候都需要调用 <code class="language-html highlighter-rouge">exit</code> 通知操作系统进行资源回收， 更细粒度的线程取代了进程的作为操作系统的调度单元。</li>
  <li><strong>线程资源回收</strong> 通过 <code class="language-html highlighter-rouge">waittid</code> 回收收线程占用的用户态和内核态资源。 这个工作一般是进程/主线程完成， 但若是 <strong>主线程</strong> 调用了 <code class="language-html highlighter-rouge">exit</code> <strong>其子线程</strong> 都会全部退出， 被 <strong>父进程</strong> 回收资源。</li>
</ul>

<p>rCore 之前描述的线程模型提到不能混用进程和线程的系统调用， 原因在于其设计对线程和进程进行了分离。 若是调用了 <code class="language-html highlighter-rouge">sys_thread_create</code> 生成子线程就只考虑多个线程在一个进程内的交互， 如果涉及到父子进程的交互， 就等价为进程模型。</p>

<h4 id="132-软硬件资源管理">1.3.2 软硬件资源管理</h4>

<p>主要干了三件事儿。</p>

<ol>
  <li>
    <p>把原来分配 PID 的数据结构用更通用的 <code class="language-html highlighter-rouge">RecycleAllocator</code> 描述， 能为 PID 以及 TID 分配提供描述结构。 PID 的分配还是延续之前章节， 使用 <code class="language-html highlighter-rouge">PID_ALLOCATOR</code> 这个全局变量。 而线程归属于进程容器， 所以在每个进程控制块的内部可变结构 <code class="language-html highlighter-rouge">ProcessControlBlockInner</code> 中占据一个变量位置， 由进程控制块 <code class="language-html highlighter-rouge">ProcessControlBlock</code> 进行管理。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/process.rs</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
     <span class="c1">// immutable</span>
     <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
     <span class="c1">// mutable</span>
     <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="p">}</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除了 TID 之外， 每个线程都有自己独立的用户栈和 Trap 上下文， 且它们在所属进程的地址空间中的位置可由 TID 计算得到。 新的进程地址空间如下所示：</p>

    <div align="center">
     <img src="/norobots/images/2023-07-15-rcore-note-ch8/app-as-full-with-threads.png" alt="Process address space with threads, rCore" width="600" />
     <br />
     <font size="2" color="#999"><u>Process address space with threads, rCore</u></font>
 </div>

    <p>这个就和第三章的结构非常类似了， 为此 rCore 提供了 <code class="language-html highlighter-rouge">trap_cx_bottom_from_tid</code> 以及 <code class="language-html highlighter-rouge">ustack_bottom_from_tid</code> 这两个函数索引每个线程的用户栈以及 Trap 上下文的具体位置。</p>
  </li>
  <li>
    <p>线程资源整合 <code class="language-html highlighter-rouge">TaskUserRes</code>， 将线程的 TID 、用户栈和 Trap 上下文与线程打包， 由于声明周期一致， 能够进行统一的资源分配和回收。</p>
  </li>
  <li>
    <p>内核栈不再与 PID 或 TID 挂钩， 而与 <code class="language-html highlighter-rouge">kstack_id</code> 这个新的内核标识符相关。 需要增加一个 <code class="language-html highlighter-rouge">KSTACK_ALLOCATOR</code> 的通用资源分配器对内核标识符进行分配。</p>
  </li>
</ol>

<h4 id="133-进程和线程控制块">1.3.3 进程和线程控制块</h4>

<p>对进程和线程两块资源进行分离， 线程已经成为了 CPU 资源的调度单位， 因而与代码执行相关的内容则分配至 <code class="language-html highlighter-rouge">TaskControlBlock</code> 中。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">process</span><span class="p">:</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kstack</span><span class="p">:</span> <span class="n">KernelStack</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">res</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TaskUserRes</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">trap_cx_ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>进程控制块中则保留进程内所有线程共享的资源：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/process.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">is_zombie</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">memory_set</span><span class="p">:</span> <span class="n">MemorySet</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">fd_table</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">File</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tasks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
    <span class="o">...</span> <span class="c1">// 其他同步互斥相关资源</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="134-结语">1.3.4 结语</h4>

<p>任务管理器 <code class="language-html highlighter-rouge">TaskManager</code> 与处理器管理结构 <code class="language-html highlighter-rouge">Processor</code> 仅在接口上有所改变。 线程相关的数据结构的实现可以直接阅读 rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html#id19">线程管理机制的设计与实现</a> 章节因而不赘述了。 若是从 chapter7 过渡到 chapter8， 到此时的改写还不足以支撑操作系统的正常运行， 还需添加线程管理的相关机制。</p>

<h2 id="2-sync-mutex-os">2. Sync Mutex OS</h2>

<p>Sync Mutex OS 增加了 <strong>互斥锁（Mutex）</strong>、 <strong>信号量（Semaphore）</strong> 和 <strong>条件变量（Condvar）</strong> 这三种资源， 并提供了与这三种同步互斥资源相关的系统调用。 这样多线程应用就可以使用这三种同步互斥机制来解决各种同步互斥问题， 如生产者消费者问题、 哲学家问题、 读者写者问题等。 在完成对操作系统的线程改写之后， 其实就遇到了引入线程带来的共享资源的访问问题， Thread Coroutine OS 与 Sync Mutex OS 耦合关系较强， 后者是前者功能性的延续。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/syncmutex-os-detail.png" alt="Sync Mutex OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Sync Mutex OS details, rCore</u></font>
</div>

<p>共享资源 (Shared Resources) 是多个线程均能够访问的资源， 线程对于共享资源进行操作的那部分代码被称为 <strong>临界区 (Critical Section)</strong>， 多线程访问共享资源要求这种访问是互斥的。 这与 Rust 的引用是非常类似的， 可变引用只能同时间有一个， 这是因为改引用具备 <strong>写权限</strong>， 而不可变引用仅有 <strong>读权限</strong>， 可以说， <strong>写操作</strong> 才是导致共享资源需要互斥访问的根源。</p>

<p>现代指令集架构提供了 <strong>原子指令(Atomic Instruction)</strong> 保护单内存位置的简单操作， 原子指令涉及到数据的 <strong>读，改，写</strong>， 只是将临界区的范围缩小为一条指令， 这意味着原子指令无法被打断， 这是由硬件层面提供相应的保障。 但对于复杂的数据结构， 简单的原子指令就无能为力了。</p>

<h3 id="21-互斥锁">2.1 互斥锁</h3>

<p><em>锁</em> 是附加在一种共享资源上的一种标记， 具有 <strong>上锁</strong> 和 <strong>空闲</strong> 这两种状态。 对共享资源的访问采用锁的机制后， 在进入临界区之前需要获取锁， 之后再访问临界区的共享资源， 在离开临界区时释放锁， 这三个步骤中如何获取锁是关键。 rCore 用以下指标权衡锁的实现：</p>

<ol>
  <li><strong>忙则等待：</strong> 当一个线程占有锁之后也就占有了共享资源， 其他线程必须等待该线程释放锁才能有机会获取锁， 以进入临界区。</li>
  <li><strong>空闲则入：</strong> 资源空闲且有线程尝试进入临界区， 则操作系统能在一定时间内选择一个线程。</li>
  <li><strong>有界等待：</strong> 要求每个线程在较大时间尺度上对锁的占有是公平的， 每个线程都有获取锁的机会而不会因为获取不到锁进入 <strong>饥饿(Starvation)</strong> 态。</li>
</ol>

<h4 id="211-软件锁的尝试">2.1.1 软件锁的尝试</h4>

<p>rCore 尝试在用户态通过软件的办法实现锁， 如下代码所示尝试使用 <code class="language-html highlighter-rouge">OCCUPIED</code> 这个全局变量表示锁。 可以看到没有获取到锁之前 CPU 会在 while 循环内忙等， 这种策略被称为 <strong>自旋</strong>， 在正确的实现中自旋锁会保证该过程不会被操作系统的调度打断。 在单核操作系统上， 自旋会造成极大的资源浪费， 在分配的一个时间片中， 第一次执行判断后陷入自旋， 由于没有外部量对这个判断条件中的数据进行更改， 自旋的条件始终成立， 相当于这个时间片都会被自旋所浪费。</p>

<p>在该实现中， <code class="language-html highlighter-rouge">OCCUPIED</code> 实际成了一种共享资源， 操作系统可以随时打断当前线程的运行调度到另一个线程， 可以发现这样一种情况： T0 线程发现 <code class="language-html highlighter-rouge">OCCUPIED = false</code> 后准备将 <code class="language-html highlighter-rouge">OCCUPIED</code> 修改为 <code class="language-html highlighter-rouge">true</code> (5 - 6 行之间)， 此时突然被操作系统打断调度到 T1 线程， 会导致 T1 也认为其具备进入临界区的权限进而尝试修改 <code class="language-html highlighter-rouge">OCCUPIED</code> 的值。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// user/src/bin/adder_simple_spin.rs</span>
<span class="k">static</span> <span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="nd">vload!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OCCUPIED</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">OCCUPIED</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">OCCUPIED</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了解决这个问题， rCore 详细介绍了适用于单核的 Peterson 多标记算法保证两个线程之间的互斥访问， 除此之外还有适用双线程的 Dekkers 算法， 以及多线程的 Eisenberg &amp; McGuire 算法。 但这些算法都具有时代的局限性， 在当前多核系统上使用需要付出极大的资源代价， 并且还很难理解。</p>

<h4 id="212-硬件锁机制">2.1.2 硬件锁机制</h4>

<p>事实上， 硬件层面为我们提供了锁的机制的支持， 包括 <strong>关闭中断</strong> 与 <strong>原子指令</strong>。</p>

<p><strong>关闭中断</strong> 在 MCU 裸机环境下经常会用到， 操作系统的抢占式调度是由时钟中断触发， 因而关闭中断能够防止线程在临界区被操作系统调度。 但是， 下放中断权限可能导致恶意的用户资源占用（恶意永久关闭中断）； 且对于 RISC-V 多特权级架构而言， 用户态对 S-Mode 和 M-Mode 的中断修改会导致异常； 另外， 关闭中断在多核 CPU 上仅仅是关闭了当前 CPU 的中断， 并不能阻止其他 CPU 的线程进入临界区。</p>

<p><strong>原子指令</strong> 在之前提到过， 它的执行无法被操作系统打断， <strong>原子指令是整个计算机系统中最根本的原子性和互斥性的来源</strong>。 比较常见的指令有 <strong>CAS（Compare-And-Swap）</strong> 以及 <strong>TAS（Test-And-Set）</strong>。 这两条是我之前一直没太理解的， 还有 RISC-V 的 <strong>（Load Reserved / Store Conditional） LR/SC</strong> 原子指令， rCore 对此解释的非常清晰。</p>

<ul>
  <li><strong>CAS（Compare-And-Swap）：</strong> 其基本用法是 <code class="language-html highlighter-rouge">CAS rd, rs1, rs2, rs3</code>， <code class="language-html highlighter-rouge">rs1</code> 中是内存存放的某个值 <em>source</em>， 这个值会与 <code class="language-html highlighter-rouge">rs2</code> 中的 <em>expected</em> 值进行比较， 若 <em>source == expected</em> 则将 <code class="language-html highlighter-rouge">rs1</code> 的值替换为 <code class="language-html highlighter-rouge">rs3</code> 中的 <em>new</em> 值。 <code class="language-html highlighter-rouge">rs1</code> 最开始存储的 <em>source</em> 值会被存入 <code class="language-html highlighter-rouge">rd</code> 目标寄存器， 这不受比较结果影响。
    <blockquote>
      <p>具体的使用例程可以参考 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/2lock.html#cas-tas">常用的 CAS 和 TAS 指令</a> 部分 <code class="language-html highlighter-rouge">adder_atomic.rs</code> 部分。</p>
    </blockquote>
  </li>
  <li>
    <p><strong>TAS（Test-And-Set）：</strong> 其基本用法是 <code class="language-html highlighter-rouge">TAS rd, rs1, rs2</code>， <code class="language-html highlighter-rouge">rs1</code> 中是内存存放的某个值 <em>source</em>， 他会被直接设置为 <code class="language-html highlighter-rouge">rs2</code> 中的 <em>expected</em> 值， 而 <code class="language-html highlighter-rouge">rd</code> 返回 <code class="language-html highlighter-rouge">rs1</code> 中原来的 <em>source</em> 值。 这个设计也能实现自旋锁， 以如下伪代码为例， 如果有多个线程执行 TAS 原子指令， 仅有一个线程的输入 <code class="language-html highlighter-rouge">OCCUPIED</code> 的值为 0， 那么 TAS 返回会为 0， 该线程就能退出循环进入后续的临界区， 而其他的线程只会看到 <code class="language-html highlighter-rouge">OCCUPIED</code> 值为 1 而陷入 while 的自旋中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static</span> <span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="nf">TAS</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>LR（Load Reserved）：</strong> 其基本用法是 <code class="language-html highlighter-rouge">LR rd, rs1</code>， 将 <code class="language-html highlighter-rouge">rs1</code> 内存中存放的值写入 <code class="language-html highlighter-rouge">rd</code> 寄存器中。 该指令不能单独使用， 需要配合 SC 指令。</p>
  </li>
  <li><strong>SC（Store Conditional）：</strong> 其基本用法是 <code class="language-html highlighter-rouge">SC rd, rs1, rs2</code>， 将 <code class="language-html highlighter-rouge">rs1</code> 的值 <em>source</em> 修改为 <code class="language-html highlighter-rouge">rs2</code> 中存放的 <em>new</em> 值， 若修改成功 <code class="language-html highlighter-rouge">rd</code> 返回 0， 否则 <code class="language-html highlighter-rouge">rd</code> 返回任意值。 修改的前提是 LR 和 SC 指令之间， 之前 LR 指令中 <code class="language-html highlighter-rouge">rs1</code> 内存的值没有改变， 这通过 RISC-V 框架下的 <strong>保留集（Reservation Set）</strong> 进行判断。</li>
</ul>

<p>在 RISC-V 架构中可以通过 LR/SC 指令是实现 CAS/TAS 指令的功能。</p>

<h4 id="213-让权等待">2.1.3 让权等待</h4>

<p>在涉及到上述这种某种条件不满足就需要在原地 <strong>等待</strong> 的情况， 操作系统设计了多种等待方式， 包括 <strong>忙等</strong>， <strong>yield 调度</strong>， <strong>阻塞</strong>。</p>

<ul>
  <li><strong>忙等</strong>
    <ul>
      <li><strong>优点：</strong> 在忙等有意义的前提下， 忙等的优势是在条件成立的第一时间就能够进行响应， 对于事件的响应延迟更低， 实时性更好， 而且不涉及开销很大的上下文切换。</li>
      <li><strong>缺点：</strong> 它的缺点则是不可避免的会浪费一部分 CPU 资源在忙等上， 且单核环境下会浪费一整个时间片。</li>
    </ul>
  </li>
  <li><strong>yield 调度</strong>
    <ul>
      <li><strong>优点：</strong> 让出 CPU 资源， 避免忙等对 CPU 的占用。</li>
      <li><strong>缺点：</strong> 增加了上下文切换的次数， 而上下文切换开销很大， 并且会破坏缓存资源（刷新 TLB）造成缓存命中率降低， 若 yield 非常频繁这种情况更会加剧。 另外， yeild 可能会导致当前事件的响应延时过久造成响应时间不可接收的局面。</li>
    </ul>
  </li>
  <li><strong>阻塞</strong>
    <ul>
      <li><strong>优点：</strong> 操作系统可标记需要等待事件的线程为 <strong>阻塞态</strong>， 并将该线程从调度器队列移除， 而在等待事件到来后唤醒该线程将其加入就绪队列， 操作系统可以定义唤醒后的线程在队列中的优先级进行优先资源配置。 由于不参与调度， 因此阻塞不会浪费时间片， 以及造成上下文开销。</li>
      <li><strong>缺点：</strong> 机制比较复杂， 并且难以避免地产生两次上下文切换（调度器移除与移入）， 在事件产生频率较高的时候不如忙等来的划算。</li>
    </ul>
  </li>
</ul>

<p>rCore 实现了 Sync Mutex OS 中的 <strong>阻塞 - 唤醒</strong> 机制， 具体原理参考 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/2lock.html#id18">实现阻塞与唤醒机制</a>。 但需要注意的是， rCore 的实现是在单核 CPU 上， 并且 RISC-V 架构规定从用户态陷入内核态之后所有（内核态）中断默认被自动屏蔽， 因而在内核中实现 Mutex 仅需要用单标记而无需使用原子指令。</p>

<h3 id="22-信号量机制">2.2 信号量机制</h3>

<p>信号量机制能够满足线程的同步要求， 即 A 线程执行到某个阶段后， B 线程通过信号量可以继续向下执行， 或者， 可以通过信号量使 N 个线程具备在临界区中访问共享资源的需求， 这些都是纯粹的 Mutex 互斥锁无法做到的。 实际上， 信号量在实现的时候还会用到 <strong>互斥锁和原子指令</strong>， 它是更高一级的同步互斥机制， 在特殊情况下， 信号量甚至与互斥锁等价。</p>

<p>信号量支持两种操作：<strong>P 操作（Proberen， 表示尝试）</strong> 和 <strong>V 操作（Verhogen ，表示增加）</strong>，P 操作表示线程尝试占用一个资源， 而与之匹配的 V 操作表示线程将占用的资源归还， 这同样基于 <strong>阻塞 - 唤醒</strong> 机制实现。</p>

<ul>
  <li>当进行 P 操作的时候， 如果此时没有可用的资源， 则当前线程会被阻塞；</li>
  <li>当进行 V 操作的时候， 如果返还之后有了可用的资源， 且此时有线程被阻塞， 那么就可以考虑唤醒它们。</li>
</ul>

<p>信号量的初始资源可用数量 N 是一个非负整数，它决定了信号量的用途。</p>

<ul>
  <li><code class="language-html highlighter-rouge">N &gt; 0</code>， 称其为 <strong>计数信号量 (Counting Semaphore)</strong> 或 <strong>一般信号量 (General Semaphore)</strong>， 当 <code class="language-html highlighter-rouge">N = 1</code> 时， 称其为 <strong>二值信号量 (Binary Semaphore)</strong>， 其与互斥锁等价。</li>
  <li>
    <p><code class="language-html highlighter-rouge">N = 0</code>， 信号量与资源管理无关， 但可用作同步量。 如下图， 在线程 A 需要等待的时候可以对该信号量进行 P 操作， 于是线程会被阻塞。 在线程 B 执行完指定阶段之后再对该信号量进行 V 操作就能够唤醒线程 A 向下执行。 但需要注意 <strong>唤醒丢失</strong> 的问题。</p>

    <div align="center">
      <img src="/norobots/images/2023-07-15-rcore-note-ch8/semaphore-sync.png" alt="Semaphore sync, rCore" width="400" />
      <br />
      <font size="2" color="#999"><u>Semaphore sync, rCore</u></font>
  </div>
  </li>
</ul>

<p>除了作为同步原语解决同步问题， rCore 还介绍了一个基于有限缓冲协作的 <strong>生产者与消费者</strong> 问题， 其实就是利用了信号量共享资源计数， 在无资源能进行阻塞的特点， 但还需注意的是， 共享资源仍需要通过互斥锁进行保护。 详见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/3semaphore.html#id8">生产者和消费者问题</a>。 虽然信号量解决了条件同步和生产者与消费者问题， 但对程序员而言要求较高， 其开发和阅读都具备一定难度。</p>

<h3 id="23-条件变量机制">2.3 条件变量机制</h3>

<p>信号量与互斥锁的组合虽然能解决一些问题， 但其仍存在局限性：</p>

<ul>
  <li>信号量本质上为一个整数， 无法描述所有类型的等待事件或等待条件；</li>
  <li>信号量需要 P 和 V 组合使用， 还容易导致死锁问题。</li>
</ul>

<p>rCore 实现了 <strong>条件变量 + 互斥锁</strong> 这样一个组合来模拟 <strong>管程</strong> 的实现， 以打破上述组合的局限性。 <strong>管程 (Monitor)</strong> 最早在 Pascal 语言中实现， 现在的 C 以及 Rust 并没有相关的实现机制， 由过程（现在的函数）、共享变量及数据结构等组成。 程序员可以自定义管程的过程和共享资源， 通过过程间接访问这些共享资源。</p>

<p>管程仍是通过互斥锁满足 <strong>互斥访问</strong> 的需求， 另外还支持线程间的同步机制， 通过 <strong>阻塞-唤醒</strong> 实现条件同步。 阻塞和唤醒就是所谓的 <strong>条件变量</strong>， 而在管程的概念中将条件变量的阻塞和唤醒操作分别叫做 <code class="language-html highlighter-rouge">wait</code> 和 <code class="language-html highlighter-rouge">signal</code> 。 一个管程中可以有多个不同的条件变量， 每个条件变量代表多线程并发执行中需要等待的一种特定的条件， 并保存所有阻塞等待该条件的线程。</p>

<p>这里的 <code class="language-html highlighter-rouge">wait</code> 和 <code class="language-html highlighter-rouge">signal</code> 有比较特殊的设计：</p>

<ul>
  <li><strong>wait</strong>： <code class="language-html highlighter-rouge">wait</code> 操作会阻塞当前的线程， 但 <strong>不能在持有锁的情况下陷入阻塞</strong>， 在管程过程中线程是持有锁的， 因而 <code class="language-html highlighter-rouge">wait</code> 需要做两件事： 释放锁， 然后阻塞线程。</li>
  <li><strong>signal</strong>： <code class="language-html highlighter-rouge">signal</code> 则是唤醒当前的线程， 处于互斥访问的需求， 线程被唤醒后需要获取锁， 然后再 <code class="language-html highlighter-rouge">wait</code> 返回继续执行。</li>
</ul>

<p>由于互斥锁的存在， signal 操作也不只是简单的唤醒操作。 rCore 介绍了基于线程优先级条件的三种唤醒操作语义： Hoare， Hansen， Mesa， 详情可见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/4condition-variable.html#id4">管程与条件变量</a>。 在 rCore 内核中实现的是 Mesa 语义， Mesa 语义涉及到锁的竞争， 因而 wait 操作返回之时不见得线程等待的条件一定成立， 有必要重复检查确认之后再继续执行。</p>

<p>另外， rCore 介绍了条件变量的两种用法 <strong>条件同步问题</strong> 以及 <strong>同步屏障问题</strong>， 尤其同步屏障问题在多线程编程中会经常遇到， 深有体会。 对此可详见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/4condition-variable.html#id6">条件变量的使用方法</a> 学习。</p>

<p>TODO…</p>]]></content><author><name>HangX-Ma</name></author><category term="Rust" /><category term="rCore" /><summary type="html"><![CDATA[第八章：并发， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 7</title><link href="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 7" /><published>2023-07-13T00:00:00+08:00</published><updated>2023-07-13T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/13/rcore-note-ch7</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html"><![CDATA[<p>该章节尝试建立基于文件的统一I/O抽象， 将标准输入/标准输出的访问改造为基于文件描述符， 然后同样基于文件描述符实现一种父子进程之间的通信机制 —— <strong>管道</strong>， 从而实现灵活的进程间通信， 并基于文件抽象和管道支持不同的独立进程之间的动态组合来实现复杂功能。</p>

<dl>
  <dt>管道</dt>
  <dd>一种数据交换的机制， 管道可被视为一种特殊的内存文件， 在进程被打开的 <em><strong>fd_table</strong></em> 中被管理。 管道通过复用文件读写的系统函数调用可以方便地进行数据交换。</dd>
  <dt>信号</dt>
  <dd>进程间通信的一种异步通知机制， 可以看成是一个应用发出某种信号， 希望另外一个应用能及时响应。</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/ipc-os-detail-2.png" alt="IPC OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>IPC OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第七章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch7">[ch7]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件抽象">1. 文件抽象</h2>

<p><strong>文件</strong> 抽象统一了对 I/O 设备的管理， <strong>Everything is a file</strong> 的思想继承于 Multics OS 的 <strong>通用性</strong> 文件设计。 操作系统不关心文件的具体内容， 而只关心如何对文件按字节流进行读写。 rCore 对此进行了举例， 例如 <strong>键盘设备</strong> 对操作系统而言就是一个只读文件（读取键盘的输入数据）， <strong>屏幕设备</strong> 是只写文件（输出图片文字等信息） 等等。 在该章节基于文件的抽象， rCore 对标准输入和标准输出进行了重构， 为其实现了 <code class="language-html highlighter-rouge">File Trait</code>， 使得进程能按照文件的接口与 I/O 外设交互。</p>

<p>一般来说， 文件的会涉及到， <code class="language-html highlighter-rouge">open</code>， <code class="language-html highlighter-rouge">close</code>， <code class="language-html highlighter-rouge">read</code>， <code class="language-html highlighter-rouge">write</code> 这些基本操作。</p>

<p>另外， 进程被创建的时候内核会默认打开三个缺省的文件， 这个设计对于后续的 I/O 重定向而言非常重要。</p>

<ul>
  <li><code class="language-html highlighter-rouge">fd: 0</code> 标准输入</li>
  <li><code class="language-html highlighter-rouge">fd: 1</code> 标准输出</li>
  <li><code class="language-html highlighter-rouge">fd: 2</code> 标准错误输出</li>
</ul>

<p>需要注意的是， 子进程需要继承其父进程的所有的文件描述符与父进程共享所有文件， 基于这个设计， <code class="language-html highlighter-rouge">pipe</code> 管道机制能够让父子进程共用一套标准输入和输出接口， 这样就构成了进程之间通信的基本桥梁。</p>

<h2 id="2-管道">2. 管道</h2>

<p>管道的设计就是基于以上文件抽象实现的几种机制， 其本质可被描述为一个 <strong>环形的缓冲队列</strong>， 具备 <strong>读端</strong> 和 <strong>写端</strong>， 读写两端通过不同的文件描述符进行访问。 通过文件抽象， 我们能对读写进行权限控制， 控制数据的流向。 另外， 只有读写两端都关闭后管道的资源才能被回收， 这要求除了实现 <code class="language-html highlighter-rouge">sys_pipe</code> 系统调用， 还需要实现 <code class="language-html highlighter-rouge">sys_close</code> 对文件的关闭进行控制。</p>

<p>rCore 对管道的设计分为端口设计与缓存设计。</p>

<ul>
  <li><strong>端口设计</strong> <code class="language-html highlighter-rouge">struct Pipe</code>， 通过实现 <code class="language-html highlighter-rouge">File Trait</code> 使得这两个端口能够通过文件描述符进行访问。</li>
  <li><strong>缓存设计</strong> <code class="language-html highlighter-rouge">struct PipeRingBuffer</code>， 实际就是维护了一个环形的缓存队列。 值得注意的是 <code class="language-html highlighter-rouge">struct Pipe</code> 用 <code class="language-html highlighter-rouge">Arc<span class="nt">&lt;Mutex</span><span class="err">&lt;</span><span class="na">PipeRingBuffer</span><span class="nt">&gt;</span>&gt;</code> 维护对 <code class="language-html highlighter-rouge">PipeRingBuffer</code> 的强引用计数， 这能保证在读写两端都被关闭后 <code class="language-html highlighter-rouge">PipeRingBuffer</code> 中的资源能够被自动回收， 而 <code class="language-html highlighter-rouge">PipeRingBuffer::write_end</code> 维护了一个弱引用计数， 这是为了后续检查写端是否全部被关闭的依据。</li>
</ul>

<blockquote>
  <p>只有写端都被关闭后才能保证没有数据被遗漏， 此时读端的关闭才是安全的。 另外， 写端实际是对读端存在依赖的， 若仅有一个写端， pipe 的缓冲区一定会耗尽， 而只存在一个读端却没什么问题， 大不了每次读返回都是 0。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/fs/pipe.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pipe</span> <span class="p">{</span>
    <span class="n">readable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">writable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">PipeRingBuffer</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PipeRingBuffer</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">RING_BUFFER_SIZE</span><span class="p">],</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">RingBufferStatus</span><span class="p">,</span>
    <span class="n">write_end</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">Pipe</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">enum</span> <span class="n">RingBufferStatus</span> <span class="p">{</span>
    <span class="n">FULL</span><span class="p">,</span>
    <span class="n">EMPTY</span><span class="p">,</span>
    <span class="n">NORMAL</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-标准-io-重定向">3. 标准 I/O 重定向</h2>

<p>重定向的想法在于对 <code class="language-html highlighter-rouge">fd</code> 文件描述符进行替换。 由前述内容可知， 新建进程默认打开三个缺省的文件描述符分别描述标准输入(0)， 标准输出(1)， 标准错误输出(2)， 文件描述符分配有一条重要的性质： <em><strong>必定分配可用描述符中编号最小的一个</strong></em>， 而 <code class="language-html highlighter-rouge">sys_dup</code> 做的工作就是将当前的文件拷贝到一个新的文件描述符。 所以， 例如我们先通过 <code class="language-html highlighter-rouge">sys_close</code> 关闭标准输入， 那么再调用 <code class="language-html highlighter-rouge">sys_dup(current_fd)</code> 就能让 <code class="language-html highlighter-rouge">fd=1</code> 的位置的内容被替换为当前的目标文件。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/fs.rs</span>

<span class="cd">/// 功能：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中。</span>
<span class="cd">/// 参数：fd 表示进程中一个已经打开的文件的文件描述符。</span>
<span class="cd">/// 返回值：如果出现了错误则返回 -1，否则能够访问已打开文件的新文件描述符。</span>
<span class="cd">/// 可能的错误原因是：传入的 fd 并不对应一个合法的已打开文件。</span>
<span class="cd">/// syscall ID：24</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_dup</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.acquire_inner_lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="o">&gt;=</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">new_fd</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.alloc_fd</span><span class="p">();</span>
    <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">new_fd</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()));</span>
    <span class="n">new_fd</span> <span class="k">as</span> <span class="nb">isize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了能让用户端使用重定向， rCore 对 <code class="language-html highlighter-rouge">user_shell</code> 进行了改进使其支持用户参数输入。 另外 <code class="language-html highlighter-rouge">sys_exec</code> 需要取出这些传入的命令行参数， 放入 <code class="language-html highlighter-rouge">args_vec: Vec<span class="nt">&lt;String&gt;</span></code> 中作为参数传入 <code class="language-html highlighter-rouge">TaskControlBlock::exec</code> 中， 这些参数会被压入用户栈中。 压栈的主体代码如下代码所示， 为了更清晰的表示压栈的过程， 我绘制了压栈的过程图， 假设压入了两个命令行参数 <code class="language-html highlighter-rouge">aa</code> 和 <code class="language-html highlighter-rouge">bb</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">impl</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">exec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">elf_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// push arguments on user stack</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">argv_base</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">argv</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">args</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">arg</span><span class="p">|</span> <span class="p">{</span>
                <span class="nf">translated_refmut</span><span class="p">(</span>
                    <span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span>
                    <span class="p">(</span><span class="n">argv_base</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">usize</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">args</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.as_bytes</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// make the user_sp aligned to 8B for k210 platform</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">user_sp</span> <span class="o">%</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="o">...</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="nf">.len</span><span class="p">();</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv_base</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack1.png" alt="Push stack process 1, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 1, HangX-Ma</u></font>
</div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack2.png" alt="Push stack process 2, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 2, HangX-Ma</u></font>
</div>

<p>压栈完成后 rCore 将 <code class="language-html highlighter-rouge">TrapContext</code>中的 <code class="language-html highlighter-rouge">a0</code> 和 <code class="language-html highlighter-rouge">a1</code> 两个寄存器的值分别设置为输入参数的数量以及前述的 <code class="language-html highlighter-rouge">argv_base</code>。 这样， 在应用第一次进入用户态的时候， 放在 Trap 上下文 <code class="language-html highlighter-rouge">a0</code> 和 <code class="language-html highlighter-rouge">a1</code> 两个寄存器中的内容可以被用户库中的入口函数以参数的形式接收。 rCore 在 <code class="language-html highlighter-rouge">_start</code> 入口函数对这些起始地址做了转化， 将其转化为编写应用的时候看到的 <code class="language-html highlighter-rouge"><span class="err">&amp;</span>[<span class="err">&amp;</span>str]</code> 的形式。</p>

<h2 id="4-信号">4. 信号</h2>

<p>信号机制补足了单向事件通知的机制， 这是一种类似于硬件中断的软件级异步通知机制， 使得进程在接收到特定事件的时候能够暂停当前的工作并及时响应事件， 并在响应事件之后可以恢复当前工作继续执行。 如果进程没有接收到任何事件， 它可以执行自己的任务。 这里的暂停与恢复的工作， 都由操作系统来完成， 应用程序只需设置好响应某事件的事件处理例程就够了。</p>

<p>信号的 <strong>接收方</strong> 是一个进程。 当某进程或操作系统发出信号时，会指定信号响应的对象， 即某个进程的 <code class="language-html highlighter-rouge">pid</code>， 并由该进程预设的信号处理例程来进行具体的信号响应。 接收到信号有多种处理方式， 最常见的三种如下：</p>

<ul>
  <li>
    <p><strong>忽略</strong>：就像信号没有发生过一样。</p>
  </li>
  <li>
    <p><strong>捕获</strong>：进程会调用相应的处理函数进行处理。</p>
  </li>
  <li>
    <p><strong>终止</strong>：终止进程。</p>
  </li>
</ul>

<p>而信号的 <strong>发送方</strong> 有两个：</p>

<ul>
  <li><strong>异步信号</strong>： 进程在正常执行， 此时可能内核或者其他进程给它发送了一个信号， 这些就属于异步信号。</li>
  <li><strong>同步信号</strong>： 由进程自身的执行触发， 在处理 Trap 的时候内核会将相应的信号直接附加到进程控制块中， 这种属于同步信号。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/signal.png" alt="Signal process, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Signal process, rCore</u></font>
</div>

<p>内核会在 Trap 处理完成即将返回用户态之前检查要返回到的进程是否还有信号待处理。 如果需要处理的话，取决于进程是否提供该种信号的处理函数， 若没有提供该函数内核会接管进行默认处理， 整体流程如上图所示。</p>

<h3 id="41-信号相关的数据结构">4.1 信号相关的数据结构</h3>

<p>进程间发送的信号是某种事件， UNIX 采用了整数来对信号进行编号， 这些整数编号都定义了对应的信号的宏名， 宏名都是以 SIG 开头， 比如 SIGABRT, SIGKILL, SIGSTOP, SIGCONT。 rCore 定义了一个 <code class="language-html highlighter-rouge">SignalFlags</code> 类型用以描述这些信号量的集合， 这个数据结构会大量应用到信号处理相关的功能上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">bitflags!</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalFlags</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">SIGDEF</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Default signal handling</span>
        <span class="k">const</span> <span class="n">SIGHUP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">SIGINT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="o">...</span>
        <span class="k">const</span> <span class="n">SIGSYS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外为了处理收到的信号， rCore 定义了 <code class="language-html highlighter-rouge">SignalAction</code> 结构， 其中 <code class="language-html highlighter-rouge">handler</code> 记录了信号处理的回调函数的入口地址， <code class="language-html highlighter-rouge">mask</code> 则表示在处理该函数时需要屏蔽的其他信号的掩码， 这样内核就不会对这些信号进行处理而是直接回到用户态继续执行回调函数， 但这些被屏蔽的信号会被记录在 TCB 中延后处理。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Action for a signal</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">16</span><span class="nd">))]</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalAction</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">handler</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-信号的产生">4.2 信号的产生</h3>

<p>如前所述， 信号产生有异步信号和同步信号， rCore 将其分作三类， 前两类是异步信号， 最后一类是同步信号。</p>

<ol>
  <li>进程通过 <code class="language-html highlighter-rouge">kill</code> 系统调用给自己或者其他进程发送信号。</li>
  <li>内核检测到某些事件给某个进程发送信号， 但这个事件与接收信号的进程的执行无关。</li>
  <li>进程执行的时候触发了某些条件， 于是在 Trap 到内核处理的时候， 内核给该进程发送相应的信号。 典型的就是 <code class="language-html highlighter-rouge">SIGSEGV</code> 段错误和 <code class="language-html highlighter-rouge">SIGILL</code> 非法指令。</li>
</ol>

<h4 id="kill-系统调用">kill 系统调用</h4>

<p>实现 <code class="language-html highlighter-rouge">kill</code> 系统调用发送信号， 需要现在 TCB 中加入 <code class="language-html highlighter-rouge">SignalFlags</code> 用以记录当前进程收到了哪些信号还未处理。 该系统调用的实现不算复杂， 我们需要给 <code class="language-html highlighter-rouge">manager.rs</code> 中增添 <code class="language-html highlighter-rouge">PID2TCB</code> 全局变量， 这个全局变量是一个 <strong>BtreeMap</strong> 数据结构， 在每次 <code class="language-html highlighter-rouge">add_task</code> 的时候建立当前进程 pid 与当前进程的 TCB 的映射。 这样在实现 <code class="language-html highlighter-rouge">sys_kill</code> 的时候能通过 <code class="language-html highlighter-rouge">pid2task</code> 获取到对应的 TCB。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_kill</span><span class="p">(</span><span class="n">pid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">pid2task</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// insert the signal if legal</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task_ref</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.contains</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.insert</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是， 如果 <code class="language-html highlighter-rouge">TaskControlBlockInner::signals</code> 中已经记录了未处理的信号， 在这个信号被处理之前不能加入同一个信号的待处理量。</p>

<h4 id="内核信号生成">内核信号生成</h4>

<p>就是将之前说的 <code class="language-html highlighter-rouge">SIGSEGV</code> 以及 <code class="language-html highlighter-rouge">SIGILL</code>， 在捕获到相应的 trap 之后， 内核主动对 <code class="language-html highlighter-rouge">TaskControlBlockInner::signals</code> 进行修改补充。</p>

<h3 id="43-信号的处理">4.3 信号的处理</h3>

<p>与信号处理相关的系统调用则有三个：</p>

<ul>
  <li><code class="language-html highlighter-rouge">sys_sigaction</code>：设置信号处理例程</li>
  <li><code class="language-html highlighter-rouge">sys_procmask</code>： 设置进程的信号屏蔽掩码</li>
  <li><code class="language-html highlighter-rouge">sys_sigreturn</code>： 清除栈帧，从信号处理例程返回</li>
</ul>

<p>需要在 <code class="language-html highlighter-rouge">TaskControlBlock</code> 中增加 <code class="language-html highlighter-rouge">signal_mask</code> 以及 <code class="language-html highlighter-rouge">signal_actions</code> 这两个变量用以屏蔽其他信号量以及记录如何对前述 <code class="language-html highlighter-rouge">TaskControlBlockInner::signals</code> 记录的信号进行响应。 因而可以看到， <code class="language-html highlighter-rouge">SignalActions</code> 实际上是个信号数量匹配的数组， 数组类型是 <code class="language-html highlighter-rouge">SignalAction</code> 这样就能将信号量与待处理函数进行一一对应。 需要说明的是 <code class="language-html highlighter-rouge">TaskControlBlockInner::signal_mask</code> 声明了在该进程内会屏蔽的信号， 而 <code class="language-html highlighter-rouge">SignalAction::mask</code> 是该回调函数会屏蔽的信号， 二者需要做 <strong>或</strong> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signal_mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signal_actions</span><span class="p">:</span> <span class="n">SignalActions</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// os/src/task/action.rs</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalActions</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">SignalAction</span><span class="p">;</span> <span class="n">MAX_SIG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>进程可以通过 <code class="language-html highlighter-rouge">sys_sigaction</code> 系统调用捕获某种信号， 暂停进程当前的执行， 调用进程为该种信号提供的函数对信号进行处理， 处理完成之后再恢复进程原先的执行。 可以看到 <code class="language-html highlighter-rouge">prev_action</code> 中存储着之前的处理例程（回调函数）， 需要将这部分内容存放在 <code class="language-html highlighter-rouge">old_action</code> 中， 而将 <code class="language-html highlighter-rouge">action</code> 中的内容替换进 table 中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigaction</span><span class="p">(</span>
      <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
      <span class="n">action</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">SignalAction</span><span class="p">,</span>
      <span class="n">old_action</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">SignalAction</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="o">...</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nf">check_sigaction_error</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">old_action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">let</span> <span class="n">prev_action</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
          <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">old_action</span><span class="p">)</span> <span class="o">=</span> <span class="n">prev_action</span><span class="p">;</span>
          <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="nf">translated_ref</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
          <span class="mi">0</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-html highlighter-rouge">sys_procmask</code> 就没啥好说的， 把传入进来的 flags 设置好就行。</p>
  </li>
  <li>
    <p><code class="language-html highlighter-rouge">sys_sigreturn</code> 的实现在逻辑上也不复杂， 更新 <code class="language-html highlighter-rouge">TaskControlBlockInner::handling_sig</code> 并恢复保存在 <code class="language-html highlighter-rouge">trap_ctx_backup</code> 中的上下文， 需要注意的是返回的时候是 <code class="language-html highlighter-rouge">trap_ctx.x[10]</code>， 这是为了避免上下文返回时原来的 <code class="language-html highlighter-rouge">a0</code> 返回值被覆盖而出现返回值变更的问题。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/syscall/process.rs</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigreturn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
          <span class="n">inner</span><span class="py">.handling_sig</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="c1">// restore the trap context</span>
          <span class="k">let</span> <span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.get_trap_cx</span><span class="p">();</span>
          <span class="o">*</span><span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.trap_ctx_backup</span><span class="nf">.unwrap</span><span class="p">();</span>
          <span class="n">trap_ctx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="k">as</span> <span class="nb">isize</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>关于 <code class="language-html highlighter-rouge">handle_signals</code> 包括的一系列内容详见 rCore 的指导书， 并没有太多疑问。</p>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="进程通信邮箱">进程通信：邮箱</h4>

<p>没有测例也不知道写的对不对， 基本上就是魔改一下 Pipe 的环形缓冲队列就整完了。</p>

<blockquote>
  <p>具体可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/e9b19e5f19851f12bcae83531a050d60230abd08">commit#e9b19e5</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="Rust" /><category term="rCore" /><summary type="html"><![CDATA[第七章：进程间通信与 I/O 重定向， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 6</title><link href="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 6" /><published>2023-07-10T00:00:00+08:00</published><updated>2023-07-10T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/10/rcore-note-ch6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html"><![CDATA[<blockquote>
  <p>文件系统这块的内容还是相当复杂的， 当时学 xv6 就是一知半解把 lab 草草做完了事儿了， 结果这几个月调设备的时候遇到用 SPI Nand Flash 的设备， 文件系统挂载不上等问题。 自己对 Block Device， VFS， 以及 inode 这些概念的理解都不是很到位， 调试非常痛苦到最后陷入了死胡同， 借着学习 rCore 的机会争取把这块搞懂， 毕竟从头搭一个 OS 要对细节有更好的把握。</p>
</blockquote>

<p><code class="language-html highlighter-rouge">easy-fs</code> 自下而上大致可以分成五个不同的层次：</p>

<dl>
  <dt>磁盘块设备接口层</dt>
  <dd>定义了以块大小为单位对磁盘块设备进行读写的 trait 接口</dd>
  <dt>块缓存层</dt>
  <dd>在内存中缓存磁盘块的数据， 避免频繁读写磁盘</dd>
  <dt>磁盘数据结构层</dt>
  <dd>磁盘上的超级块、 位图、 索引节点、 数据块、 目录项等核心数据结构和相关处理</dd>
  <dt>磁盘块管理器层</dt>
  <dd>合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构， 以及基于这些结构进行文件系统的创建等操作， 以及对磁盘块进行分配和回收处理</dd>
  <dt>索引节点层</dt>
  <dd>管理索引节点（即文件控制块）数据结构， 并实现文件创建/文件打开/文件读写等成员函数， 以向上支持文件操作相关的系统调用</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/fsos-fsdisk.png" alt="Filesystem OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Filesystem OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第六章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch6">[ch6]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件系统">1. 文件系统</h2>

<p>文件系统交互的主要对象是磁盘这类的存储器， 这类存储器和 RAM 的管理方式不同， 这类存储器以扇区 （一般为 512 bytes） 进行读写， 以块为单位进行存储 （一个块为由多个扇区组成）。 文件系统的职责就是将逻辑上的目录树结构映射存储到这类存储器中并进行管理。 另外， 为了适配管理多个文件系统， 在此基础上抽象出一层 <strong>虚拟文件系统（VFS, Virtual File System）</strong> 提供统一的接口和目录树的通用格式方便进行管理。</p>

<h2 id="2-块设备接口层">2. 块设备接口层</h2>

<p>文件系统以块为单位进行数据管理， 一般我们会通过 <strong>块设备驱动</strong> 完成对磁盘的数据的存取， 这需要文件系统提供接口对接驱动， 这种方式以二者职能为分界进行了层次化处理。 在 rCore 中提供 <code class="language-html highlighter-rouge">BlockDevice</code> 抽象接口， 不过需要注意的是， 这个接口实现了 <code class="language-html highlighter-rouge">Send</code>， <code class="language-html highlighter-rouge">Sync</code>， <code class="language-html highlighter-rouge">Any</code> 这几个 trait。 前两个见过面， 用以保证数据的线程安全， 但我目前还是不太理解下面这两句：</p>

<ul>
  <li><em>A type is Send if it is safe to send it to another thread.</em></li>
  <li><em>A type is Sync if it is safe to share between threads (<code class="language-html highlighter-rouge">T</code> is Sync if and only if <code class="language-html highlighter-rouge"><span class="err">&amp;</span>T</code> is Send).</em></li>
</ul>

<p>由于 Rust 编译器需要知道 trait 实现时的具体大小， 因而 rCore 后续使用的时候都是以 <code class="language-html highlighter-rouge">Arc<span class="nt">&lt;dyn</span> <span class="na">BlockDevice</span><span class="nt">&gt;</span></code> 表明该 trait 类型， 被 <code class="language-html highlighter-rouge">Arc</code> 引用包裹的静态大小是已知的， 这样编译器可以保证引用指向已分配堆的 <code class="language-html highlighter-rouge">BlockDevice</code>， 同时还需要使用 <code class="language-html highlighter-rouge">dyn</code> 关键字。</p>

<p>用到 <code class="language-html highlighter-rouge">Any</code> 与 <code class="language-html highlighter-rouge">BlockDevice</code> 是一个 trait 类型相关。 <code class="language-html highlighter-rouge">Any</code> 的存在实现了 Rust 语言的部分的反射功能， 获得变量的类型 <code class="language-html highlighter-rouge">TypeId</code>， 判断变量是否是指定类型， 转换该类型， 获取类型名称等， 具体的作用后续阅读代码再补充。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_dev.rs</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">BlockDevice</span> <span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="n">Any</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
    <span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">The Rustonomicon - 8.2. Send and Sync</a><br />
<a href="https://rustwiki.org/zh-CN/rust-by-example/trait/dyn.html">通过例子学 Rust 中文版 - 16.2. 使用 dyn 返回 trait</a><br />
<a href="https://www.jianshu.com/p/28386b52c607">Rust std-any 模块详解</a></p>
</blockquote>

<h2 id="3-块缓存层">3. 块缓存层</h2>

<p>块缓存层的存在是为了减少块设备频繁读写的开销， 相较于直接从 RAM 中获取数据， 读写磁盘的速度还是太慢了， 因而我们在软件层面实现块的缓存以加快数据的读写。 但缓存还得解决缓存一致性以及同步性等问题， rCore 使用块缓存全局管理器解决这些问题， 并通过该管理器一次性让更多的块合并操作， 这是因为连续的块的操作能够加速存取速度。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">],</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">modified</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每个 BlockCache 缓存一个磁盘块， 这是一个最小单位， rCore 提供了一些对缓存管理的方法：</p>

<ul>
  <li><strong>new</strong>： <code class="language-html highlighter-rouge">BlockCache</code> 实现了 <code class="language-html highlighter-rouge">new</code> 方法创建从磁盘读取一个 Block 到缓冲区。 前述所言， Block 大小和 Sector 大小一致均为 512 bytes， 这也是缓冲区 <code class="language-html highlighter-rouge">cache</code> 被设置为 <code class="language-html highlighter-rouge">BLOCK_SZ</code> 大小的原因。</li>
  <li><strong>addr_of_offset</strong>： 获取 <code class="language-html highlighter-rouge">cache</code> 数组偏移 <code class="language-html highlighter-rouge">offset</code> 大小的字节地址。</li>
  <li><strong>get_ref， get_mut</strong>： 通过调用 <code class="language-html highlighter-rouge">addr_of_offset</code> 获取地址后， 将该地址声明为不可变或可变引用。</li>
</ul>

<p>rCore 将 <code class="language-html highlighter-rouge">BlockCache::get_ref</code> 和 <code class="language-html highlighter-rouge">BlockCache::get_mut</code> 封装成了 <code class="language-html highlighter-rouge">BlockCache::read</code> 以及 <code class="language-html highlighter-rouge">BlockCache::modify</code> 这两个泛型， 这两个函数后续用到非常多， 后面结合具体代码进行解释。 但从代码的构成而言， <code class="language-html highlighter-rouge">read/modify</code> 构成了传入闭包 f 的一层执行环境，让它能够绑定到一个缓冲区上执行。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_ref</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>rCore 实现了很多与 <code class="language-html highlighter-rouge">BlockCache</code> 相关的操作方法详见 Tutorial， 这里仅对个人疑难点做记录以及梳理思路。</p>
</blockquote>

<p>rCore 用 FIFO 作为简单的缓存替换策略并限定了缓存区的大小， <strong>块缓存全局管理器</strong> 完成了上述所说的缓存管理的功能。 值得注意的是缓存队列中存储的是 <strong>块编号</strong> 和 <strong>块缓存</strong> 组。 块缓存类型是 <code class="language-html highlighter-rouge">Arc<span class="nt">&lt;Mutex</span><span class="err">&lt;</span><span class="na">BlockCache</span><span class="nt">&gt;</span>&gt;</code>， 共享引用保证在当前 <strong>块缓存全局管理器</strong> 中保留一个引用外（FIFO 剔除缓存的依据）， 缓存请求者能够对缓存进行访问， 而 Mutex 则避免在后续多核拓展时的访存冲突。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCacheManager</span> <span class="p">{</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-html highlighter-rouge">struct BlockCacheManager</code> 实现了一个 <code class="language-html highlighter-rouge">get_block_cache</code> 的方法， 通过将全局实例 <code class="language-html highlighter-rouge">BLOCK_CACHE_MANAGER</code> 封装， 其他模块能够方便地调用 <code class="language-html highlighter-rouge">get_block_cache</code> 获取 <code class="language-html highlighter-rouge">block_id</code> 对应的缓存块， 但需要注意的是返回类型是 <code class="language-html highlighter-rouge">Arc<span class="nt">&lt;Mutex</span><span class="err">&lt;</span><span class="na">BlockCache</span><span class="nt">&gt;</span>&gt;</code> 调用者还需要通过 <code class="language-html highlighter-rouge">.lock()</code> 方法获取互斥锁才能对 <code class="language-html highlighter-rouge">BlockCache</code> 进行操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="n">BLOCK_CACHE_MANAGER</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.get_block_cache</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">block_device</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="4-磁盘布局及磁盘上数据结构">4. 磁盘布局及磁盘上数据结构</h2>

<p>前面几个部分比较好理解， 个人认为这个小节和 inode 小节最为关键且复杂。 要理解磁盘布局先得理解几个概念：</p>

<dl>
  <dt>索引节点(Inode, Index Node)</dt>
  <dd>Inode 编码了文件/目录的底层编号， 这个数据结构包含文件大小， 访问权限， 文件类型等信息， 还包含对数据的索引信息， 通过这些索引信息就能够找到数据块存储在磁盘上的位置。</dd>
  <dt>位图(Bitmap)</dt>
  <dd>位图用以标注索引节点以及数据块的分配情况， 通过位图能够方便分配和回收在磁盘上的存储资源。</dd>
</dl>

<p>rCore 中的磁盘布局如下图所示， 他们是以 Block ID 顺序排布的， 后续根据这个顺序对关键数据结构进行阐述。 这里需要注意的是， rCore 的假定内核仅管理一个块设备， 否则仅以 Block ID 作为标识， 在访问多个不同的块设备的时候会引起歧义。</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/layouts.png" alt="Disk Layouts, HangX-Ma" width="800" /><a id="disk-layouts"></a>
    <br />
    <font size="2" color="#999"><u>Disk Layouts, HangX-Ma</u></font>
</div>

<h3 id="41-super-block">4.1 Super Block</h3>

<p>一句话可以概括， Super Block 存储了后续四个分区占用的 <strong>块数量</strong>， 并利用 <strong>MAGIC</strong> 验证文件系统的合法性。</p>

<h3 id="42-inodedata-bitmap">4.2 Inode/Data Bitmap</h3>

<p>从磁盘布局可以看出， rCore 通过 <strong>Inode Bitmap</strong> 和 <strong>Data Bitmap</strong> 分别管理索引节点和数据块。 每个 Bitmap 可以占据多个块， 在 rCore 中一个块的大小和一个扇区的大小一致都是 512 bytes， 相当于每个 Bitmap 实际上可以管理 \(4096 \times n\) 个索引节点或数据块。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="n">start_block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">blocks</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">BitmapBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u64</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
</code></pre></div></div>

<p>rCore 教程中的 <code class="language-html highlighter-rouge">struct Bitmap</code> 存储的是 <strong>Inode Bitmap</strong> 或 <strong>Data Bitmap</strong> 在磁盘中的位置和大小的信息， 而这个数据结构本身则是存储在 RAM 中的。 rCore 另外用 <code class="language-html highlighter-rouge">BitmapBlock</code> 数组表示每个 4096-bit 大小的数据块。 理解这个数据结构的设计原理， <code class="language-html highlighter-rouge">struct Bitmap</code> 中的 <code class="language-html highlighter-rouge">alloc</code> 和 <code class="language-html highlighter-rouge">dealloc</code> 两个方法的实现就容易理解了。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            start_block_id(Start ID)
                  v
        ----------+---------------------+--------
                  |//// Bitmap Area ////|
        ----------+---------------------+--------
                                        ^
                             start_block_id + blocks(End ID)
        Block ID =&gt; 
        (increase)
</code></pre></div></div>

<p>这里结合 <code class="language-html highlighter-rouge">alloc</code> 函数阐明 <code class="language-html highlighter-rouge">BlockCache</code> 提供的 <code class="language-html highlighter-rouge">read/modify</code> 方法。 注意 <code class="language-html highlighter-rouge">modify</code> 函数中的闭包， 它显式声明了传入闭包的参数的类型是 <code class="language-html highlighter-rouge"><span class="err">&amp;</span>mut BitmapBlock</code> 这样 <code class="language-html highlighter-rouge">modify</code> 中才能将泛型 <code class="language-html highlighter-rouge">T</code> 实例化为具体的类型 <code class="language-html highlighter-rouge">BitmapBlock</code>。 这样通过声明的 <code class="language-html highlighter-rouge">bitmap_block</code>， 我们实际上能对缓冲区的数据进行更改操作。 如果没有理解 <code class="language-html highlighter-rouge">read/modify</code> 泛型的作用， 闭包中捕获的参数的数据来源就会混淆， 对后续的实验理解造成较大的阻碍。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">const</span> <span class="n">BLOCK_BITS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">BLOCK_SZ</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.blocks</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="nf">get_block_cache</span><span class="p">(</span>
                <span class="n">block_id</span> <span class="o">+</span> <span class="k">self</span><span class="py">.start_block_id</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
                <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nf">.lock</span><span class="p">()</span>
            <span class="nf">.modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> 
            <span class="p">|</span><span class="n">bitmap_block</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BitmapBlock</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">inner_pos</span><span class="p">))</span> <span class="o">=</span> <span class="n">bitmap_block</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.enumerate</span><span class="p">()</span>
                    <span class="nf">.find</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="o">**</span><span class="n">bits64</span> <span class="o">!=</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="p">{</span>
                        <span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="nf">.trailing_ones</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                    <span class="p">})</span> <span class="p">{</span>
                    <span class="c1">// modify cache</span>
                    <span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="n">inner_pos</span><span class="p">;</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">block_id</span> <span class="o">*</span> <span class="n">BLOCK_BITS</span> <span class="o">+</span> <span class="n">bits64_pos</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">inner_pos</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="k">if</span> <span class="n">pos</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="43-inode-blocks">4.3 Inode Blocks</h3>

<p>Inode 存储着每个文件/目录的元数据： 文件/目录大小 <code class="language-html highlighter-rouge">size</code>， 索引节点类型 <code class="language-html highlighter-rouge">type_</code>， 以及对数据块的索引 <code class="language-html highlighter-rouge">direct/indirect1/indirect2</code>。 在虚拟内存映射的章节 rCore 通过三级页表进行索引， 这里的 Inode 索引方式也很类似。 rCore 设计的单个 <code class="language-html highlighter-rouge">DiskInode</code> 的大小是 128 bytes， 也就是 <strong>Inode Blocks</strong> 中每个块能够存储 4 个 <code class="language-html highlighter-rouge">DiskInode</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">const</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">direct</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">indirect1</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">indirect2</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">type_</span><span class="p">:</span> <span class="n">DiskInodeType</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">DiskInodeType</span> <span class="p">{</span>
    <span class="n">File</span><span class="p">,</span>
    <span class="n">Directory</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的多级索引是这样理解的， 分为直接索引 (direct) 和 间接索引 (indirect1/indirect2)。</p>

<ul>
  <li><strong>直接索引</strong> <code class="language-html highlighter-rouge">direct</code> 数组的每一个元素都保存着一个数据块的 Block ID， 这在文件尺寸不大于 <code class="language-html highlighter-rouge">28 * 512 bytes = 14 KiB</code> 时使用。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/direct-index.png" alt="Direct Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Direct Index, HangX-Ma</u></font>
</div>

<ul>
  <li><strong>间接索引</strong>
    <ul>
      <li>装满 <code class="language-html highlighter-rouge">direct</code> 这部分内容后需要用间接索引扩大索引范围。 可以使用 <code class="language-html highlighter-rouge">indirect1</code> 存储一个数据块的 Block ID 获取到这个数据块的内容， 而这个数据块我们不直接保存数据， 而是将其当作一个跳板用来存储其他数据块的 Block ID。 512 bytes 的数据块以 <code class="language-html highlighter-rouge">u32(4 bytes)</code> 为单位， 这个数据块最大能存储 128 个 Block ID， 这样我们还能额外索引到 <code class="language-html highlighter-rouge">128 * 512 bytes = 64 KiB</code> 的数据。</li>
      <li>相同的道理， 一级间接索引和直接索引总共 78 KiB 空间都不够用， 就可以再加上二级间接索引， 通过二级索引先找到一级索引块的 Block ID， 这些一级间接索引指向的每个数据块都不直接保存数据， 而是存储其他数据块的 Block ID， 这样再通过一级索引就能确定最终的数据块， 这种设计能额外索引 8 MiB 的额外内容。</li>
    </ul>
  </li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/indirect-index.png" alt="Indirect Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Indirect Index, HangX-Ma</u></font>
</div>

<p><code class="language-html success highlighter-rouge">NOTE: 关于 get_block_id 的一些疑惑和相关解释</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">inner_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基于直接索引和间接索引， <code class="language-html highlighter-rouge">DiskInode</code> 提供了获取数据块索引的功能的 <code class="language-html highlighter-rouge">get_block_id</code> 函数。 这个函数的接口需要读入一个 <code class="language-html highlighter-rouge">inner_id</code>， 这个并不是对应实际的磁盘的 Block ID 的， 而是根据这个 <code class="language-html highlighter-rouge">inner_id</code> 的大小结合我们存储在 <code class="language-html highlighter-rouge">Inode</code> 中的 <code class="language-html highlighter-rouge">direct</code>， <code class="language-html highlighter-rouge">indirect1</code> 以及 <code class="language-html highlighter-rouge">indirect2</code> 可以获取到对应的数据块所在的 Block ID。</p>
<blockquote>
  <p>那这些数据又是怎么来的？ 通过 <a href="#6-索引节点">6. 索引节点</a>， 中 <code class="language-html highlighter-rouge">struct Inode</code> 提供了 <code class="language-html highlighter-rouge">create</code> 方法。</p>
</blockquote>

<p>对于 <code class="language-html highlighter-rouge">inner_id</code> 可以确定是使用直接索引还是间接索引， 直接索引 <code class="language-html highlighter-rouge">direct</code> 范围是 \([0;27]\)，  <code class="language-html highlighter-rouge">indirect1</code> 的范围是 \([28;127]\)， <code class="language-html highlighter-rouge">indirect2</code> 的范围是 \([128;128*128-1]\)。 实际的 <code class="language-html highlighter-rouge">inner_id</code> 和索引方式的分布值如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/inner-id.png" alt="Inner ID, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Inner ID, HangX-Ma</u></font>
</div>

<p>后续关于 <code class="language-html highlighter-rouge">DiskInode</code> 的各种辅助方法就不展开了。</p>

<h3 id="44-data-block--directory">4.4 Data Block / Directory</h3>

<p>对 <strong>文件</strong> 而言其内容就是字节序列， 保存文件内容的数据块可以用字节数组表示。 前述的 Inode 相关的 <code class="language-html highlighter-rouge">read_at</code> 和 <code class="language-html highlighter-rouge">write_at</code> 方法中就是对这些字节数组进行操作。 这里我对 <code class="language-html highlighter-rouge">read_at</code> 以及 <code class="language-html highlighter-rouge">write_at</code> 操作的数据的位置是有疑惑的， 因为 rCore 自下而上编写的这个教学手册， 底层的内容很可能是有上层的包装的 （突然就想起李雅普诺夫判定式了）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">type</span> <span class="n">DataBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">];</span>
</code></pre></div></div>

<p>对 <strong>目录</strong> 而言情况则有所不同， 我们需要建立一种树的结构进行逐级访问。 rCore 设计了 <code class="language-html highlighter-rouge">struct DirEntry</code> 用以存储目录项结构， 其大小为 32 bytes， 这意味着每个 Data Block 可以最多存储 16 个目录项结构。 <code class="language-html highlighter-rouge">name</code> 表示该目录下的一个文件名或子目录目录名， <code class="language-html highlighter-rouge">inode_number</code> 则是这个文件或子目录所对应的 Inode 的节点编号。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">const</span> <span class="n">NAME_LENGTH_LIMIT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DirEntry</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">NAME_LENGTH_LIMIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">inode_number</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">DIRENT_SZ</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-磁盘块管理器">5. 磁盘块管理器</h2>

<p>在前面我们描述了磁盘的布局及其相应的数据结构， 这里就是将这些这些细节进行统筹管理， <code class="language-html highlighter-rouge">struct EasyFileSystem</code> 中所保留的信息正好是 <a href="#disk-layouts">Disk Layouts</a> 中描述的几个部分。 另外， 保留 <code class="language-html highlighter-rouge">block_device</code> 指针引用是方便下层数据结构访问块设备。 可以看到这个数据结构中是不包含 superblock 的， 但是在后续计算的时候需要考虑进去。 从这里开始， 所有的数据结构都存储在内存上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/efs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">EasyFileSystem</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">inode_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="n">inode_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// inode 区域的起始 block id</span>
    <span class="n">data_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// data 区域的起始 block id</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="6-索引节点">6. 索引节点</h2>

<p>服务于文件相关系统调用的索引节点层的代码在 <code class="language-html highlighter-rouge">vfs.rs</code> 中， rCore 抽象了一层 Virtual Filesystem 方便使用者管理文件系统的文件与目录。</p>

<p><code class="language-html highlighter-rouge">Inode</code> 和 <code class="language-html highlighter-rouge">DiskInode</code> 的区别从它们的名字中就可以看出： <code class="language-html highlighter-rouge">DiskInode</code> 放在磁盘块中比较固定的位置，而 <code class="language-html highlighter-rouge">Inode</code> 是放在内存中的记录文件索引节点信息的数据结构。 <code class="language-html highlighter-rouge">Inode</code> 数据结构给使用者直接管理目录树结构中逻辑上的文件和目录的接口。 这个 <code class="language-html highlighter-rouge">Inode</code> 在磁盘上所处的位置用 <code class="language-html highlighter-rouge">block_id</code> 以及 <code class="language-html highlighter-rouge">block_offset</code> 即可表示， <code class="language-html highlighter-rouge">fs</code> 则给 Inode 提供了访问底层文件系统的接口。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Inode</span> <span class="p">{</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 后续还介绍了获取根目录 Inode, 文件索引， 文件列举， 文件创建， 文件清空， 文件读写的方式。 一直到这里把这几个函数读完， 以及将前述的所有内容再细读之后， 我才理清了 <code class="language-html highlighter-rouge">DiskInode</code> 中的数据是如何被创建以及如何被索引管理的， 之前一直没搞懂究竟数据是如何被定位到 Data Block 的， 实际上就是 root_node 创建新的 child node 的时候 (Inode::create) 就通过 <code class="language-html highlighter-rouge">EasyFileSystem::alloc_inode</code> 在 Inode Area 创建了一个新的 Inode， 最开始这个 Inode 是不存在任何数据的(<code class="language-html highlighter-rouge">DiskInode::initialize</code> 返回的是个空的 <code class="language-html highlighter-rouge">DiskInode</code>)， 只有在调用 <code class="language-html highlighter-rouge">Inode::increase_size</code> 之后， 通过 <code class="language-html highlighter-rouge">EasyFileSystem::alloc_data</code> 申请数据块后， 利用 <code class="language-html highlighter-rouge">DiskInode::increase_size</code> 函数将这些数据块和 <code class="language-html highlighter-rouge">direct</code>， <code class="language-html highlighter-rouge">indirect1</code>， 以及 <code class="language-html highlighter-rouge">indirect2</code> 填充并联系起来的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="cd">/// Increase the size of a disk inode</span>
<span class="k">fn</span> <span class="nf">increase_size</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">new_size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">disk_inode</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">DiskInode</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MutexGuard</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">disk_inode</span><span class="py">.size</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">blocks_needed</span> <span class="o">=</span> <span class="n">disk_inode</span><span class="nf">.blocks_num_needed</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">blocks_needed</span> <span class="p">{</span>
        <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">fs</span><span class="nf">.alloc_data</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">disk_inode</span><span class="nf">.increase_size</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.block_device</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="7-课后练习">7. 课后练习</h2>

<h3 id="71-编程练习">7.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="72-实验练习">7.2 实验练习</h3>

<h4 id="硬链接">硬链接</h4>

<p>硬链接要求两个不同的目录项指向同一个文件， 在 easy-fs 中就是两个不同名称目录项指向同一个磁盘块。 需要实现三个系统调用 <code class="language-html highlighter-rouge">sys_linkat</code>， <code class="language-html highlighter-rouge">sys_unlinkat</code>， 以及 <code class="language-html highlighter-rouge">sys_stat</code>。</p>

<p>硬链接需要新的 Inode 的 <code class="language-html highlighter-rouge">block_id</code> 以及 <code class="language-html highlighter-rouge">block_offset</code> 与被链接的对象是一致的， 这样才能保证链接到同一个文件数据， 而这两个数据则是通过 <code class="language-html highlighter-rouge">get_disk_inode_pos</code> 函数获取到的， 依据是 <code class="language-html highlighter-rouge">DirEntry</code> 中的 <code class="language-html highlighter-rouge">inode_id</code> 这个数据。 所以 <code class="language-html highlighter-rouge">sys_linkat</code> 的实现和 <code class="language-html highlighter-rouge">Inode::create</code> 非常类似， 唯一不同的是 <code class="language-html highlighter-rouge">new_inode_id</code> 不再是通过 <code class="language-html highlighter-rouge">fs.alloc_inode</code> 获取一个新的 <code class="language-html highlighter-rouge">inode_id</code>， 而是和需要链接的对象的完全一致。</p>

<p>对于 <code class="language-html highlighter-rouge">sys_unlinkat</code> 就是和上述实现相反， 通过输入的 <code class="language-html highlighter-rouge">block_id</code> 以及 <code class="language-html highlighter-rouge">block_offset</code> 这两个参数， 遍历 <code class="language-html highlighter-rouge">file_count</code> 数量的 <code class="language-html highlighter-rouge">DirEntry</code> 并将数据读取到 <code class="language-html highlighter-rouge">buf</code> 中查看 <code class="language-html highlighter-rouge">buf</code> 对应的 <code class="language-html highlighter-rouge">block_id</code> 以及 <code class="language-html highlighter-rouge">block_offset</code> 是否和所给的参数一致， 另外实验不要求删除这个被分配的 inode。</p>

<p><code class="language-html highlighter-rouge">sys_stat</code> 这部分遇到的比较大的问题是如何将 <code class="language-html highlighter-rouge">fd_table</code> 获取的到的 <code class="language-html highlighter-rouge">OSInode</code> 从一个 trait 转换成实际的数据类型。 参考了 <a href="https://github.com/yao-jz/rCore-lab/commit/5bdaac804d7ab042f337261ecefa50bda72c0896">yao-jz/rCore-lab - ch6</a> 中的实现， 需要给 File Trait 增加一个自己实现的 AnyConvertor Trait， 能够将任意类型转为 <code class="language-html highlighter-rouge"><span class="err">&amp;</span>dyn Any</code> 再通过 <code class="language-html highlighter-rouge">downcast_ref::<span class="nt">&lt;OSInode&gt;</span>()</code> 强制转换为 <code class="language-html highlighter-rouge">OSInode</code> 数据类型。 这样我们再给 <code class="language-html highlighter-rouge">OSInode</code> 增加 <code class="language-html highlighter-rouge">get_inode_id</code> 以及 <code class="language-html highlighter-rouge">get_inode_pos</code> 获取 <code class="language-html highlighter-rouge">inode_id</code> 以及 <code class="language-html highlighter-rouge">block_id</code> 和 <code class="language-html highlighter-rouge">block_offset</code> 即可。 另外需要一个 <code class="language-html highlighter-rouge">get_nlink_num</code> 函数获取 <code class="language-html highlighter-rouge">nlink</code> 硬链接的数量， 思路和 unlink 的实现很类似， 也是遍历 <code class="language-html highlighter-rouge">file_count</code> 数量的 <code class="language-html highlighter-rouge">DirEntry</code> 只不过我们只计数。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">Any</span><span class="p">;</span>

<span class="cd">/// convert current type to &amp;dyn Any</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">AnyConvertor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="n">AnyConvertor</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/1b6c70b223719a7207a786fdc49e09eccce51480">commit#1b6c70b</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="Rust" /><category term="rCore" /><summary type="html"><![CDATA[第六章：文件系统， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry></feed>