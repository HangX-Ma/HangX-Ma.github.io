<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-06-20T00:01:27+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">rCore note - Chapter 1</title><link href="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html" rel="alternate" type="text/html" title="rCore note - Chapter 1" /><published>2023-06-19T00:00:00+08:00</published><updated>2023-06-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/19/rcore-note-ch1</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html"><![CDATA[<ul>
  <li>rCore 第一章相关内容的实现记录在 <a href="https://github.com/HangX-Ma/rcore-sp23/tree/main/ch1">Github</a> 中。</li>
  <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S</a></li>
  <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
  <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
</ul>

<h2 id="1-为内核支持函数调用">1. 为内核支持函数调用</h2>

<h3 id="11-导读问答">1.1 导读问答</h3>

<ul>
  <li>
    <p><em>如何使得函数返回时能够跳转到调用该函数的下一条指令，即使该函数在代码中的多个位置被调用？</em></p>

    <blockquote>
      <p>RISC-V 中 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器 （即 <code class="language-plaintext highlighter-rouge">x1</code> 寄存器） 是用来保存函数的返回地址的， 函数调用时会使用相关的跳转指令 <code class="language-plaintext highlighter-rouge">jal</code> 或者 <code class="language-plaintext highlighter-rouge">jalr</code>， 这两条指令都会在函数调用前将 <code class="language-plaintext highlighter-rouge">pc+4</code> 即下一条指令的地址存入 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器， 一般情况下 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器会选为 <code class="language-plaintext highlighter-rouge">ra</code>。 在函数需要返回时， 只需要通过 <code class="language-plaintext highlighter-rouge">ret</code> 汇编伪指令， 即可使主程序继续在 <code class="language-plaintext highlighter-rouge">ra</code> 保存的物理地址继续执行， 这里 <code class="language-plaintext highlighter-rouge">ret</code> 伪指令会被解析为 <code class="language-plaintext highlighter-rouge">jalr x0, 0(ra)</code>。 但在使用 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器时需要注意函数调用上下文， 保证控制流转移前后特定的寄存器值保持不变。</p>
    </blockquote>
  </li>
  <li>
    <p><em>对于一个函数而言，保证它调用某个子函数之前，以及该子函数返回到它之后（某些）通用寄存器的值保持不变有何意义？</em></p>

    <blockquote>
      <p>这些特定的寄存器分为 <em><strong>Caller-Saved</strong></em> 和 <em><strong>Callee-Saved</strong></em> 两类， 对于编译器而言， 每个函数的编译是独立的， 子函数的寄存器是未知的， 这些寄存器的值的改变可能会影响整个函数的运行。 例如 <code class="language-plaintext highlighter-rouge">ra</code> 在嵌套函数调用中， 若没有保存通用寄存器的值， 可能会因子函数覆盖了 <code class="language-plaintext highlighter-rouge">ra</code> 的值而使得控制流出现混乱。 因而保证这些特定的通用寄存器的值保持不变可以保证 <strong>多层嵌套调用</strong> 的正确， 以及实现对寄存器的复用 （寄存器资源非常珍贵）。</p>
    </blockquote>
  </li>
  <li>
    <p><em>调用者函数和被调用者函数如何合作保证调用子函数前后寄存器内容保持不变？调用者保存和被调用者保存寄存器的保存与恢复各自由谁负责？它们暂时被保存在什么位置？它们于何时被保存和恢复（如函数的开场白/退场白）？</em></p>

    <blockquote>
      <p>需要依据 <strong>Calling Convention</strong> 对各自需要保存的寄存器进行保存， 正如 <strong>Caller-Saved</strong> 和 <strong>Callee-Saved</strong> 二者的字面含义， 调用者保存寄存器就由调用函数保存， 被调用者寄存器则由被调用函数保存， 这些寄存器都被保存在 <strong>栈帧</strong> 上。 一般在被调用函数开始时会保存这些寄存器， 而在被调用函数结束时会恢复寄存器， 这对于 <strong>Caller</strong> 和 <strong>Callee</strong> 而言是一致的。</p>
    </blockquote>
  </li>
  <li>
    <p><em>在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分的？</em></p>

    <blockquote>
      <p>主要还是根据 <strong>调用规范</strong>（Calling Convention）</p>

      <ul>
        <li>a0~a7（<code class="language-plaintext highlighter-rouge">x10~x17</code>）， 用来传递输入参数， 其中的 a0 和 a1 还用来保存返回值。 <strong>调用者保存</strong>。</li>
        <li>t0~t6(<code class="language-plaintext highlighter-rouge">x5~x7</code>, <code class="language-plaintext highlighter-rouge">x28~x31</code>)， 作为临时寄存器使用，在被调函数中可以随意使用无需保存。</li>
        <li>s0~s11(<code class="language-plaintext highlighter-rouge">x8~x9</code>, <code class="language-plaintext highlighter-rouge">x18~x27</code>)， 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 <strong>被调用者保存</strong>。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>sp</em> 和 <em>ra</em> 是调用者还是被调用者保存寄存器，为什么这样约定？</p>

    <blockquote>
      <ul>
        <li>ra(<code class="language-plaintext highlighter-rouge">x1</code>) 是被调用者保存的。 被调用者函数可能也会调用函数， 在调用之前就需要修改 <code class="language-plaintext highlighter-rouge">ra</code> 使得这次调用能正确返回。 因此，每个函数都需要在开头保存 <code class="language-plaintext highlighter-rouge">ra</code> 到自己的栈帧中，并在结尾使用 <code class="language-plaintext highlighter-rouge">ret</code> 返回之前将其恢复。</li>
        <li>sp(<code class="language-plaintext highlighter-rouge">x2</code>) 是被调用者保存的。sp 是栈指针 (Stack Pointer) 寄存器， 它指向下一个将要被存储的栈顶位置。 sp 寄存器和 fp 寄存器构成了当前栈帧的空间范围， 同样的被调用函数也会调用其他函数， 这会更新栈帧， 所以 sp 以及 fp 都约定为被调用者保存寄存器。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>如何使用寄存器传递函数调用的参数和返回值？如果寄存器数量不够用了，如何传递函数调用的参数？</em></p>

    <blockquote>
      <p>a0~a7 可用以传递函数参数， 而 a0， a1 则用以保存函数返回值。 若寄存器数量不足， 可以通过栈进行参数传递， 在参数压栈结束后， 可以在 a0 或者 a1 中保存当前 sp 的值 （栈顶位置）， 通过偏移获取栈中保存的参数。</p>
    </blockquote>
  </li>
</ul>

<h3 id="12-程序解释与问题记录">1.2 程序解释与问题记录</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">clear_bss</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">sbss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">ebss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">sbss</span> <span class="k">as</span> <span class="nb">usize</span><span class="o">..</span><span class="n">ebss</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">ptr</span><span class="p">|{</span>
                <span class="c1">// use volatile to avoid compiler optimization</span>
                <span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span><span class="nf">.write_volatile</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rcore" /><summary type="html"><![CDATA[第一章：应用程序与基本执行环境， 阅读 rCore tutorial book 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Async Programming in Rust: Futures, Async/Await</title><link href="https://hangx-ma.github.io/2023/06/16/rust-async.html" rel="alternate" type="text/html" title="Async Programming in Rust: Futures, Async/Await" /><published>2023-06-16T00:00:00+08:00</published><updated>2023-06-16T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/16/rust-async</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/16/rust-async.html"><![CDATA[<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=lJ3NC-R3gSI">Rust’s Journey to Async/Await - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-2019/">[Slide]</a></li>
  <li><a href="https://www.youtube.com/watch?v=NNwK5ZPAJCk">The Talk You’ve Been Await-ing for - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-async-await/">[Slide]</a></li>
  <li><a href="https://course.rs/advance/async/intro.html">Rust语言圣经(Rust Course) - 异步编程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[Rust 异步编程中涉及到 Futures， Async/Await 等设计， 这种 Event Driven Programming 以及 Non-Blocking 的设计与构想非常重要。]]></summary></entry><entry><title type="html">Async Programming in Rust： Channel</title><link href="https://hangx-ma.github.io/2023/06/11/rust-channel.html" rel="alternate" type="text/html" title="Async Programming in Rust： Channel" /><published>2023-06-11T00:00:00+08:00</published><updated>2023-06-11T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/11/rust-channel</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/11/rust-channel.html"><![CDATA[<blockquote>
  <ul>
    <li>CS110L Spring 2020 仓库： <a href="https://github.com/HangX-Ma/cs110l-sp20">https://github.com/HangX-Ma/cs110l-sp20</a></li>
    <li>CS110L Spring 2020 课程网站： <a href="https://reberhardt.com/cs110l/spring-2020/">https://reberhardt.com/cs110l/spring-2020/</a></li>
  </ul>
</blockquote>

<p>CS110L Spring20 课程的 Lecture 12 提及了 Rust 多线程间的数据共享的问题。 一般来说， 线程之间会通过一块共享内存传递数据， 并使用 <code class="language-plaintext highlighter-rouge">Arc</code> 以及 <code class="language-plaintext highlighter-rouge">Mutex</code> 避免数据竞争 (Race Condition)。</p>

<p>但是 <strong>使用锁的办法是开销极大的</strong>。 假设内核调度时线程 A 遇到了上锁的数据， 虽然处理这一小段数据可能只需要几纳秒的时间， 但是剩余的时间片因为锁的原因而被浪费了， 而此时该线程又被内核放在了调度队列的末尾， 这意味着线程 A 真正运行时需要经历多轮调度等待很长时间。 那么最好的办法就是使用一种不上锁的数据结构。</p>

<h2 id="1-channel-模型的提出">1. Channel 模型的提出</h2>

<div align="center" style="font-weight: bold; font-style: italic;">

Do not communicate by sharing memory; instead, share memory by communicating
<p align="right">-- Effective Golang</p>
</div>

<p>早在 1978 年就已经提出了 Channel 的理论模型， 多个线程之间的通信以消息的方式传递， 由于没有使用共享内存， 因而不会产生数据竞争。 但消息传递并不意味着高效， 由于我们没有使用共享内存， 这需要我们将需要传递的数据拷贝进 <code class="language-plaintext highlighter-rouge">Message</code> 中， 这会造成极大的资源浪费和严重的效率问题。</p>

<p>在 Rust 中可以通过浅拷贝达到数据共享的目的， 我们需要在 <code class="language-plaintext highlighter-rouge">Message</code> 中传递指针。 用以描述指针的数据结构所占的资源是极小的， 这种 <strong>Partial Shared Memory</strong> 的安全性也能得到保证。 由于 Rust 语言的特性， 指针的所有权会在传递时转移至 Channel 中， 编译器会保证我们在传递指针后无法再在除 Channel 外的任何地方使用这个指针。</p>

<p>完美的 Channel 模型应当是 <em><strong>MPMC (multi-producer, multi-consumer)</strong></em> 类型， 简单的 <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt; + CondVar</code> 组合能够实现 MPMC 但正如前述所言， 使用锁会降低效率。 比如在 Go 语言中实现了基于锁的安全的 MPMC Channel， 虽然使用了 <strong>futex (fast userspace mutex)</strong> 但由于锁的存在而效率低下。 因而， 标准的 Rust 库中实现的是 <em><strong>MPSC (multi-producer, single-consumer)</strong></em>， 这种实现方式有如下优缺点：</p>

<ul>
  <li>优点
    <ul>
      <li>适用于归约数据汇总的场合， 多个线程需要将结果统一发送给一个单独的线程。</li>
      <li>可以退化为 <em><strong>SPSC(single-producer, single-consumer)</strong></em> 进行线程与线程之间独立的通信。</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>当我们想分发数据的时候即一对多时， 情况就比较难办且复杂了。</li>
      <li>Rust 标准库中的 Channel 比较古老， 一些术语和标准没有统一， 不仅难用而且很有可能会被替代。</li>
    </ul>
  </li>
</ul>

<p><a href="https://docs.rs/crossbeam/0.7.3/crossbeam/">crossbeam</a> 是 Rust 官方指定的 Channel 的实现库， 实现了 MPMC 的特性， 改进了很多 API， 甚至比当前的标准库的实现还要快上不少。</p>

<h2 id="2-crossbeam-channel">2. crossbeam Channel</h2>

<p>这里使用 CS110L 课程的 farm v3.0 这个例子对 Channel 的使用进行解释说明。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="n">crossbeam_channel</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="n">num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">thread</span><span class="p">,</span> <span class="n">time</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">factor_number</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// unbounded 表示使用的内存是无上限的</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">crossbeam</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="nf">unbounded</span><span class="p">();</span>
    
    <span class="k">let</span> <span class="k">mut</span> <span class="n">threads</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="nn">num_cpus</span><span class="p">::</span><span class="n">get</span> <span class="p">{</span>
        <span class="c1">// 创建一个 receiver 的拷贝， 避免下一个线程因所有权转移而无法使用 receiver</span>
        <span class="k">let</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">threads</span><span class="nf">.push</span><span class="p">(</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">next_num</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">factor_number</span><span class="p">(</span><span class="n">next_num</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">stdin</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">stdin</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"Tried writing to channel, but there are no receivers!"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果没有调用 drop， 那么通道关闭的两个条件： 发送者全部 drop 或接收者被 drop 就无法满足。</span>
    <span class="c1">// 那么对于子线程而言， 如果它想从 while 循环中跳出必须要让 recv() 返回一个 Err()， 只有提早</span>
    <span class="c1">// 通过 drop 函数关闭了 sender 才能让 Channel 关闭， 让子线程完成处理。</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">thread</span> <span class="k">in</span> <span class="n">threads</span> <span class="p">{</span>
        <span class="n">thread</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Panic occurred in thread"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-参考">3. 参考</h2>

<ul>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-12.pdf">CS110L, Spring 2020: Channels</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-11.pdf">CS110L, Spring 2020: Synchronization</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/lecture-notes/lecture-11/">CS110L, Spring 2020: Synchronization in Rust</a></li>
  <li><a href="https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93">Rust Course: Channel</a></li>
</ul>

<p class="error">Thanks for Roberto Huertas providing the background image, you can find some from his blog: <a href="https://robertohuertas.com/2019/12/08/wallpapers-for-the-rust-of-us/">Wallpapers for the Rust of us</a></p>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[学习 CS110L Spring20 课程 Lecture 12： Channel， 总结相关原理及用法。]]></summary></entry><entry><title type="html">MDIO (Management Data Input/Output)</title><link href="https://hangx-ma.github.io/2023/06/06/net-mdio.html" rel="alternate" type="text/html" title="MDIO (Management Data Input/Output)" /><published>2023-06-06T00:00:00+08:00</published><updated>2023-06-06T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/06/net-mdio</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/06/net-mdio.html"><![CDATA[<h2 id="1-mdio-简介">1. MDIO 简介</h2>

<p><a href="#ref-mdio-wiki">wiki</a> 中这样定于 <em><strong>MDIO（Management Data Input/Output）</strong></em>： <em>MDIO 是 IEEE 802.3 标准定义一种两线以太网串行总线用于 <strong>MII（Media Independent Interface）</strong>， 有时关于 MDIO 我们还会说到 <strong>SMI（Serial Management Interface）</strong> 或者 <strong>MIIM（Media Independent Interface Management）</strong></em>。SMI/MDIO 协议用来管理 <em><strong>MAC（Media Access Controller）</strong></em> 与 <em><strong>PHY（Physical）</strong></em> 两个网络层之间的数据传输。 控制 MDIO 总线的设备称为 <em><strong>STA（Station Management Entity）</strong></em> 而被 MDIO 总线管理的设备称为 <em><strong>MMD（MDIO Manageable Device）</strong></em>。</p>

<blockquote>
  <p>MDIO 上层是 MII 其有两个接口： 数据接口连接以太网 MAC 层， 用以发送和接收以太网帧数据； 另外一个 PHY 管理接口了， 也就是我们所说的 MDIO 接口。</p>
</blockquote>

<p>MMD 一般是指 PHY 设备这类 MDIO 从设备， MDIO 接口会连接控制单元控制 PHY 设备以及获取其状态 （读写寄存器）。 每个 PHY 设备能在执行操作之前监视， 在执行操作时则可通过寄存器监视其状态。 这些寄存器提供了状态和控制信息， 包括 <em>link status, speed ability and selection, power down for low power consumption, duplex mode (full or half), auto-negotiation, fault signalling, loopback</em>。 MDIO 协议的作用就是配置 PHY 层所需要的接收/发送的参量。</p>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/mdio-interface-layout.png" alt="MDIO interface layout" width="600" />
    <br />
    <font size="2" color="#999"><u>MDIO interface layout</u></font>
</div>

<p>前述所说， MDIO 是一种双线协议， 其接口由两种信号构成：</p>

<ul>
  <li><strong>MDIO Data Clock（MDC）：</strong> 由 MAC 设备驱动的连接到 PHY 设备的时钟信号。</li>
  <li><strong>MDIO Data：</strong> 双向的数据传输， 所有的设备都依据 MDC 同步 （synchronous） 传输。</li>
</ul>

<p>虽然 MDIO 的是一种最高仅有 2.5 MHz 的低速总线 （最新的 DP83640 已经能支持 25 MHz）， 最开始是由 IEEE 802.3 的 Clause 22 定义， 后为了满足对 10G 以太网的设备需求在 IEEE 802.3ae 定义了 Clause 45。 对于 MDIO 总线而言其仅有一个主设备， 但能有多达 32 个 PHY 从设备。</p>

<blockquote>
  <p>MDIO 主从设备的控制器有不同的协议适用要求：</p>

  <ul>
    <li>MDIO master controller: Clause 22 和 Clause 45 均可</li>
    <li>MDIO slave controller: Clause 22</li>
    <li>MDIO slave controller: Clause 45</li>
  </ul>
</blockquote>

<h2 id="2-clause-22">2. Clause 22</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause22-frame-format.png" alt="Clause 22 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 22 format format</u></font>
</div>

<p>Clause 22 的帧格式只允许 5 bit 物理层地址和寄存器地址， 这限制了 STA 可以连接的 MMD 的数量。 此外，Clause 22 MDIO 只支持限压 5V 的设备且不支持多设备的 PHY。</p>

<h2 id="3-clause-45">3. Clause 45</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause45-frame-format.png" alt="Clause 45 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 45 format format</u></font>
</div>

<p>Clause 45 更改了寄存器的读写模式， 不同于 Clause 22 将寄存器读写数据以及地址都放在一个独立帧， Clause 45 分成了两帧进行传输， 第一帧为地址帧确定 MMD 和 寄存器， 第二帧为数据帧进行数据的读写。 这种设计不仅向后兼容 Clause 22， 并且将地址从 5 bit 扩展到了 16 bit， 使得寄存器的访问数量从 32 个增加到了 65535 个。 另外 Clause 45 支持 32 个端口， 每个端口都能支持 32 个 MMD 设备。</p>

<h2 id="4-mdio-与-phy-与-nic">4. MDIO 与 PHY 与 NIC</h2>

<p>网卡 （NIC） 工作在 OSI 的最后两层， 物理层和数据链路层</p>

<ul>
  <li><strong>物理层</strong> 定义了数据传送与接收所需要的电与光信号、 线路状态、 时钟基准、 数据编码和电路等， 并向数据链路层设备提供标准接口。</li>
  <li><strong>数据链路层</strong> 则提供寻址机制、 数据帧的构建、 数据差错检查、 传送控制、 向网络层提供标准的数据接口等功能。 以太网卡中数据链路层的芯片称之为 MAC 控制器。</li>
</ul>

<p>物理层的芯片称之为 PHY。 IEEE-802.3 标准定义了以太网 PHY。 包括 <em><strong>MII（Media Independent Interface）</strong></em> 子层， <em><strong>PCS（Physical Coding Sublayer）</strong></em>， <em><strong>PMA（Physical Medium Attachment）</strong></em> 子层， <em><strong>PMD（Physical Medium Dependent）</strong></em> 子层， <em><strong>MDI（Medium Dependent Interface）</strong></em> 子层， 符合 IEEE-802.3k 中用于 10BaseT 和 100BaseTX 的规范。</p>

<p>PHY 和 MAC 之间通过 IEEE 定义的标准的 <em><strong>MII（Media Independent Interface）</strong></em> 连接 MAC 和 PHY。 MII 传递了网络的所有数据和数据的控制。 以太网接口实质是 MAC 通过 MII 总线控制 PHY 的过程。 按照前述内容可知， IEEE 定义了 MDIO 总线服务于 MII 用以与 PHY 的通信。</p>

<h2 id="5-参考">5. 参考</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Management_Data_Input/Output">Management Data Input/Output - wikipedia</a> <a id="ref-mdio-wiki"></a></li>
  <li><a href="https://www.latticesemi.com/-/media/LatticeSemi/Documents/ReferenceDesigns/JM/MDIOMasterandSlaveControllersDocumentation.ashx?document_id=50604">MDIO Master and Slave Controllers - LATTICE-semiconductor</a></li>
  <li><a href="https://prodigytechno.com/mdio-management-data-input-output/">MDIO ( Management Data Input/Output )</a></li>
  <li><a href="https://www.totalphase.com/support/articles/200349206-mdio-background/">MDIO Background</a></li>
  <li><a href="https://grouper.ieee.org/groups/802/3/ae/public/jul00/law_1_0700.pdf">IEEE P802.3ae 10Gb/s Ethernet MDC/MDIO Proposal</a></li>
  <li><a href="https://www.cnblogs.com/jason-lu/articles/3195473.html">网口扫盲三:以太网芯片MAC和PHY的关系</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Network" /><category term="Linux" /><summary type="html"><![CDATA[介绍 MDIO 以及与其相关的 clause 22， clause 45 协议。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 6: putting it all together</title><link href="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 6: putting it all together" /><published>2023-05-31T00:00:00+08:00</published><updated>2023-05-31T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/31/cs144-lab6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html"><![CDATA[<p>记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab6 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check6.pdf">Lab Checkpoint 6: putting it all together</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简介">1. 内容简介</h2>

<p>Lab6 是一个选择性的实验， 在前 6 个实验中我们已经完成了网络的框架， Checkpoint 0 (a reliable byte stream), Checkpoints 1–3 (the Transmission Control Protocol), Checkpoint 4 (an IP/Ethernet network interface) 以及 Checkpoint 5 (an IP router)， 该实验的目的是使用前述的网络栈实现真实的网络通信， 这需要我们有个 partner， 一人分饰两角也是可以的。</p>

<h2 id="2-the-network">2. The Network</h2>

<p>在该实验中需要一对可行的网络栈组合成一个真实的网络通信环境， 两方都需要构建 host 和 router， 网络拓扑如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-05-31-cs144-lab6/the-network.png" alt="The Network" width="600" />
    <br />
    <font size="2" color="#999"><u>The Network</u></font>
</div>

<ol>
  <li>对于个人而言， 需要使用同一套代码在不同的终端中启用 server 以及 client。</li>
  <li>为了使用 relay， 我们需要选择任意的一个 1024 到 64000 之间的偶数以区分不同的 group。 我们可以选择 “4088”。</li>
  <li>
    <p>server 端在 build 文件夹下输入 <code class="language-plaintext highlighter-rouge">./apps/endtoend server cs144.keithw.org 4088</code>， 若顺利的话 server 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend server cs144.keithw.org 4088
 DEBUG: Network interface has Ethernet address 02:00:00:91:a1:8f and IP address 172.16.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:bf:ba:0e and IP address 10.0.0.172
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> 10.0.0.192 on interface 1
 DEBUG: Network interface has Ethernet address 9a:c0:ea:b5:88:82 and IP address 172.16.0.100
 DEBUG: Listening <span class="k">for </span>incoming connection...
</code></pre></div>    </div>
  </li>
  <li>
    <p>client 端在 build 文件夹下输入 <code class="language-bash highlight highlighter-rouge">./apps/endtoend client cs144.keithw.org 4089</code>， 若顺利的话 client 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend client cs144.keithw.org 4089
 DEBUG: Network interface has Ethernet address 02:00:00:e0:84:14 and IP address 192.168.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:e8:1a:da and IP address 10.0.0.192
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> 10.0.0.172 on interface 1
 DEBUG: Network interface has Ethernet address 7e:fa:65:55:c7:4e and IP address 192.168.0.50
 DEBUG: Connecting from 192.168.0.50:7907...
 DEBUG: Connecting to 172.16.0.100:1234...
 Successfully connected to 172.16.0.100:1234.
</code></pre></div>    </div>

    <p>并且 server 端会额外打印一条信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> New connection from 192.168.0.50:7907.
</code></pre></div>    </div>
  </li>
  <li>
    <p>若以上信息都能正确打印， 则意味着 TCP 握手成功， 若有问题则需要在之前的命令后加上 <code class="language-plaintext highlighter-rouge">debug</code> 进入 debug 模式进行调试。</p>

    <ul>
      <li>我们可以在 server 或者 client 任意一端输入数据， 就能在相应的另一端看到数据。
        <blockquote>
          <p>经过测试发现需要在 Terminal 输入需要发送的数据后按下 Ctrl-D 才能发送数据并在 remote 端看到。</p>
        </blockquote>
      </li>
      <li>可以使用 Ctrl-D 关闭链接。 server 或 client 关闭链接后会终止那一端的 ByteStream 的输出， 但仍会持续接收数据直到另一端也关闭了 ByteStream 的输出， 我们需要验证这点。
        <blockquote>
          <p>首先需要确保 Terminal 中已经没有数据了， 此时我们按下 Ctrl-D 才会断开 TCP 的链接。</p>
        </blockquote>
        <ul>
          <li>
            <p><em><strong>server</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  DEBUG: Outbound stream to 192.168.0.50:36742 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Inbound stream from 192.168.0.50:36742 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:36742 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p><em><strong>client</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  <span class="c">######## Nothing ########</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>当 server 和 client 都关闭 ByteStream 输出后并且一端又持续存在数秒后， 两边的程序应该会正常退出。</li>
    </ul>
  </li>
</ol>

<h2 id="3-文件传输">3. 文件传输</h2>

<h3 id="31-操作流程">3.1 操作流程</h3>

<p>当基本的通信功能实现之后就可以通过网络进行文件的传输。</p>

<ul>
  <li>
    <p>将 1M 大小的随机数写入文件 <code class="language-plaintext highlighter-rouge">/tmp/big.txt</code>。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>1 <span class="nv">of</span><span class="o">=</span>/tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 server 端在接受连接后立刻发送文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ./apps/endtoend server cs144.keithw.org 4088 &lt; /tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 client 端关闭输出数据流并下载文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;/dev/null ./apps/endtoend client cs144.keithw.org 4089 <span class="o">&gt;</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>比较两个文件确保二者一致</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">sha256sum</span> /tmp/big.txt
  <span class="nb">sha256sum</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
</ul>

<p>如果 SHA-256 哈希值都能匹配上， 那我们就可以确定文件被正确传输了。</p>

<h3 id="32-输出打印">3.2 输出打印</h3>

<ul>
  <li>
    <p><em><strong>server</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Inbound stream from 192.168.0.50:27200 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:27200 finished <span class="o">(</span>63000 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 192.168.0.50:27200 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>client</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: TCP connection finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown... <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>SHA-256</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big.txt
  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big-received.txt
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 5: building an IP router</title><link href="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 5: building an IP router" /><published>2023-05-30T00:00:00+08:00</published><updated>2023-05-30T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/30/cs144-lab5</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html"><![CDATA[<p>记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab5 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check5.pdf">Lab Checkpoint 5: building an IP router</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/check5-structure.png" alt="IP router structure" width="500" />
    <br />
    <font size="2" color="#999"><u>IP router structure</u></font>
</div>

<p>Lab5 要求实现一个简易的路由器， 通常路由器会有多个网络接口， 能够从任意一个接口接收网络数据报。 路由器的作用就是将 datagrams 依据 <strong>路由表</strong> 进行转发， 路由表定义了路由转发的一些规则：</p>

<ul>
  <li>确定转发的接口</li>
  <li>确定下一跳的 IP 地址</li>
</ul>

<p>在 Lab5 中需要实现一个新的 <code class="language-plaintext highlighter-rouge">Router</code> 类， 该类能够 <em>跟踪路由表信息</em> 并且 <em>将接收到的每个 datagram 通过正确的输出端 <strong>NetworkInterface</strong> 正确转发到下一跳 （hop）</em>。 在项目指导书中明确解释了 <em><strong>route</strong></em> 的相关含义， 后续需要通过 IP 的最长前缀匹配来实现路由的功能， 这也是实验中最为棘手的部分。</p>

<h2 id="2-ip-router-实现">2. IP Router 实现</h2>

<ol>
  <li>
    <p><strong>add_route：</strong> 调用该方法将路由信息添加到路由表中， 我们需要自己添加存储相关信息的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">add_route</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">,</span> 
                 <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">interface_num</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>根据 <code class="language-plaintext highlighter-rouge">add_route</code> 所给的参数以及 <a href="https://en.wikipedia.org/wiki/Routing_table">wiki</a> 中对 routing table 内容的描述， 我们需要自己创建如下的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Routing table data structure</span>
 <span class="k">using</span> <span class="n">route_t</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">;</span>
     <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">interface_id</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">route_t</span><span class="o">&gt;</span> <span class="n">routing_table_</span> <span class="p">{};</span>
</code></pre></div>    </div>

    <blockquote>
      <p><a href="https://en.wikipedia.org/wiki/Routing_table">wikipedia - Routing table</a></p>
    </blockquote>
  </li>
  <li>
    <p><strong>route：</strong> 该方法需要对输入的 datagrams 进行路由， 将其通过正确的网络接口转发到下一跳， 这需要实现 <strong>“最长前缀匹配 （longest-prefix match）”</strong> 以找到最合适的路由方案， 该方法有如下细节需要实现：</p>

    <ul>
      <li>路由器需要搜索路由表找到匹配 datagrams 中的目的地址的那个路由。 这意味着目的地址的 <em>prefix_length</em> 需要与 <em>route_prefix</em> 的 <em>prefix_length</em> 完全一致。</li>
      <li>在匹配的路由方案中路由器选择 <em>prefix_length</em> 值最大的那个， 选中的就是满足 “最长前缀匹配” 的路由。</li>
      <li>如果没有匹配的路由信息， 则丢弃该项 datagram。</li>
      <li>每一跳的路由器都需要减少 datagrams 的 ttl。 如果 ttl 已经归零或者在本次减除后触及零的下界， 路由器同样需要丢弃该项 datagram。</li>
      <li>最终， 路由器需要将修改过的 datagram 通过合适的网络接口 （<code class="language-plaintext highlighter-rouge">interface(interface num).send datagram()</code>） 发送到下一跳。</li>
    </ul>

    <p>整个过程中， 路由器仅需要和 datagram 以及链接层的网络接口抽象进行交互， 完全不需要考虑 TCP， ARP 以及以太网帧， 较好实现了分层隔离， 降低了路由器的处理负担。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">route</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="3-网络拓扑">3. 网络拓扑</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/simulated-router-and-interfaces.png" alt="Simulated router and interfaces topology" width="600" />
    <br />
    <font size="2" color="#999"><u>Simulated router and interfaces topology</u></font>
</div>

<h2 id="4-坑点记录">4. 坑点记录</h2>

<p>测试的时候有这样一条记录（就是第一个测试都没过啦）， 当时觉得很奇怪怎么会有 <code class="language-plaintext highlighter-rouge">bad IPv4 datagram</code> 的打印， 查看后是 <code class="language-plaintext highlighter-rouge">InternetDatagram</code> 的 <code class="language-plaintext highlighter-rouge">parse</code> 返回了错误。 于是我给 <code class="language-plaintext highlighter-rouge">set_error</code> 的部分都加上了打印才发现是 <strong>checksum</strong> 未匹配。 我还以为是 <em><strong>NetworkInterface</strong></em> 部分的接收部分没有写好， 调试了半天就想着要不要用 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 在 <code class="language-plaintext highlighter-rouge">recv_frame</code> 中重新把 checksum 计算一下， 这时候突然发现这个函数的接口都是 <code class="language-plaintext highlighter-rouge">const</code> 类型， 并且结合 <em><strong>NetworkInterface</strong></em> 在 <em>link layer</em> 与 <em>application</em> 之间的情况， 以及错误是出现在以太网帧传输到 router 再转发出去的， 唯一有嫌疑的应当还是刚刚写的 <em><strong>Router</strong></em> 类。</p>

<p>在读 <code class="language-plaintext highlighter-rouge">router.cc</code> 代码考虑把 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 加在哪里的时候我突然看到 ttl 的值被我更改了。 这不就是问题根源嘛， 我们更新了 <em><strong>InternetDatagram</strong></em> 的内容， 那么 checksum 也需要重新计算。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Testing traffic between two ordinary hosts <span class="o">(</span>applesauce to cherrypie<span class="o">)</span>...

Host applesauce trying to send datagram <span class="o">(</span>with next hop <span class="o">=</span> 10.0.0.1<span class="o">)</span>: 
    IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 
    <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/10.0.0.1

Transferring frame from router.eth0 to applesauce: 
    <span class="nv">dst</span><span class="o">=</span>16:4e:eb:3a:a2:3d, <span class="nv">src</span><span class="o">=</span>02:00:00:dd:27:73, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:dd:27:73/10.0.0.1, <span class="nv">target</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:dd:27:73, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: IPv4: IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, 
    <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from router.eth2 to cherrypie: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nb">type</span><span class="o">=</span>ARP, 
    payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/192.168.0.2

Transferring frame from cherrypie to router.eth2: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nv">src</span><span class="o">=</span>ea:80:f1:26:53:c8, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>ea:80:f1:26:53:c8/192.168.0.2, <span class="nv">target</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1

Transferring frame from router.eth2 to cherrypie: 
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="nv">dst</span><span class="o">=</span>ea:80:f1:26:53:c8, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: bad IPv4 datagram
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="o">[</span>NetworkInterface ERROR]: <span class="s1">'recv_frame'</span> IPV4 parse error



Error: Host cherrypie did NOT receive an expected Internet datagram: 
        IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2
</code></pre></div></div>

<h2 id="5-测试结果">5. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check5
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/3 Test  <span class="c">#1: compile with bug-checkers ........   Passed   44.90 sec</span>
    Start 35: net_interface
2/3 Test <span class="c">#35: net_interface ....................   Passed    0.20 sec</span>
    Start 36: router
3/3 Test <span class="c">#36: router ...........................   Passed    0.17 sec</span>

100% tests passed, 0 tests failed out of 3

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  45.41 sec
Built target check5
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)</title><link href="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)" /><published>2023-05-27T00:00:00+08:00</published><updated>2023-05-27T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/27/cs144-lab4</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html"><![CDATA[<p>记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 <em><strong>TCPReceiver</strong></em> 和 <em><strong>TCPSender</strong></em> 结合起来）。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab4 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check4.pdf">Lab Checkpoint 4: down the stack (the network interface)</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-27-cs144-lab4/check4-structure.png" alt="network interface structure" width="300" />
    <br />
    <font size="2" color="#999"><u>network interface structure</u></font>
</div>

<p>Lab4 要求实现网络接口部分， 打通网络数据报 （Internet datagrams） 和链路层的以太网帧（link-layer Ethernet frames） 之间的桥梁。 之前的实验实现了 TCP segments 在使用 TCP 协议的设备之间的传输， 而 TCP 报文是如何传递的？ TCP报文有三种方式可被传送至远程服务器：</p>

<ul>
  <li>
    <p><em><strong>TCP-in-UDP-in-IP：</strong></em> TCP 报文会被置于用户的数据报的 payload 中， 在用户空间下这是最简单的实现方式： Linux 提供接口 （如 <em><strong>UDPSocket</strong></em>）， 而用户侧仅需要提供 payload， 目标地址， Linux 内核会负责将 UDP 报部， IP 报头， 以太网报头组装起来， 将这个网络包发向下一个 hop。 <strong>Linux 内核会保证每个 socket 会有独立的本地与远端地址以及端口号， 并且保证这些数据在应用层的相互隔离</strong>。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP：</strong></em> 一般情况下， TCP 报文会直接放在 Internet datagrams 中， 这通常被成为 “TCP/IP”。 Linux 会提供一个 TUN 设备接口， 需要应用层提供整个 Internet datagram， 而 Linux 内核则会处理剩下的部分。 但此时应用层需要自己构建整个 IP 报头以及 payload 部分。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP-in-Ethernet：</strong></em> 以上的方法依赖Linux内核来实现的协议栈操作， 每次用户向 TUN 设备写入 IP datagrams 时， Linux 都需要构建正确的带有 IP datagrams 的以太网帧作为 payload。 这意味着 Linux 需要知悉下一个 hop 的以太网目的地址， 给出其 IP 地址。 否则 Linux 会以广播的形式请求这些信息。</p>

    <p>这些功能是由 <em><strong>Network Interface</strong></em> 实现的， 该组件能将 IP 数据报转义成以太网帧等等， 之后会传入 TAP 设备 （类似 TUN 设备但更底层）， 实现对 link-layer 的数据帧的传输。</p>
  </li>
</ul>

<p>网络接口的大部分工作是， <strong>为每个下一跳 IP 地址查找(和缓存)以太网地址</strong>。而这种协议被称为 <strong>地址解析协议 ARP （Address Resolution Protocol）</strong>。</p>

<blockquote>
  <p><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">Address Resolution Protocol - wiki</a></p>
</blockquote>

<h2 id="2-network-interface-实现">2. Network Interface 实现</h2>

<h3 id="21-默认接口">2.1 默认接口</h3>

<p>在 Lab4 的 <em><strong>Network Interface</strong></em> 中我们需要实现以下几个部分， 维护一个 IP 地址到 Ethernet 地址的映射表。 这个映射类似缓存， 能提高网络栈的传输效率。</p>

<ol>
  <li><strong>send datagram：</strong> 该方法被 TCPConnection 或者 router 所调用， 这个接口就是将待发送的 Internet(IP) datagrams 转义为以太网帧并最终发送出去。
    <ul>
      <li>如果以太网目的地址是已知的就直接发送， 创建以太网帧 （<code class="language-plaintext highlighter-rouge">type = EthernetHeader::TYPE IPv4</code>）， 将 payload 设置为串行的数据报文， 并设置源地址和目标地址。</li>
      <li>如果以太网目的地址未知， 广播下一跳的以太网地址的 ARP 请求， 并将 IP 报文放入队列中待 ARP 回复收到后能将其发送出去。
        <blockquote>
          <p>需要间隔 5 秒再发送相同的 ARP 请求， 并且只有在收到目的以太网地址后再将数据报放入队列中。 若没有收到目的以太网地址， 我们需要将 dgrams 以及其对应的 Address 都暂存在列表中， 以供之后收到 ARP reply 后再进行发送， 否则这部分数据就会丢失了。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">send_datagram</span><span class="p">(</span><span class="k">const</span> <span class="n">InternetDatagram</span> <span class="o">&amp;</span><span class="n">dgram</span><span class="p">,</span> <span class="k">const</span> <span class="n">Address</span> <span class="o">&amp;</span><span class="n">next_hop</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>recv frame：</strong> 该方法接收来自网络的以太网帧， 但需要忽略任何目的地址非网络接口部分的帧 （广播地址或者存储在 <code class="language-plaintext highlighter-rouge">_ethernet_address</code> 中的接口自身的以太网地址）。
    <ul>
      <li>若为 IPv4 帧就将其以 <em><strong>InternetDatagramF</strong></em> 进行解析， 若成功的就将结果的 <em><strong>InternetDatagramF</strong></em> 返回给调用者。</li>
      <li>若为 ARP 帧就将其以 <em><strong>ARPMessage</strong></em>  进行解析， 若成功则缓存发送方 IP 地址与以太网帧的映射 30 秒。 若这个 ARP 请求是询问我们的 IP 地址， 就回复正确的 ARP 答复。
        <blockquote>
          <p>根据 FAQs 中的答疑， 我们需要自行创建一个用以存储映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">InternetDatagram</span><span class="o">&gt;</span> <span class="n">recv_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">EthernetFrame</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>maybe send：</strong> 该方法在必要时发送 <em><strong>EthernetFrame</strong></em>。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">maybe_send</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>tick：</strong> 记录时间， 以使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p class="warning"><em><strong>FAQs and special cases</strong></em> 中的信息都很有帮助， 可以当作一种提供解题思路的 Hints。</p>

<h3 id="22-额外说明">2.2 额外说明</h3>

<h4 id="ethernet-frames">Ethernet Frames</h4>

<p><em><strong>EthernetFrame</strong></em> 是我们需要传输给 TAP 设备的数据， 根据已有信息， 我们只需要将组装好的 <em><strong>EthernetFrame</strong></em> 用 <code class="language-plaintext highlighter-rouge">queue</code> 数据结构封装即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// outbound Ethernet frames which will be sent by the Network Interface</span>
<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">outbound_frames_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="arp-table">ARP Table</h4>

<p>从以上接口的描述可以看出， 我们需要建立一个存储 ARP 映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>， IP-To-Ethernet。 根据 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">wiki</a> 关于 ARP 原理章节的阐述， 这个表中的 ARP 数据需要有一个变量存储 <em><strong>EthernetFrame</strong></em> 表示映射目标， 以及 <em><strong>ttl (time-to-live)</strong></em> 表示该条 ARP 信息的生命周期 （默认是 30s）。 另外，在 FAQs 中有这么一句：</p>

<p class="info"><strong>Q:</strong> <em>How do I convert an IP address that comes in the form of an Address object, into a raw 32-bit integer that I can write into the ARP message?</em>
<br />
<strong>A:</strong> Use the <code class="language-plaintext highlighter-rouge">Address::ipv4 numeric()</code> method.</p>

<p>这说明 ARP 的映射应当是 <code class="language-plaintext highlighter-rouge">uint32_t</code> 类型到 <code class="language-plaintext highlighter-rouge">arp_t</code> 类型， 我们可以用一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储映射信息。 除此之外我们还注意到， 同一个 ARP 的 ARP 请求的间隔需要 5s， 那么除了映射信息外， 我们还需要一个 <code class="language-plaintext highlighter-rouge">list</code> 结构用以存储绑定 <em><strong>InternetDatagram</strong></em> 和 <em><strong>Address</strong></em> 的等待列表 <code class="language-plaintext highlighter-rouge">arp_datagrams_waiting_list_</code>。 另外， 为了记录 ARP 请求的声明周期， 我们还需要一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储 <em><strong>numeric IP</strong></em> 与该条 ARP 请求的声明周期的映射 <code class="language-plaintext highlighter-rouge">arp_requests_lifetime_</code>。</p>

<blockquote>
  <p>这里使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构是头文件中已经包含了相关的库文件， 另外这部分信息具有时效的不确定性， 我们并不清楚 ARP 请求究竟哪一个会在下一刻返回， 所以在这部分信息我们需要逐个遍历， 将已经获取目标以太网地址的数据包组装后放入发送队列中， 并从 <code class="language-plaintext highlighter-rouge">list</code> 中移除。 故而使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构能够利用链表插入/移除数据的快速性的优势， 而不用考虑查询带来的负面影响。</p>
</blockquote>

<p>这样关于 ARP Table 的数据结构就可以按如下格式创建。 需要注意的是 TTL 的时间单位是 ‘毫秒’， 而我们设定的边界值都是以 ‘秒’ 为单位。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ARP will be stored for 30s at most, which can reduce the length of ARP table,</span>
<span class="c1">// increasing the enquiry speed. What's more, </span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_REQUEST_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">arp</span> <span class="p">{</span>
    <span class="n">EthernetAddress</span> <span class="n">eth_addr</span><span class="p">;</span> <span class="c1">// mac address</span>
    <span class="kt">size_t</span> <span class="n">ttl</span><span class="p">;</span> <span class="c1">// time to live</span>
<span class="p">}</span> <span class="n">arp_t</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="cm">/* ipv4 numeric */</span><span class="p">,</span> <span class="n">arp_t</span><span class="o">&gt;</span> <span class="n">arp_table_</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">,</span> <span class="n">InternetDatagram</span><span class="o">&gt;&gt;</span> <span class="n">arp_requests_waiting_list_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="内存泄漏">内存泄漏</h4>

<p>在遍历 ARP Table 的时候我用了迭代器， 但是调用了 <code class="language-plaintext highlighter-rouge">erase</code> 函数之后又用了 <code class="language-plaintext highlighter-rouge">iter++</code> 去获取下一个 ARP 项， 这产生了矛盾， 当前的迭代器的内存空间已经被释放了。 因而使用 <code class="language-plaintext highlighter-rouge">erase</code> 函数需要注意使用 <code class="language-plaintext highlighter-rouge">iter = xxx.erase(iter);</code> 来更新迭代器的内容。</p>

<h2 id="3-测试结果">3. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check4
<span class="o">[</span>1/1] <span class="nb">cd</span> /home/cs144/minnow/build <span class="o">&amp;&amp;</span> /usr/bin/ctest <span class="nt">--output-on-failure</span> <span class="nt">--stop-on-failure</span> <span class="nt">--timeout</span> 12 <span class="nt">-R</span> <span class="s1">'^net_interface'</span>
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/2 Test  <span class="c">#1: compile with bug-checkers ........   Passed   20.14 sec</span>
    Start 35: net_interface
2/2 Test <span class="c">#35: net_interface ....................   Passed    0.15 sec</span>

100% tests passed, 0 tests failed out of 2

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  20.29 sec
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 TCPReceiver 和 TCPSender 结合起来）。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 3: the TCP sender</title><link href="https://hangx-ma.github.io/2023/05/24/cs144-lab3.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 3: the TCP sender" /><published>2023-05-24T00:00:00+08:00</published><updated>2023-05-24T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/24/cs144-lab3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/24/cs144-lab3.html"><![CDATA[<p>记录 cs144 Spring-23 Lab3: the TCP sender 的思路与实践难点。 前面一些内容看起来像翻译， 但其实也是做一遍逻辑梳理， 之后落实思路会更清晰一些。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab3 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check3.pdf">Lab Checkpoint 3: the TCP sender</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<p>Lab3 将实现 TCP 中的 <em><strong>TCPSender</strong></em>， 其需要完成的功能有：</p>

<ul>
  <li>跟踪 Receiver 的 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 信息， 通过将 <em><strong>ByteStream</strong></em> 的数据以 TCP Segments 的格式不断发送， 尽可能地填满 window， 直到 window 满了或者 <em><strong>ByteStream</strong></em> 中没有任何东西可以发送。</li>
  <li>跟踪那些已经发送但还没有被接收的 segments， 通常将这些数据被称为 “outstanding segments”。</li>
  <li>若是这些 segments 在足够长的时间后没有没接收， 则重传这些 segments 数据。</li>
</ul>

<p>这些功能实现了 “automatic repeat request (ARQ)” 机制， <em><strong>TCPSender</strong></em> 的任务就是确保 <em><strong>TCPReceiver</strong></em> 能收到每个字节至少一次。</p>

<h2 id="2-tcpsender-如何监测丢包">2. TCPSender 如何监测丢包</h2>

<p><em><strong>TCPSender</strong></em> 会跟踪那些 outstanding segments 的状态， 周期性调用 <code class="language-plaintext highlighter-rouge">tick</code> 函数以指示这些 segments 自发出以来所经过的时间。 <em><strong>TCPSender</strong></em> 会在内部的存储空间存储 <code class="language-plaintext highlighter-rouge">TCPSenderMessages</code> 的信息并遍历这个集合， 找出那些 <strong>已发出但经过时间太久但还未被接收</strong> 的 segments 进行 <strong>数据超时重传</strong>， 直到所有的 <code class="language-plaintext highlighter-rouge">seqno</code> 都被接收。</p>

<p>那么如何界定 <strong>已发出但经过时间太久</strong> 这个定义就尤为重要， 太长的等待时间会增加通信延时， 而太短的等待时间则会浪费网络存储空间以及增大开销。 需要注意如下几点：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tick</code> 函数每隔几毫秒需要调用一次， 记录自上一次调用以来经过的时间， 并以此记录 <em><strong>TCPSender</strong></em> 存在的总时长。 <code class="language-plaintext highlighter-rouge">time</code> 以及 <code class="language-plaintext highlighter-rouge">clock</code> 这类与操作系统和 CPU 相关的函数不允许调用， 否则会导致 TCP 工作异常。</li>
  <li><strong>retransmission timeout (RTO)</strong> 在 <em><strong>TCPSender</strong></em> 初始化时会初始化 <code class="language-plaintext highlighter-rouge">_initial_retransmission_timeout</code>， 该值始终不变而 RTO 会不断改变 （可能为初值的两倍， 或者等于初值） 以记录 outstanding segments 在超时重传前所经过的时间。</li>
  <li>重传定时器 timer 以 tick 为时间单位， timer 会在某个时间启动， 在经过 RTO 时间后失效。</li>
  <li>包含数据的 segment 被传输后 timer 会被启动， 直到经过 RTO 毫秒后 timer 会失效。</li>
  <li>当所有的 outstanding 数据都被接收后， 服务于重传机制的 timer 将会被停止。</li>
  <li>
    <p><a href="#func_tick">以下信息与 <em>tick</em> 函数的实现密切相关</a></p>

    <p>若是 <code class="language-plaintext highlighter-rouge">tick</code> 被调用而 timer 已经失效了：</p>

    <ol>
      <li>将时间最早的未被接收的 segment 进行重传 （<code class="language-plaintext highlighter-rouge">seqno</code> 最小的那个）。</li>
      <li>若此时 window size 非零：
        <ul>
          <li>跟踪记录连续 <strong>重传的数量</strong>， 并在每次重传后进行累加， <em><strong>TCPConnection</strong></em> 会使用这个信息用以判断 TCP 连接的可靠性， 太多连续的重传意味着 TCP 连接不稳定需要终止。</li>
          <li>设置 RTO 值为原来的两倍。 “exponential backoff” 以降低较差网络的重传速度， 避免加深网络的拥堵。</li>
        </ul>
      </li>
      <li>重置 timer 并启动， 使其在 RTO 毫秒之后失效 （需要考虑 RTO 已经翻倍）。</li>
    </ol>
  </li>
  <li>
    <p><a href="#func_receive">以下信息与 <em>receive</em> 函数的实现密切相关</a></p>

    <p>当接收方给发送方传输了 <code class="language-plaintext highlighter-rouge">ackno</code> 表示成功接收了新的数据 （这个 <code class="language-plaintext highlighter-rouge">ackno</code> 比之前任何一个的 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 都要大）:</p>

    <ol>
      <li>需要将 RTO 设置为其初始值。</li>
      <li>如果发送方仍有 outstanding 的数据， timer 需要重启并将会在 RTO 毫秒后失效。</li>
      <li>重置前述的 <strong>连续重传数量</strong> 为 0。</li>
    </ol>
  </li>
</ul>

<h2 id="3-tcp-sender-实现">3. TCP Sender 实现</h2>

<div align="center">
    <img src="/norobots/images/2023-05-24-cs144-lab3/space-structure.png" alt="space structure" width="600" />
    <br />
    <font size="2" color="#999"><u>space structure, HangX-Ma</u></font>
</div>

<p>需要实现以下 5 个接口并增添自己所需的变量以及 helper functions。 上图是 Sender 端所看到的内存结构以及 <code class="language-plaintext highlighter-rouge">seqno</code> 的分布。</p>

<ol>
  <li>
    <p><em><strong>push:</strong></em> 不断读取新的字节， 并组装生成 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>。 需要使满足 window 尺寸的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 尽可能大， 但上限是 <code class="language-plaintext highlighter-rouge">TCPConfig::MAX PAYLOAD SIZE (1452 bytes)</code>。 <code class="language-plaintext highlighter-rouge">TCPSenderMessage::sequence length()</code> 会用以计量该 segment 占用的 <code class="language-plaintext highlighter-rouge">seqno</code> 的尺寸， SYN 和 FIN 都需要计算在内。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Push bytes from the outbound stream */</span>
 <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">Reader</span> <span class="o">&amp;</span><span class="n">outbound_stream</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这里也是需要注意 window size 最小应当为 1。 另外我们需要两个布尔变量来记录是否需要给传输的 <em><strong>TCPSenderMessage</strong></em> 增加 SYN 标志或者 FIN 标志。 我们以如下顺序对 msg 进行组装： SYN， payload， FIN。 需要注意的是， FIN 标志设定有一定的条件限制：</p>

      <ul>
        <li>FIN 之前没设定过；</li>
        <li>Reader 已经没有数据了；</li>
        <li>塞完 SYN 和 payload 之后我们的 window size 还能容纳一个 FIN 的位置
如果本次 FIN 没有传输， 就下次传输， 不会有什么影响。</li>
      </ul>

      <p>另外， 只有在 outstanding segments 清空后我们才需要在传输新的 <em><strong>TCPSenderMessage</strong></em> 时重置 timer， 否则 timer 将在很大程度上失去其基本作用。 每次传输都需要更新 outstanding segments 集合以及发送的 <code class="language-plaintext highlighter-rouge">seqno</code> 数量， <code class="language-plaintext highlighter-rouge">next_seqno</code> 等信息。</p>
    </blockquote>

    <p class="info">cs144 指导书特地说明了 window size 为零的情况， 仅适用于 <code class="language-plaintext highlighter-rouge">push()</code> 函数。 这时 <em><strong>TCPSender</strong></em> 仍需要发送一个独立的字节， 虽然会被 <em><strong>TCPReceiver</strong></em> 拒绝接收但 <em><strong>TCPReceiver</strong></em> 会返回一个 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 数据， 这个信息可以告知 <em><strong>TCPSender</strong></em> window 中是否有新用于传输的空间。 否则 <em><strong>TCPSender</strong></em> 将无法确定何时发送新的 segment。</p>
  </li>
  <li>
    <p><em><strong>maybe_send:</strong></em> 必要时发送 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 或者为空。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TCPSenderMessage</span><span class="o">&gt;</span> <span class="n">maybe_send</span><span class="p">();</span>
</code></pre></div>    </div>

    <blockquote>
      <p>我们需要额外创建一个队列变量 <code class="language-plaintext highlighter-rouge">segments_out_</code> 来管理需要发送的 segments， 使用队列可以保证传输的先后顺序。 仅在这个队列的元素数量不为零且收到 SYN 信号才返回队列头部的那个数据， 并将其从队列头部移除。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>receive:</strong></em> <a id="func_receive"></a> 接收的 window 范围是 \([ackno, ackno + window size]\)。 <em><strong>TCPSender</strong></em> 需要遍历 outstanding segments 集合将其中已经被 ACK 的部分移除 （<code class="language-plaintext highlighter-rouge">ackno</code> 比 segments 中所有的 <code class="language-plaintext highlighter-rouge">seqno</code> 都要大的那些 segments）。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Receive an act on a TCPReceiverMessage from the peer's receiver */</span>
 <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPReceiverMessage</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>我们只需要按照 <a href="#2-tcpsender-如何监测丢包">2.TCPSender 如何监测丢包</a> 中的最后一条逻辑写代码就行。</p>

      <p>这里需要注意， 接收的 <code class="language-plaintext highlighter-rouge">TCPReceiveMessage</code> 中的 <code class="language-plaintext highlighter-rouge">ackno</code> 可能为空， 这时候不能直接返回， 有可能是我们传输了一个 <em><strong>empty message</strong></em> 去获取 window size 而返回的一个包。 因此， 我们需要更新 <code class="language-plaintext highlighter-rouge">window_size_</code> 变量， 除此之外就什么都不做了。</p>

      <p>或者收到的这个 <code class="language-plaintext highlighter-rouge">ackno</code> 比我们当前保存的 <code class="language-plaintext highlighter-rouge">next_seqno</code> 都要大， 这可能是一个错误信息需要丢弃这段数据。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>tick:</strong></em> <a id="func_tick"></a> 计时单位， 得到与上次该函数被调用的时间间隔。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Time has passed by the given # of milliseconds since the last time the tick() method was called. */</span>
 <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>除了要创建一个 <code class="language-plaintext highlighter-rouge">timer_</code> 变量存储时间外， 在 tick 中还需要做 <a href="#2-tcpsender-如何监测丢包">2.TCPSender 如何监测丢包</a> 中的几件事：</p>

      <ol>
        <li>若 outstanding segments 存在且 timer 失效， 重传时间最早的那个 segments。</li>
        <li>window size 非零时累加连续重传数量， 并进行 “exponential backoff”。</li>
        <li>重置 timer 的值为 0， 为下一次重传准备。</li>
      </ol>
    </blockquote>
  </li>
  <li>
    <p><em><strong>send_empty_message:</strong></em> 长度为零并且 <code class="language-plaintext highlighter-rouge">seqno</code> 正确的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>， 在 <em><strong>TCPReceiver</strong></em> 希望通过 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 获取一些特定信息的时候特别有用， 这个和 <code class="language-plaintext highlighter-rouge">push</code> 中的那个想法很类似。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Generate an empty TCPSenderMessage */</span>
 <span class="n">TCPSenderMessage</span> <span class="n">send_empty_message</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这种长度为 0 的 segments 不需要被监测并纳入 outstanding segments 用以重传。 我们只需要返回一个仅有 <code class="language-plaintext highlighter-rouge">ackno</code> 被赋值为下一个需要接收的字节的 <code class="language-plaintext highlighter-rouge">seqno</code> 的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>。</p>
    </blockquote>
  </li>
</ol>

<p class="warning"><em><strong>FAQs and special cases</strong></em> 中的信息都很有帮助， 可以当作一种提供解题思路的 Hints。</p>

<h3 id="helper-functions">Helper Functions</h3>

<p>简化 <code class="language-plaintext highlighter-rouge">seqno</code> 与 <code class="language-plaintext highlighter-rouge">abs_seqno</code> 转换， 使用如下两个 helper functions 即可满足需求。 之后在给 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 中的 <code class="language-plaintext highlighter-rouge">ackno</code> 赋值就很方便了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">get_next_abs_seqno_</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_abs_seqno_</span><span class="p">;</span> <span class="p">};</span>
<span class="n">Wrap32</span> <span class="n">get_next_seqno</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">isn_</span> <span class="o">+</span> <span class="n">next_abs_seqno_</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>

<h2 id="4-坑点记录">4. 坑点记录</h2>

<h3 id="41-the-test-retx-syn-twice-at-the-right-times-then-ack-failed">4.1 <em>The test “Retx SYN twice at the right times, then ack” failed.</em></h3>

<p>这个问题是初始化 window size 不正确导致的， 在文档里的 FAQs 部分有这么一段：</p>

<p class="info"><strong>Q:</strong> <em>What should my TCPSender assume as the receiver’s window size before I’ve gotten an ACK from the receiver?</em>
<br />
<strong>A:</strong> One.</p>

<p>当时我将 <code class="language-plaintext highlighter-rouge">window_size_</code> 初始化为 0， 结果在调用 <code class="language-plaintext highlighter-rouge">tick</code> 函数后 <code class="language-plaintext highlighter-rouge">window_size_ &gt; 0</code> 这条条件判断语句永远不满足， <code class="language-plaintext highlighter-rouge">RTO_timeout_</code> 永远无法进行翻倍。 正确的做法是将 window size 初始化为 1。</p>

<h3 id="42-the-test-retx-syn-until-too-many-retransmissions-failed">4.2 <em>The test “Retx SYN until too many retransmissions” failed.</em></h3>

<p><code class="language-plaintext highlighter-rouge">RTO_timeout</code> 翻倍， 但我以为是初始值翻倍就直接设定成了 <code class="language-plaintext highlighter-rouge">RTO_timeout = 2 * initial_RTO_ms_</code>， 实际上指导书就是说 <em><strong>Double the value of RTO</strong></em> 并且说明是 <em><strong>exponential backoff</strong></em> （给的提示很明显 :joy:）。</p>

<h3 id="5-测试结果">5. 测试结果</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
      Start 28: send_connect
27/36 Test <span class="c">#28: send_connect .....................   Passed    0.09 sec</span>
      Start 29: send_transmit
28/36 Test <span class="c">#29: send_transmit ....................   Passed    1.11 sec</span>
      Start 30: send_retx
29/36 Test <span class="c">#30: send_retx ........................   Passed    0.08 sec</span>
      Start 31: send_window
30/36 Test <span class="c">#31: send_window ......................   Passed    0.35 sec</span>
      Start 32: send_ack
31/36 Test <span class="c">#32: send_ack .........................   Passed    0.08 sec</span>
      Start 33: send_close
32/36 Test <span class="c">#33: send_close .......................   Passed    0.09 sec</span>
      Start 34: send_extra
33/36 Test <span class="c">#34: send_extra .......................   Passed    0.16 sec</span>
      Start 36: compile with optimization
34/36 Test <span class="c">#36: compile with optimization ........   Passed   18.01 sec</span>
      Start 37: byte_stream_speed_test
             ByteStream throughput: 1.02 Gbit/s
35/36 Test <span class="c">#37: byte_stream_speed_test ...........   Passed    0.45 sec</span>
      Start 38: reassembler_speed_test
             Reassembler throughput: 1.83 Gbit/s
36/36 Test <span class="c">#38: reassembler_speed_test ...........   Passed    0.85 sec</span>

100% tests passed, 0 tests failed out of 36

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span> 170.63 sec
Built target check3
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab3: the TCP sender 的思路与实践难点。 前面一些内容看起来像翻译， 但其实也是做一遍逻辑梳理， 之后落实思路会更清晰一些。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 2: the TCP receiver</title><link href="https://hangx-ma.github.io/2023/05/23/cs144-lab2.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 2: the TCP receiver" /><published>2023-05-23T00:00:00+08:00</published><updated>2023-05-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/23/cs144-lab2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/23/cs144-lab2.html"><![CDATA[<p>记录 cs144 Spring-23 Lab2: the TCP receiver 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab2 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check2.pdf">Lab Checkpoint 2: the TCP receiver</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<p>Lab2 将实现 TCP 协议的具体细节， <em><strong>TCPReceiver</strong></em>， 以处理传入的字符流数据。 如果还记得 Lab1 中的实验框图， <em><strong>TCPReceiver</strong></em> 是 <em><strong>Reassembler</strong></em> 和 <em><strong>ByteStream</strong></em> 的上层封装， 它通过 <code class="language-plaintext highlighter-rouge">receive()</code> 函数从 peer 端接收数据， 经过 <em><strong>Reassembler</strong></em> 处理写入 <em><strong>ByteStream</strong></em> 缓存， 应用层就可以通过 <em><strong>TCPSocket</strong></em> 读取数据。</p>

<p>在接收 peer 端数据的同时， <em><strong>TCPReceiver</strong></em> 通过 <code class="language-plaintext highlighter-rouge">send()</code> 函数承担着告知 peer 一些重要信息的职责， 这些信息包括这两个部分：</p>

<ul>
  <li><strong>Acknowledgment:</strong> <code class="language-plaintext highlighter-rouge">first_unassembled_index</code> 又称 <code class="language-plaintext highlighter-rouge">ackno</code>， 是 <em><strong>TCPReceiver</strong></em> 从 peer 发送端希望收到的 <strong>第一个字节的索引号</strong>。</li>
  <li><strong>Flow Control:</strong> <code class="language-plaintext highlighter-rouge">window size</code>， 是输出到 ByteStream 的剩余空间， 限制了 <em><strong>TCPSender</strong></em> 发送数据的 <em><strong>index</strong></em> 的实际范围。 通过这个 <code class="language-plaintext highlighter-rouge">window</code>， <em><strong>TCPReceiver</strong></em> 能够 <strong>对输入的数据流量进行控制</strong>， 限制发送端的数据直到接收端准备好继续接收。</li>
</ul>

<blockquote>
  <p>通常将 <code class="language-plaintext highlighter-rouge">ackno</code> 称作 <code class="language-plaintext highlighter-rouge">window</code> 的索引左边界 （Smallest Index）， 将 <code class="language-plaintext highlighter-rouge">ackno + window size</code> 称作 <code class="language-plaintext highlighter-rouge">window</code> 的索引右边界 （Largest Index）。</p>
</blockquote>

<h2 id="2-64-bit-索引与-32-bit-序列号的转换">2. 64-bit 索引与 32-bit 序列号的转换</h2>

<div align="center">
    <img src="/norobots/images/2023-05-23-cs144-lab2/tcp-segment.png" alt="TCP segment, wikipedia" width="600" />
    <br />
    <font size="2" color="#999"><u>TCP segment, wikipedia</u></font>
</div>

<p><em><strong>Reassembler</strong></em> 重组 substrings 时每一个字节的索引号都是 64-bit， 并且其首位 <em><strong>index</strong></em> 始终是从零开始。 这是一组在当前技术条件下永远不可能溢出的数据流索引号组。 但是在 TCP segment 的头部数据中， 这一组 <code class="language-plaintext highlighter-rouge">sequence number</code> 又被称为 <code class="language-plaintext highlighter-rouge">seqno</code> 是 32-bit 的， 这组索引号与前述的数据流索引号在长度上不匹配。 32-bit 的数据可以在 100 gigabits/sec 的传输速率下在 1/3 秒内传输完， 因而其可能溢出。 这种不匹配引入了一些复杂性：</p>

<ul>
  <li>TCP 的数据流长度是不固定的， 但数据段的头部 <code class="language-plaintext highlighter-rouge">seqno</code> 仅有 32 位， 4 GiB 大小。 当 <code class="language-plaintext highlighter-rouge">seqno</code> 到达 \(2^{32} - 1\) 大小后， <code class="language-plaintext highlighter-rouge">seqno</code> 会置零。</li>
  <li>TCP <code class="language-plaintext highlighter-rouge">seqno</code> 的起始位置是任意的， ISN （Initial Sequence Number） 可以是 32-bit 中的任意值， 避免数据混淆和提高协议的鲁棒性。 那么 ISN 就代表了当前数据流的 “零点 （zero point）”， 或称其为 SYN （beginning of stream）。</li>
  <li>有 SYN （beginning of stream） 自然也有 FIN （end of stream）， 它们不属于数据流中的任意字节， 仅作为数据流的起始和末尾的两个标识符存在， 但他们分别占有一个 <code class="language-plaintext highlighter-rouge">seqno</code>。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-05-23-cs144-lab2/ex-three-types-number.png" alt="Example of Sequence Numbers, Absolute Sequence Numbers, Stream Indices" width="400" />
    <img src="/norobots/images/2023-05-23-cs144-lab2/three-types-number.png" alt="Sequence Numbers, Absolute Sequence Numbers, Stream Indices" width="600" />
    <br />
    <font size="2" color="#999"><u>Sequence Numbers, Absolute Sequence Numbers, Stream Indices</u></font>
</div>

<p>cs144 区分了三种类型的索引值， 并给出了一个 “cat” 数据的例子。 <code class="language-plaintext highlighter-rouge">seqno</code>， <code class="language-plaintext highlighter-rouge">absolute seqno</code>， 以及 <code class="language-plaintext highlighter-rouge">stream index</code>， 这些索引需要我们实现相互之间的转换， 并保持转换前后不同数据的这三类索引值之间的关系一致。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">wrap</code> 是将 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 转换为 <code class="language-plaintext highlighter-rouge">seqno</code>， 64-bit 数据本就是 32-bit 数据的倍数， 进行 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 截断直接和 <code class="language-plaintext highlighter-rouge">zero_point</code> 加和就是 wrap 后的结果。
    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">uint32_t</code> 数据类型自动将溢出部分进行了 wrap 操作。</p>
    </blockquote>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static</span> <span class="n">Wrap32</span> <span class="nf">wrap</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unwrap</code> 麻烦一些， 但指导书表明 10 行也能搞定 :joy:。 给了 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 中的 <code class="language-plaintext highlighter-rouge">checkpoint</code> 以及 <code class="language-plaintext highlighter-rouge">seqno</code> 中的 <code class="language-plaintext highlighter-rouge">zero_point</code>， <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 \([SYN,FIN] \in {64 bit}\) 之间的任意一个值。 在指导书中有这么一句：</p>

    <p><em>“Given a sequence number (the Wrap32), the Initial Sequence Number (zero point), and an absolute checkpoint sequence number, find the corresponding absolute sequence number that is closest to the checkpoint.”</em></p>

    <p>说明我们实际要转换的是一个 <code class="language-plaintext highlighter-rouge">Wrap32</code> 类型的数据， 这个数据源就是 <code class="language-plaintext highlighter-rouge">this-&gt;raw_data_</code>， 属于 <code class="language-plaintext highlighter-rouge">seqno</code>。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">uint64_t</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">checkpoint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>对于 <code class="language-plaintext highlighter-rouge">checkpoint</code> 的作用指导书也说的很明确， <code class="language-plaintext highlighter-rouge">seqno</code> 中 17 可能对应着 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 的 17， 也可能是 \(17 + 2^{32}\) 等等。 我们确定变量 <code class="language-plaintext highlighter-rouge">seqno_offset = this-&gt;raw_data_ - zero_point.raw_data_</code>， 写过 Lab0 和 Lab1 应该都清楚， <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 first_unassembled_index， 它应当比传入的 <code class="language-plaintext highlighter-rouge">seqno_offset</code> 的值要小， 若 <code class="language-plaintext highlighter-rouge">checkpoint &gt;= seqno_offset</code>， 我们就需要找到具体偏移了几个 \(2^{32}\)， 那最终的 <code class="language-plaintext highlighter-rouge">absolute seqno = seqno_offset + UINT32_SIZE_num * UINT32_SIZE</code>。</p>
  </li>
</ul>

<h2 id="3-tcp-receiver-实现">3. TCP Receiver 实现</h2>

<p>cs144 提供了 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 和 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code>, 前者用于 <code class="language-plaintext highlighter-rouge">receive</code> 后者用于 <code class="language-plaintext highlighter-rouge">send</code>。</p>

<ol>
  <li><em><strong>receive：</strong></em> 该部分有两个要求
    <ul>
      <li>在必要时， 也就是 message 中包含 SYN 时， 需要保存这个 SYN 的 <code class="language-plaintext highlighter-rouge">seqno</code>。</li>
      <li>将 payload 部分的数据推送给 <em><strong>Reassembler</strong></em>， FIN 作为标识符控制 push 过程的终止。</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span><span class="n">TCPSenderMessage</span> <span class="n">message</span><span class="p">,</span> <span class="n">Reassembler</span> <span class="o">&amp;</span><span class="n">reassembler</span><span class="p">,</span> <span class="n">Writer</span> <span class="o">&amp;</span><span class="n">inbound_stream</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>可以明确的是， 在 <em><strong>TCPReceiver</strong></em> 还没有接收到 SYN 时， 所有的数据都不应当被送入 <em><strong>Reassembler</strong></em>， 因为此时的数据传输还没有开始， 所以我们需要有一个标志位表明数据开始传输。</p>

    <p>另外传输的时候使用的是 <code class="language-plaintext highlighter-rouge">stream_index</code>， 而我们得到的是 <code class="language-plaintext highlighter-rouge">seqno</code>， 首先需要将 <code class="language-plaintext highlighter-rouge">seqno</code> 转为 <code class="language-plaintext highlighter-rouge">absolute seqno</code>， 我们已经写好了 <code class="language-plaintext highlighter-rouge">unwarp</code> 函数， 需要提供 <code class="language-plaintext highlighter-rouge">checkpoint</code>。 <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 <em>first_unassembled_index</em>， 也就是下一个需要被 buffer 存储的字节。 在 Lab0 中我们完成的 <code class="language-plaintext highlighter-rouge">Writer</code> 类有一个 <code class="language-plaintext highlighter-rouge">bytes_pushed()</code> 函数， <code class="language-plaintext highlighter-rouge">bytes_pushed() + 1 = checkpoint</code>。</p>

    <p><code class="language-plaintext highlighter-rouge">absolute_seqno</code> 转换为 <code class="language-plaintext highlighter-rouge">stream_index</code> 时需要考虑当前的 message 是否有 SYN 部分。 我们给 <code class="language-plaintext highlighter-rouge">unwrap</code> 提供的 <code class="language-plaintext highlighter-rouge">zero_point</code> 是以 SYN 对应的 <code class="language-plaintext highlighter-rouge">seqno</code>， 若 SYN 在当前的 message 中不存在， 则 <code class="language-plaintext highlighter-rouge">zero_point</code> 应当为当前 payload 的第一个字节。 所以有如下转换满足：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">uint64_t</span> <span class="n">stream_index</span> <span class="o">=</span> <span class="n">abs_seqno</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">message</span><span class="p">.</span><span class="n">SYN</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>之后我们只需要提供 <code class="language-plaintext highlighter-rouge">inbound_stream.insert()</code> 所需要的各个变量即可。</p>
  </li>
  <li>
    <p><em><strong>send：</strong></em> 这里只需要注意只有 <code class="language-plaintext highlighter-rouge">ackno</code> 是 optional 属性， <code class="language-plaintext highlighter-rouge">window_size</code> 是每次都要发送的。 如果已经收到 FIN 那段 message， 满足 <code class="language-plaintext highlighter-rouge">inbound_stream.is_closed() == true</code> 那我们需要增加 FIN 部分的长度。 但也别忘了传输开始后， SYN 也是占有一个 <code class="language-plaintext highlighter-rouge">seqno</code> 位置的。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">TCPReceiverMessage</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">Writer</span> <span class="o">&amp;</span><span class="n">inbound_stream</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="4-测试结果">4. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/cs144-sp23/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check2
Test project /home/cs144/cs144-sp23/minnow/build
      Start  1: compile with bug-checkers
 1/29 Test  <span class="c">#1: compile with bug-checkers ........   Passed   20.37 sec</span>
 ...
      Start 21: recv_connect
20/29 Test <span class="c">#21: recv_connect .....................   Passed    0.09 sec</span>
      Start 22: recv_transmit
21/29 Test <span class="c">#22: recv_transmit ....................   Passed    0.75 sec</span>
      Start 23: recv_window
22/29 Test <span class="c">#23: recv_window ......................   Passed    0.09 sec</span>
      Start 24: recv_reorder
23/29 Test <span class="c">#24: recv_reorder .....................   Passed    0.09 sec</span>
      Start 25: recv_reorder_more
24/29 Test <span class="c">#25: recv_reorder_more ................   Passed    1.86 sec</span>
      Start 26: recv_close
25/29 Test <span class="c">#26: recv_close .......................   Passed    0.09 sec</span>
      Start 27: recv_special
26/29 Test <span class="c">#27: recv_special .....................   Passed    0.10 sec</span>
      Start 28: compile with optimization
27/29 Test <span class="c">#28: compile with optimization ........   Passed   18.11 sec</span>
      Start 29: byte_stream_speed_test
             ByteStream throughput: 0.63 Gbit/s
28/29 Test <span class="c">#29: byte_stream_speed_test ...........   Passed    0.71 sec</span>
      Start 30: reassembler_speed_test
             Reassembler throughput: 1.33 Gbit/s
29/29 Test <span class="c">#30: reassembler_speed_test ...........   Passed    1.23 sec</span>

100% tests passed, 0 tests failed out of 29

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  47.45 sec
Built target check2
</code></pre></div></div>

<h2 id="website">Website</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol - wikipedia</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab2: the TCP receiver 的思路与实践难点。]]></summary></entry><entry><title type="html">私有化 Git Pages 源码仓库</title><link href="https://hangx-ma.github.io/2023/05/21/protect-source-data.html" rel="alternate" type="text/html" title="私有化 Git Pages 源码仓库" /><published>2023-05-21T00:00:00+08:00</published><updated>2023-05-21T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/21/protect-source-data</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/21/protect-source-data.html"><![CDATA[<h2 id="1-前言">1. 前言</h2>

<p>被一件事儿恶心到了， 发现最开始发在博客园上的文章被爬到了一个不知名的小网站， 没有署名， 没有注明来源。 真的对这种侵犯个人权利的事情感到恶心， 至少引用和转载文章需要注明来源。 国内互联网的内容同质化严重， 优质内容也逐渐减少不是没有道理的。</p>

<p>一气之下把 cnblogs 的内容都删掉了。</p>

<p>后来又想了想什么地方造成了数据外泄， 毕竟 markdown 数据也是保存在自己的私有仓库中， 估计 content 部分的内容被精准地洗劫了， 而且图片是上传在博客园的服务器上的， 被爬走还能正常显示， 这和在 Git Pages 中用相对地址引用还有区别。</p>

<p>感觉自己的 Git Pages 把源码都泄露在外头无异于数据裸奔， 另外 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 每次都需要自己去手动更新， 明明 jekyll-sitemap 插件能够将这件事情自动化处理， 于是产生了分离源码仓库和展示仓库的想法。</p>

<h2 id="2-私有化与自动化部署">2. 私有化与自动化部署</h2>

<p>实现的思路很清晰， 通过 Github Action 实现私有仓库的数据编译， 再将编译后的内容推送到目标公有仓库中， 所有的内容均对外不可见就完成了源码的私有化和部署的公有化。</p>

<div class="mermaid" align="center">
flowchart LR
    p1(Private Repository)
    p2(Git Action)
    p3(Public Repository)
    style p1 fill:#4F94CD,stroke:#363636,stroke-width:2px,color:#F5F5F5
    style p2 fill:#DCDCDC,stroke:#363636,color:#8B8B7A,color:#696969
    style p3 fill:#FF6A6A,stroke:#363636,stroke-width:2px,color:#F5F5F5
    p1 --&gt; p2
    p2 --&gt;|Compile/Push| p3
</div>

<p>需要在自己的源码仓库中创建 <code class="language-plaintext highlighter-rouge">.github/workflows/jekyll.yml</code> 文件， 当然文件名可以自定义。 这样 Git Action 就可以识别这个配置文件的内容， 这个仓库就能执行配置文件定义的各个步骤。 在其中复制粘贴如下代码， 将其中带有提示性的大写的字符都替换为自己的配置。 但需要注意的是， 我们需要通过 <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa</code> 生成用于该仓库推送的一对密钥， 将私有密钥填写在私有仓库的 <code class="language-plaintext highlighter-rouge">Settings-&gt;Actions secrets and variables</code> 的 <code class="language-plaintext highlighter-rouge">Secrets</code> 中， 并将这个 <em>secret</em> 命名为 <code class="language-plaintext highlighter-rouge">DEPLOY_KEY</code>。 之后需要将公有密钥添加到 Github 账号的 <code class="language-plaintext highlighter-rouge">Settings-&gt;SSH and GPG keys</code> 中。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This workflow uses actions that are not certified by GitHub.</span>
<span class="c1"># They are provided by a third-party and are governed by</span>
<span class="c1"># separate terms of service, privacy policy, and support</span>
<span class="c1"># documentation.</span>

<span class="c1"># Sample workflow for building and deploying a Jekyll site to GitHub Pages</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Deploy Jekyll site to Pages</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="c1"># Runs on pushes targeting the default branch</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">YOUR_PRIVATE_REPO_SOURCE_BRANCH"</span><span class="pi">]</span>

  <span class="c1"># Allows you to run this workflow manually from the Actions tab</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>

<span class="c1"># Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages</span>
<span class="na">permissions</span><span class="pi">:</span>
  <span class="na">contents</span><span class="pi">:</span> <span class="s">read</span>
  <span class="na">pages</span><span class="pi">:</span> <span class="s">write</span>
  <span class="na">id-token</span><span class="pi">:</span> <span class="s">write</span>

<span class="c1"># Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.</span>
<span class="c1"># However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.</span>
<span class="na">concurrency</span><span class="pi">:</span>
  <span class="na">group</span><span class="pi">:</span> <span class="s2">"</span><span class="s">pages"</span>
  <span class="na">cancel-in-progress</span><span class="pi">:</span> <span class="kc">false</span>

<span class="na">env</span><span class="pi">:</span>
  <span class="na">TZ</span><span class="pi">:</span> <span class="s">Asia/Shanghai</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="c1"># Build job</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
        <span class="na">with</span><span class="pi">:</span>
           <span class="na">persist-credentials</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># false 是用 personal token，true 是使用 GitHub token</span>
           <span class="na">fetch-depth</span><span class="pi">:</span> <span class="m">0</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Ruby</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">ruby/setup-ruby@55283cc23133118229fd3f97f9336ee23a179fcf</span> <span class="c1"># v1.146.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">ruby-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.1'</span> <span class="c1"># Not needed with a .ruby-version file</span>
          <span class="na">bundler-cache</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># runs 'bundle install' and caches installed gems automatically</span>
          <span class="na">cache-version</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># Increment this number if you need to re-download cached gems</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build with Jekyll</span>
        <span class="c1"># Outputs to the './_site' directory by default</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">bundle exec jekyll build --baseurl "$" --config ./_config.yml</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">JEKYLL_ENV</span><span class="pi">:</span> <span class="s">production</span>
          <span class="na">TZ</span><span class="pi">:</span> <span class="s">Asia/Shanghai</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload artifact</span>
        <span class="c1"># Automatically uploads an artifact from the './_site' directory by default</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/upload-pages-artifact@v1</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set SSH Environment</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="c1"># 1. Add this private key and title as DEPLOY_KEY in this repo -&gt; settings/secrets</span>
          <span class="c1"># 2. Add corresponding public key and named as any text to the github page repo -&gt; settings/deploy keys</span>
          <span class="na">DEPLOY_KEY</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">USER_NAME</span><span class="pi">:</span> <span class="s">YOUR_USER_NAME</span>
          <span class="na">USER_EMAIL</span><span class="pi">:</span> <span class="s">YOUR_USER_EMAIL</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">mkdir -p ~/.ssh/</span>
          <span class="s">echo "$DEPLOY_KEY" | tr -d '\r' &gt; ~/.ssh/id_rsa</span>
          <span class="s">chmod 600 ~/.ssh/id_rsa</span>
          <span class="s">chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/*</span>
          <span class="s">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span>
          <span class="s">git config --global user.name $USER_NAME</span>
          <span class="s">git config --global user.email $USER_EMAIL</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Commit and Push to Git Pages</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">USER_NAME</span><span class="pi">:</span> <span class="s">YOUR_USER_NAME</span>
          <span class="na">USER_EMAIL</span><span class="pi">:</span> <span class="s">YOUR_USER_EMAIL</span>
        <span class="na">working-directory</span><span class="pi">:</span> <span class="s">./</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span> 
          <span class="s">git clone -b PUBLIC_REPOSITORY_BRANCH git@github.com:YOUR_USER_NAME/YOUR_USER_NAME.github.io.git gitpage_repo</span>
          <span class="s">cd gitpage_repo</span>
          <span class="s">cp robots.txt ../_site/robots.txt</span>
          <span class="s">rm -rf *</span>
          <span class="s">cp -r ../_site/* .</span>
          <span class="s">git add -A</span>
          <span class="s">git -c user.name="$USER_NAME" -c user.email="$USER_EMAIL" commit -am "Site Updated: `date +'%Y-%m-%d %H:%M:%S'`" </span>
          <span class="s">git push origin master -f -q</span>
</code></pre></div></div>

<p>简化了个人摸索这个自动化配置的过程， 若对以上配置有所疑惑之处， 可以参考以下文章加深个人理解。 如有问题欢迎留言询问~</p>

<blockquote>
  <p><a href="https://juejin.cn/post/7120474763910676488">GitHub 私有仓库免费开启 GitHub Pages 的可行性方案</a><br />
<a href="https://babybluue.github.io/posts/89195a6e">通过Github Action自动部署Hexo</a><br />
<a href="https://gist.github.com/Half9000/7d83d7f8dea012926dc7d2203a1f169e">Hexo Deploy with Github Actions workflow</a><br />
<a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog/">使用 GitHub Actions 自动部署 Hexo 博客</a><br />
<a href="https://blog.csdn.net/shiwanghualuo/article/details/128514693">github actions中如何判断仓库是否有变更</a></p>
</blockquote>

<h2 id="3-爬虫与目录结构保护">3. 爬虫与目录结构保护</h2>

<p>更改网站的 <code class="language-plaintext highlighter-rouge">robots.txt</code> 为如下形式</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">layout</span><span class="pi">:</span> <span class="kc">null</span>
<span class="nn">---</span>

<span class="na">User-agent</span><span class="pi">:</span> <span class="err">*</span>

<span class="na">Disallow</span><span class="pi">:</span> <span class="s">/assets/</span>   <span class="c1"># /assets/ 是常规资源目录，不怕暴露路径</span>
<span class="na">Disallow</span><span class="pi">:</span> <span class="s">/norobots/</span> <span class="c1"># 零碎敏感文件、目录等放置在此</span>

<span class="na">Sitemap</span><span class="pi">:</span> <span class="s">https://hangx-ma.github.io/sitemap.xml</span>

</code></pre></div></div>

<p>出于安全考虑，站点的某些目录结构，譬如 <code class="language-plaintext highlighter-rouge">/norobots/</code>， 不希望被外部访问， 所以需要使用重定向来保护目录， 可以使用 GitHub 推荐的 Jekyll 重定向插件 <a href="https://github.com/jekyll/jekyll-redirect-from">Jekyll Redirect From</a>。</p>

<p>GitHub Pages 默认支持该插件，在项目的 <code class="language-plaintext highlighter-rouge">Gemfile</code> 里添加引用：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem "jekyll-redirect-from"
</code></pre></div></div>

<p>接着运行 <code class="language-plaintext highlighter-rouge">bundle install</code> 命令安装插件，安装完成后，在站点 404 页面的 YAML 头部添加跳转规则：</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">redirect_from</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">/norobots/</span>
<span class="nn">---</span>
</code></pre></div></div>

<p>具体的目录可以更具自己站点的实际情况定义， 按照上述定义， <code class="language-plaintext highlighter-rouge">访问 {SITE_URL}/norobots/</code> 会直接返回 404 页面， 从而保护了敏感目录。</p>

<blockquote>
  <p><a href="https://cotes.page/posts/the-seo-to-jekyll/">Jekyll 的 SEO 优化</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="Git" /><summary type="html"><![CDATA[通过私有化 Git Pages 源码仓库， 并自动化推送和部署公有 Git Pages 仓库以实现源数据保护。]]></summary></entry></feed>