<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2024-02-04T16:16:56+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">CSAPP - Bomb Lab</title><link href="https://hangx-ma.github.io/2023/12/12/csapp-bomblab.html" rel="alternate" type="text/html" title="CSAPP - Bomb Lab" /><published>2023-12-12T00:00:00+08:00</published><updated>2023-12-12T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/12/12/csapp-bomblab</id><content type="html" xml:base="https://hangx-ma.github.io/2023/12/12/csapp-bomblab.html"><![CDATA[<p>Computer Systems: A Programmer’s Perspective, 3/E (CS:APP3e) – Bomb Lab， 实现源码可从 <a href="https://github.com/HangX-Ma/csapp/tree/main/02-bomblab">HangX-Ma/csapp: 02-bomblab</a> 获取。
<!--more--></p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Progress and timeline <font color="#4682B4">[2/14]</font></li>
</ul>

<p>阅读 <a href="https://csapp.cs.cmu.edu/3e/students.html">CS:APP3e Student Site - Online GDB Materials</a> 章节的内容可以快速熟悉 GDB 的使用指令， 另外 <a href="https://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">GDB Notes</a> 罗列了一系列常用的 GDB 指令， 比网上搜索的要简洁完备。</p>

<p>开始实验之前用 <code class="language-plaintext highlighter-rouge">objdump -d bomb &gt; bomb.s</code> 反汇编这段二级制代码， 后续就不用在 GDB 里用 <code class="language-plaintext highlighter-rouge">print</code> 找半天了， 便捷很多。</p>

<h2 id="1-phase1">1. Phase1</h2>

<p>从 <code class="language-plaintext highlighter-rouge">bomb.c</code> 文件可以看到总共有 6 个 phase 的问题， 不难直接定位 <code class="language-plaintext highlighter-rouge">phase_1</code> 所在的部分：</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">0000000000400</span><span class="n">ee0</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_1</span><span class="o">&gt;:</span><span class="w">
  </span><span class="m">400</span><span class="n">ee0</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">sub</span><span class="w">    </span><span class="o">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%rsp
  400ee4:	be 00 24 40 00       	mov    $0x402400,%</span><span class="n">esi</span><span class="w">
  </span><span class="m">400</span><span class="n">ee9</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">4</span><span class="n">a</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">401338</span><span class="w"> </span><span class="o">&lt;</span><span class="n">strings_not_equal</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">eee</span><span class="o">:</span><span class="w">	</span><span class="m">85</span><span class="w"> </span><span class="n">c0</span><span class="w">                	</span><span class="n">test</span><span class="w">   </span><span class="o">%eax,%</span><span class="n">eax</span><span class="w">
  </span><span class="m">400</span><span class="n">ef0</span><span class="o">:</span><span class="w">	</span><span class="m">74</span><span class="w"> </span><span class="m">05</span><span class="w">                	</span><span class="n">je</span><span class="w">     </span><span class="m">400</span><span class="n">ef7</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_1</span><span class="m">+0</span><span class="n">x17</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">ef2</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">43</span><span class="w"> </span><span class="m">05</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">ef7</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%</span><span class="n">rsp</span><span class="w">
  </span><span class="m">400</span><span class="n">efb</span><span class="o">:</span><span class="w">	</span><span class="n">c3</span><span class="w">                   	</span><span class="n">ret</span><span class="w">    
</span></code></pre></div></div>

<p>这里可以看到 <code class="language-plaintext highlighter-rouge">string_not_equal</code> 函数会进行字符串匹配， 而在调用函数之前， <code class="language-plaintext highlighter-rouge">%esi</code> 寄存器实际上传递的是第二个函数参数， 这个需要留意。 那索性看看 <code class="language-plaintext highlighter-rouge">string_note_equal</code> 函数做了什么：</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">0000000000401338</span><span class="w"> </span><span class="o">&lt;</span><span class="n">strings_not_equal</span><span class="o">&gt;:</span><span class="w">
  </span><span class="m">401338</span><span class="o">:</span><span class="w">	</span><span class="m">41</span><span class="w"> </span><span class="m">54</span><span class="w">                	</span><span class="n">push</span><span class="w">   </span><span class="o">%r12
  40133a:	55                   	push   %</span><span class="n">rbp</span><span class="w">
  </span><span class="m">40133</span><span class="n">b</span><span class="o">:</span><span class="w">	</span><span class="m">53</span><span class="w">                   	</span><span class="n">push</span><span class="w">   </span><span class="o">%rbx
  40133c:	48 89 fb             	mov    %</span><span class="n">rdi</span><span class="p">,</span><span class="o">%rbx
  40133f:	48 89 f5             	mov    %</span><span class="n">rsi</span><span class="p">,</span><span class="o">%rbp
  401342:	e8 d4 ff ff ff       	call   40131b &lt;string_length&gt;
  401347:	41 89 c4             	mov    %</span><span class="n">eax</span><span class="p">,</span><span class="o">%r12d
  40134a:	48 89 ef             	mov    %</span><span class="n">rbp</span><span class="p">,</span><span class="o">%rdi
  40134d:	e8 c9 ff ff ff       	call   40131b &lt;string_length&gt;
  401352:	ba 01 00 00 00       	mov    $0x1,%</span><span class="n">edx</span><span class="w">
  </span><span class="m">401357</span><span class="o">:</span><span class="w">	</span><span class="m">41</span><span class="w"> </span><span class="m">39</span><span class="w"> </span><span class="n">c4</span><span class="w">             	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%eax,%</span><span class="n">r12d</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span></code></pre></div></div>

<p>这里没有放全部的代码， 但前面的处理也比较清晰了。 <code class="language-plaintext highlighter-rouge">%rdi</code> 存储的是第一个函数参数， 可以看两次 <code class="language-plaintext highlighter-rouge">string_length</code> 函数调用存储的结果会进行比较， 如果不同就会 Explore Bomb。 而函数的输入参数在观察后也是清晰的， 仅有一个输入参数， 第一次给的 <code class="language-plaintext highlighter-rouge">%rdi</code> 中的内容， 第二次则是 <code class="language-plaintext highlighter-rouge">%rsi</code> 中的内容。 而在进入 <code class="language-plaintext highlighter-rouge">strings_not_equal</code> 之前 <code class="language-plaintext highlighter-rouge">%esi</code> 中的内容被赋值为了 <code class="language-plaintext highlighter-rouge">0x402400</code>， 说明这个地址应当存储着被比较的答案。 那么， 在 GDB 调试的时候不妨在 <code class="language-plaintext highlighter-rouge">0x400ee9</code> 调用 <code class="language-plaintext highlighter-rouge">strings_not_equal</code> 函数处设置断点， 调用如下命令打印的内容就是答案了：</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">(gdb) b *0x400ee9
(gdb) r
(gdb) print (char *)0x402400
</span><span class="gp">$</span>1 <span class="o">=</span> <span class="s2">"Border relations with Canada have never been better."</span>
</code></pre></div></div>

<blockquote>
  <p>用如上命令的主要原因是此处比较的是字符串是否匹配，　因而猜测答案应该是一串字符串。</p>
</blockquote>
<div class="premonition note"> <div class="header"> <i class="fas fa-sticky-note" style="color: #87d8f2;"></i> <div class="title"> Note </div> </div> <div class="content"> <p>将上述答案放入 <code class="language-plaintext highlighter-rouge">result.txt</code> 文件的时候， 需要单独留一空行在最后， 否则 EOF 读取会有误。</p>



 </div> </div>
<h2 id="2-phase2">2. Phase2</h2>

<p>开始在 <code class="language-plaintext highlighter-rouge">read_six_numbers</code> 函数里面看了半天， 发现就是读了几个数塞到特定的位置， 其中调用了 <code class="language-plaintext highlighter-rouge">sscanf</code>。 在过来看这段 <code class="language-plaintext highlighter-rouge">phase_2</code> 的代码， 获取数据后对 <code class="language-plaintext highlighter-rouge">%rsp</code> 存储的内容进行比较， 只有为 1 才会跳转到 <code class="language-plaintext highlighter-rouge">0x400f30</code> 位置， 取了一些值后继续跳转到 <code class="language-plaintext highlighter-rouge">0x400f17</code> 位置。 获取了 <code class="language-plaintext highlighter-rouge">%rsp</code> 寄存器中的内容， 一开始这个寄存器被设置为 1， 0x400f17 到 0x400f29 这部分代码就是检测前当前 <code class="language-plaintext highlighter-rouge">(%rbx)</code> 的值是否为 <code class="language-plaintext highlighter-rouge">-0x4%(rbx)</code> 即前一个值的两倍， 甚至这里的 4 字节宽度可以看出是个 <code class="language-plaintext highlighter-rouge">int</code> 类型数据， 总共循环 6 次。</p>

<p>不难推断出答案应当为 <code class="language-plaintext highlighter-rouge">1 2 4 8 16 32</code>， 当然可以在 <code class="language-plaintext highlighter-rouge">0x400f1a</code> 处打断点， 查看上一个值 <code class="language-plaintext highlighter-rouge">%eax</code> 和 现在的值 <code class="language-plaintext highlighter-rouge">(%rbx)</code> 的内容也是一样的。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">0000000000400</span><span class="n">efc</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_2</span><span class="o">&gt;:</span><span class="w">
  </span><span class="m">400</span><span class="n">efc</span><span class="o">:</span><span class="w">	</span><span class="m">55</span><span class="w">                   	</span><span class="n">push</span><span class="w">   </span><span class="o">%rbp
  400efd:	53                   	push   %</span><span class="n">rbx</span><span class="w">
  </span><span class="m">400</span><span class="n">efe</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="m">28</span><span class="w">          	</span><span class="n">sub</span><span class="w">    </span><span class="o">$</span><span class="mh">0x28</span><span class="p">,</span><span class="o">%rsp
  400f02:	48 89 e6             	mov    %</span><span class="n">rsp</span><span class="p">,</span><span class="o">%rsi
  400f05:	e8 52 05 00 00       	call   40145c &lt;read_six_numbers&gt;
  400f0a:	83 3c 24 01          	cmpl   $0x1,(%</span><span class="n">rsp</span><span class="p">)</span><span class="w">
  </span><span class="m">400</span><span class="n">f0e</span><span class="o">:</span><span class="w">	</span><span class="m">74</span><span class="w"> </span><span class="m">20</span><span class="w">                	</span><span class="n">je</span><span class="w">     </span><span class="m">400</span><span class="n">f30</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_2</span><span class="m">+0</span><span class="n">x34</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f10</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">25</span><span class="w"> </span><span class="m">05</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f15</span><span class="o">:</span><span class="w">	</span><span class="n">eb</span><span class="w"> </span><span class="m">19</span><span class="w">                	</span><span class="n">jmp</span><span class="w">    </span><span class="m">400</span><span class="n">f30</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_2</span><span class="m">+0</span><span class="n">x34</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f17</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">43</span><span class="w"> </span><span class="n">fc</span><span class="w">             	</span><span class="n">mov</span><span class="w">    </span><span class="m">-0</span><span class="n">x4</span><span class="p">(</span><span class="o">%rbx),%</span><span class="n">eax</span><span class="w">
  </span><span class="m">400</span><span class="n">f1a</span><span class="o">:</span><span class="w">	</span><span class="m">01</span><span class="w"> </span><span class="n">c0</span><span class="w">                	</span><span class="n">add</span><span class="w">    </span><span class="o">%eax,%</span><span class="n">eax</span><span class="w">
  </span><span class="m">400</span><span class="n">f1c</span><span class="o">:</span><span class="w">	</span><span class="m">39</span><span class="w"> </span><span class="m">03</span><span class="w">                	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%eax,(%</span><span class="n">rbx</span><span class="p">)</span><span class="w">
  </span><span class="m">400</span><span class="n">f1e</span><span class="o">:</span><span class="w">	</span><span class="m">74</span><span class="w"> </span><span class="m">05</span><span class="w">                	</span><span class="n">je</span><span class="w">     </span><span class="m">400</span><span class="n">f25</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_2</span><span class="m">+0</span><span class="n">x29</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f20</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">15</span><span class="w"> </span><span class="m">05</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f25</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="m">04</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%rbx
  400f29:	48 39 eb             	cmp    %</span><span class="n">rbp</span><span class="p">,</span><span class="o">%rbx
  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;
  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;
  400f30:	48 8d 5c 24 04       	lea    0x4(%</span><span class="n">rsp</span><span class="p">),</span><span class="o">%rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%</span><span class="n">rsp</span><span class="p">),</span><span class="o">%rbp
  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;
  400f3c:	48 83 c4 28          	add    $0x28,%</span><span class="n">rsp</span><span class="w">
  </span><span class="m">400</span><span class="n">f40</span><span class="o">:</span><span class="w">	</span><span class="m">5</span><span class="n">b</span><span class="w">                   	</span><span class="n">pop</span><span class="w">    </span><span class="o">%rbx
  400f41:	5d                   	pop    %</span><span class="n">rbp</span><span class="w">
  </span><span class="m">400</span><span class="n">f42</span><span class="o">:</span><span class="w">	</span><span class="n">c3</span><span class="w">                   	</span><span class="n">ret</span><span class="w">    
</span></code></pre></div></div>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">(gdb) print /d $</span>rax
<span class="gp">$</span>1 <span class="o">=</span> 1
<span class="gp">(gdb) print *(int *) ($</span>rbx<span class="o">)</span>
<span class="gp">$</span>2 <span class="o">=</span> 2
</code></pre></div></div>

<div class="premonition note"> <div class="header"> <i class="fas fa-sticky-note" style="color: #87d8f2;"></i> <div class="title"> Note </div> </div> <div class="content"> <p>这里要注意的是， 在进入 GDB 调试之前， 需要用 <code class="language-plaintext highlighter-rouge">set args result.txt</code> 设置程序的读取参数。 另外， bomb 程序会要求输入一组数， 一定要记得先随便输入 6 个数， 否则在判断输入数量就会出错了。</p>



 </div> </div>
<h2 id="3-phase3">3. Phase3</h2>

<p>乍一看是理不出具体的操作的， 不过有几个地方还是能找到一些信息的。 如下代码先将 <code class="language-plaintext highlighter-rouge">%rsp</code> 预留出的几个位置的地址放到了 <code class="language-plaintext highlighter-rouge">%rcx</code> 和 <code class="language-plaintext highlighter-rouge">%rdx</code> 寄存器。 我们知道 <code class="language-plaintext highlighter-rouge">%rdx</code> 和 <code class="language-plaintext highlighter-rouge">%rcx</code> 是用以传输第三第四个参数的， 根据 <code class="language-plaintext highlighter-rouge">int sscanf(const char *str, const char *format, ...)</code> 的函数声明， 不难得知 <code class="language-plaintext highlighter-rouge">%esi</code> 中的内容通过 <code class="language-plaintext highlighter-rouge">sscanf</code> 格式化后写入到了 <code class="language-plaintext highlighter-rouge">%rdx</code> 和 <code class="language-plaintext highlighter-rouge">%rcx</code> 并返回格式化参数的个数。</p>

<blockquote>
  <p>通过读取 <code class="language-plaintext highlighter-rouge">0x4025cf</code> 处的内容得知为 <strong>“%d %d”</strong> 说明会格式化 2 个 <code class="language-plaintext highlighter-rouge">int</code> 类型的数据， 与猜测相符合。</p>
</blockquote>

<p>按照下面的代码， 需要返回参数数量在需要大于 1 并且， 并且 <code class="language-plaintext highlighter-rouge">%rdx</code> 的值需要小于等于 7 否则会 Explore Bomb。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">0000000000400</span><span class="n">f43</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_3</span><span class="o">&gt;:</span><span class="w">
  </span><span class="m">400</span><span class="n">f43</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">ec</span><span class="w"> </span><span class="m">18</span><span class="w">          	</span><span class="n">sub</span><span class="w">    </span><span class="o">$</span><span class="mh">0x18</span><span class="p">,</span><span class="o">%rsp
  400f47:	48 8d 4c 24 0c       	lea    0xc(%</span><span class="n">rsp</span><span class="p">),</span><span class="o">%rcx
  400f4c:	48 8d 54 24 08       	lea    0x8(%</span><span class="n">rsp</span><span class="p">),</span><span class="o">%rdx
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%</span><span class="n">esi</span><span class="w">
  </span><span class="m">400</span><span class="n">f56</span><span class="o">:</span><span class="w">	</span><span class="n">b8</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%eax
  400f5b:	e8 90 fc ff ff       	call   400bf0 &lt;__isoc99_sscanf@plt&gt;
  400f60:	83 f8 01             	cmp    $0x1,%</span><span class="n">eax</span><span class="w">
  </span><span class="m">400</span><span class="n">f63</span><span class="o">:</span><span class="w">	</span><span class="m">7</span><span class="n">f</span><span class="w"> </span><span class="m">05</span><span class="w">                	</span><span class="n">jg</span><span class="w">     </span><span class="m">400</span><span class="n">f6a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_3</span><span class="m">+0</span><span class="n">x27</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f65</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="n">d0</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">f6a</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="m">7</span><span class="n">c</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">07</span><span class="w">       	</span><span class="n">cmpl</span><span class="w">   </span><span class="o">$</span><span class="mh">0x7</span><span class="p">,</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rsp</span><span class="p">)</span><span class="w">
  </span><span class="m">400</span><span class="n">f6f</span><span class="o">:</span><span class="w">	</span><span class="m">77</span><span class="w"> </span><span class="m">3</span><span class="n">c</span><span class="w">                	</span><span class="n">ja</span><span class="w">     </span><span class="m">400</span><span class="n">fad</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_3</span><span class="m">+0</span><span class="n">x6a</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>之后就是一个间接跳转的指令了， 这个间接跳转的指令和第一个输入的值有关系， 第一个输入的值在 0 到 7 之间， 那么就会根据第一参数跳转到不同的位置， 可以查看 <code class="language-plaintext highlighter-rouge">0x402470</code> 的值为 <strong>0x400f7c</strong>， 需要第二个输入的值为 <code class="language-plaintext highlighter-rouge">0x137</code> 这不巧了， 下面一对类似的语句应该都是间接跳转的情况。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">400</span><span class="n">f71</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">44</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">mov</span><span class="w">    </span><span class="mh">0x8</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">eax</span><span class="w">
  </span><span class="m">400</span><span class="n">f75</span><span class="o">:</span><span class="w">	</span><span class="n">ff</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="n">c5</span><span class="w"> </span><span class="m">70</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">40</span><span class="w"> </span><span class="m">00</span><span class="w"> 	</span><span class="n">jmp</span><span class="w">    </span><span class="o">*</span><span class="mh">0x402470</span><span class="p">(,</span><span class="o">%</span><span class="n">rax</span><span class="p">,</span><span class="m">8</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>如此有不同的答案， 分别为 <code class="language-plaintext highlighter-rouge">0 207</code>， <code class="language-plaintext highlighter-rouge">1 311</code>， <code class="language-plaintext highlighter-rouge">2 707</code>， <code class="language-plaintext highlighter-rouge">3 256</code>， <code class="language-plaintext highlighter-rouge">4 389</code>， <code class="language-plaintext highlighter-rouge">5 206</code>， <code class="language-plaintext highlighter-rouge">6 682</code>， <code class="language-plaintext highlighter-rouge">7 327</code>。 真贴心， 还打乱了顺序！</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">(gdb) print /x *(int *) 0x402470
</span><span class="gp">$</span>1 <span class="o">=</span> 0x400f7c
<span class="go">(gdb) print /x *(int *) 0x402478
</span><span class="gp">$</span>2 <span class="o">=</span> 0x400fb9
<span class="go">(gdb) print /x *(int *) 0x402480
</span><span class="gp">$</span>3 <span class="o">=</span> 0x400f83
<span class="go">(gdb) print /x *(int *) 0x402488
</span><span class="gp">$</span>4 <span class="o">=</span> 0x400f8a
<span class="go">(gdb) print /x *(int *) 0x402490
</span><span class="gp">$</span>5 <span class="o">=</span> 0x400f91
<span class="go">(gdb) print /x *(int *) 0x402498
</span><span class="gp">$</span>6 <span class="o">=</span> 0x400f98
<span class="go">(gdb) print /x *(int *) 0x4024a0
</span><span class="gp">$</span>7 <span class="o">=</span> 0x400f9f
<span class="go">(gdb) print /x *(int *) 0x4024a8
</span><span class="gp">$</span>8 <span class="o">=</span> 0x400fa6
</code></pre></div></div>

<h2 id="4-phase4">4. Phase4</h2>

<p>同样也是读取数据如出一辙， 甚至连字符串的地址都和 Phase3 的一致。 不过 <code class="language-plaintext highlighter-rouge">cmpl    $0xe,0x8(%rsp)</code> 这一句要求 <code class="language-plaintext highlighter-rouge">%rdx</code> 获取到的第一个参数值要小于等于 0xe。</p>

<p>后面的这几句也很明确， 为了调用 <code class="language-plaintext highlighter-rouge">func4</code> 函数， 将其第三个参数 <code class="language-plaintext highlighter-rouge">%edx</code> 设置为 0xe， 第二个参数 <code class="language-plaintext highlighter-rouge">%esi</code> 设置为 0x0， 第一个参数则是从 <code class="language-plaintext highlighter-rouge">sscanf</code> 输入读取的第一个参数。 暂且放一放 <code class="language-plaintext highlighter-rouge">func4</code>， 0x401051 地址的语句是判断 <code class="language-plaintext highlighter-rouge">sscanf</code> 输入的第二个参数是否为 0， 否则就 Explore Bomb， 答案的一半已经呼之欲出了 （就是 <code class="language-plaintext highlighter-rouge">0</code>）。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">40103</span><span class="n">a</span><span class="o">:</span><span class="w">	</span><span class="n">ba</span><span class="w"> </span><span class="m">0</span><span class="n">e</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0xe</span><span class="p">,</span><span class="o">%edx
  40103f:	be 00 00 00 00       	mov    $0x0,%</span><span class="n">esi</span><span class="w">
  </span><span class="m">401044</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">7</span><span class="n">c</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">mov</span><span class="w">    </span><span class="mh">0x8</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">edi</span><span class="w">
  </span><span class="m">401048</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">81</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">400</span><span class="n">fce</span><span class="w"> </span><span class="o">&lt;</span><span class="n">func4</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">40104</span><span class="n">d</span><span class="o">:</span><span class="w">	</span><span class="m">85</span><span class="w"> </span><span class="n">c0</span><span class="w">                	</span><span class="n">test</span><span class="w">   </span><span class="o">%eax,%</span><span class="n">eax</span><span class="w">
  </span><span class="m">40104</span><span class="n">f</span><span class="o">:</span><span class="w">	</span><span class="m">75</span><span class="w"> </span><span class="m">07</span><span class="w">                	</span><span class="n">jne</span><span class="w">    </span><span class="m">401058</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_4</span><span class="m">+0</span><span class="n">x4c</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">401051</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="m">7</span><span class="n">c</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">0</span><span class="n">c</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">cmpl</span><span class="w">   </span><span class="o">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0xc</span><span class="p">(</span><span class="o">%rsp)
  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;
  401058:	e8 dd 03 00 00       	call   40143a &lt;explode_bomb&gt;
  40105d:	48 83 c4 18          	add    $0x18,%</span><span class="n">rsp</span><span class="w">
  </span><span class="m">401061</span><span class="o">:</span><span class="w">	</span><span class="n">c3</span><span class="w">                   	</span><span class="n">ret</span><span class="w">    
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">func4</code> 的内容还是有些神奇， 跟着流程走下来， 比如我当前设定的第一个数是 1， 0x400fdb 时 <code class="language-plaintext highlighter-rouge">%ecx</code> 的值从 0xe， 会递归更新到 0x6， 0x2， 而相应的 <code class="language-plaintext highlighter-rouge">%eax</code> 的值在 <code class="language-plaintext highlighter-rouge">sar    %eax</code> 语句执行后会变更为 0x7, 0x3, 0x1， 这个 <code class="language-plaintext highlighter-rouge">sar</code> 的指令的使用我没见过， 但看流程应该是将 <code class="language-plaintext highlighter-rouge">%eax</code> 向右移动一位， 因为 <code class="language-plaintext highlighter-rouge">%ecx</code> 的值是更新到 <code class="language-plaintext highlighter-rouge">%eax</code> 中的， 正好和上述结果对应。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">400</span><span class="n">fe2</span><span class="o">:</span><span class="w">	</span><span class="m">39</span><span class="w"> </span><span class="n">f9</span><span class="w">                	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%edi,%</span><span class="n">ecx</span><span class="w">
  </span><span class="m">400</span><span class="n">fe4</span><span class="o">:</span><span class="w">	</span><span class="m">7</span><span class="n">e</span><span class="w"> </span><span class="m">0</span><span class="n">c</span><span class="w">                	</span><span class="n">jle</span><span class="w">    </span><span class="m">400</span><span class="n">ff2</span><span class="w"> </span><span class="o">&lt;</span><span class="n">func4</span><span class="m">+0</span><span class="n">x24</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">fe6</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">51</span><span class="w"> </span><span class="n">ff</span><span class="w">             	</span><span class="n">lea</span><span class="w">    </span><span class="m">-0</span><span class="n">x1</span><span class="p">(</span><span class="o">%rcx),%</span><span class="n">edx</span><span class="w">
  </span><span class="m">400</span><span class="n">fe9</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="n">e0</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">400</span><span class="n">fce</span><span class="w"> </span><span class="o">&lt;</span><span class="n">func4</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>这个函数还处理了了第一个输入的数更大的情况， 但范围是也是被限制在了 0 到 7 之内。 也就是说， 根据 <code class="language-plaintext highlighter-rouge">func4</code> 的处理逻辑， 只有输入的值为 <code class="language-plaintext highlighter-rouge">1 0</code>， <code class="language-plaintext highlighter-rouge">3 0</code>， <code class="language-plaintext highlighter-rouge">7 0</code> 才能返回 <code class="language-plaintext highlighter-rouge">%eax</code> 为 0。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">400</span><span class="n">ff7</span><span class="o">:</span><span class="w">	</span><span class="m">39</span><span class="w"> </span><span class="n">f9</span><span class="w">                	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%edi,%</span><span class="n">ecx</span><span class="w">
  </span><span class="m">400</span><span class="n">ff9</span><span class="o">:</span><span class="w">	</span><span class="m">7</span><span class="n">d</span><span class="w"> </span><span class="m">0</span><span class="n">c</span><span class="w">                	</span><span class="n">jge</span><span class="w">    </span><span class="m">401007</span><span class="w"> </span><span class="o">&lt;</span><span class="n">func4</span><span class="m">+0</span><span class="n">x39</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">400</span><span class="n">ffb</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">71</span><span class="w"> </span><span class="m">01</span><span class="w">             	</span><span class="n">lea</span><span class="w">    </span><span class="mh">0x1</span><span class="p">(</span><span class="o">%rcx),%</span><span class="n">esi</span><span class="w">
  </span><span class="m">400</span><span class="n">ffe</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="n">cb</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">ff</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">400</span><span class="n">fce</span><span class="w"> </span><span class="o">&lt;</span><span class="n">func4</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<h2 id="5-phase5">5. Phase5</h2>

<p><code class="language-plaintext highlighter-rouge">phase_5</code> 开头有这么一段， 在堆栈的特定位置存入了一个 Canary 值以监测程序是否有被栈溢出问题修改内容。 对程序主体没有影响。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">40106</span><span class="n">a</span><span class="o">:</span><span class="w">	</span><span class="m">64</span><span class="w"> </span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">25</span><span class="w"> </span><span class="m">28</span><span class="w"> </span><span class="m">00</span><span class="w"> 	</span><span class="n">mov</span><span class="w">    </span><span class="o">%fs:0x28,%</span><span class="n">rax</span><span class="w">
  </span><span class="m">401071</span><span class="o">:</span><span class="w">	</span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> 
  </span><span class="m">401073</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">89</span><span class="w"> </span><span class="m">44</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">18</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">%rax,0x18(%</span><span class="n">rsp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>而后则是判断输入的字符串的长度， 如果长度相等则会跳转到 0x4010d2 处， 清空 <code class="language-plaintext highlighter-rouge">%rax</code> 中的内容跳到实际的函数主体的入口地址 0x40108b。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">401078</span><span class="o">:</span><span class="w">	</span><span class="m">31</span><span class="w"> </span><span class="n">c0</span><span class="w">                	</span><span class="n">xor</span><span class="w">    </span><span class="o">%eax,%</span><span class="n">eax</span><span class="w"> </span><span class="c1"># clear %eax</span><span class="w">
  </span><span class="m">40107</span><span class="n">a</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">9</span><span class="n">c</span><span class="w"> </span><span class="m">02</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40131</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="n">string_length</span><span class="o">&gt;</span><span class="w"> </span><span class="c1"># check length equals to 6 or not</span><span class="w">
  </span><span class="m">40107</span><span class="n">f</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="n">f8</span><span class="w"> </span><span class="m">06</span><span class="w">             	</span><span class="n">cmp</span><span class="w">    </span><span class="o">$</span><span class="mh">0x6</span><span class="p">,</span><span class="o">%eax
  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;
  401084:	e8 b1 03 00 00       	call   40143a &lt;explode_bomb&gt;
  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;
  40108b:	0f b6 0c 03          	movzbl (%</span><span class="n">rbx</span><span class="p">,</span><span class="o">%rax,1),%</span><span class="n">ecx</span><span class="w">
</span></code></pre></div></div>

<p>这个主体部分的逻辑也非常清晰， <code class="language-plaintext highlighter-rouge">%rbx</code> 中的内容是我们输入的字符串的起始地址， 由 <code class="language-plaintext highlighter-rouge">%rdi</code> 赋值得到。 可以看到这段代码是根据 <code class="language-plaintext highlighter-rouge">%rax</code> 的值进行循环逐个取输入字符串中的单个字符， 处理传入的 <code class="language-plaintext highlighter-rouge">char input[6]</code>， 并将 <code class="language-plaintext highlighter-rouge">input[n]</code> 的低 4 位作为 offset 取以 <code class="language-plaintext highlighter-rouge">0x4024b0</code> 为首地址的字符串中的字符。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">40108</span><span class="n">b</span><span class="o">:</span><span class="w">	</span><span class="m">0</span><span class="n">f</span><span class="w"> </span><span class="n">b6</span><span class="w"> </span><span class="m">0</span><span class="n">c</span><span class="w"> </span><span class="m">03</span><span class="w">          	</span><span class="n">movzbl</span><span class="w"> </span><span class="p">(</span><span class="o">%rbx,%</span><span class="n">rax</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="o">%ecx
  40108f:	88 0c 24             	mov    %</span><span class="n">cl</span><span class="p">,(</span><span class="o">%rsp)
  401092:	48 8b 14 24          	mov    (%</span><span class="n">rsp</span><span class="p">),</span><span class="o">%rdx
  401096:	83 e2 0f             	and    $0xf,%</span><span class="n">edx</span><span class="w">
  </span><span class="m">401099</span><span class="o">:</span><span class="w">	</span><span class="m">0</span><span class="n">f</span><span class="w"> </span><span class="n">b6</span><span class="w"> </span><span class="m">92</span><span class="w"> </span><span class="n">b0</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">40</span><span class="w"> </span><span class="m">00</span><span class="w"> 	</span><span class="n">movzbl</span><span class="w"> </span><span class="mh">0x4024b0</span><span class="p">(</span><span class="o">%rdx),%</span><span class="n">edx</span><span class="w">
  </span><span class="m">4010</span><span class="n">a0</span><span class="o">:</span><span class="w">	</span><span class="m">88</span><span class="w"> </span><span class="m">54</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">10</span><span class="w">          	</span><span class="n">mov</span><span class="w">    </span><span class="o">%dl,0x10(%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%rax,1)
  4010a4:	48 83 c0 01          	add    $0x1,%</span><span class="n">rax</span><span class="w">
  </span><span class="m">4010</span><span class="n">a8</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">f8</span><span class="w"> </span><span class="m">06</span><span class="w">          	</span><span class="n">cmp</span><span class="w">    </span><span class="o">$</span><span class="mh">0x6</span><span class="p">,</span><span class="o">%</span><span class="n">rax</span><span class="w">
  </span><span class="m">4010</span><span class="n">ac</span><span class="o">:</span><span class="w">	</span><span class="m">75</span><span class="w"> </span><span class="n">dd</span><span class="w">                	</span><span class="n">jne</span><span class="w">    </span><span class="m">40108</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_5</span><span class="m">+0</span><span class="n">x29</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>上述循环结束后就会进入下列代码中， 又见到老朋友 <code class="language-plaintext highlighter-rouge">strings_not_equal</code> 了， 我们很清楚 <code class="language-plaintext highlighter-rouge">0x40245e</code> 地址存储着最后的字符组合， 打印出来是 <code class="language-plaintext highlighter-rouge">flyers</code>。 因此根据这个值我们就可以进行逆推了， 打印 <code class="language-plaintext highlighter-rouge">0x4024b0</code> 为首地址的字符串可以得到 <code class="language-plaintext highlighter-rouge">maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code>， 我们可以找到 <code class="language-plaintext highlighter-rouge">flyers</code> 的每个对应的位置而得出 offset 的值为 <code class="language-plaintext highlighter-rouge">9, 15, 14, 5, 6, 7</code>。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">4010</span><span class="n">ae</span><span class="o">:</span><span class="w">	</span><span class="n">c6</span><span class="w"> </span><span class="m">44</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">movb</span><span class="w">   </span><span class="o">$</span><span class="mh">0x0</span><span class="p">,</span><span class="mh">0x16</span><span class="p">(</span><span class="o">%rsp)
  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%</span><span class="n">esi</span><span class="w">
  </span><span class="m">4010</span><span class="n">b8</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">7</span><span class="n">c</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">10</span><span class="w">       	</span><span class="n">lea</span><span class="w">    </span><span class="mh">0x10</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">rdi</span><span class="w">
  </span><span class="m">4010</span><span class="n">bd</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">76</span><span class="w"> </span><span class="m">02</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">401338</span><span class="w"> </span><span class="o">&lt;</span><span class="n">strings_not_equal</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">4010</span><span class="n">c2</span><span class="o">:</span><span class="w">	</span><span class="m">85</span><span class="w"> </span><span class="n">c0</span><span class="w">                	</span><span class="n">test</span><span class="w">   </span><span class="o">%eax,%</span><span class="n">eax</span><span class="w">
</span></code></pre></div></div>

<p>反正最后是要的低 4 位， 根据 <a href="https://www.asciitable.com/">ASCII Table</a> 的内容， 答案可以有很多种， <code class="language-plaintext highlighter-rouge">9?&gt;567</code>(0x30 + offset)，  <code class="language-plaintext highlighter-rouge">IONEFG</code>(0x40 + offset) 等等。</p>

<h2 id="6-phase6">6. Phase6</h2>

<p>代码好长， 建议看一点就在旁边做点注释。</p>

<p>最开始先是读取了 6 个数， 之后就进入下列代码中， 这段代码的目的就是判断这 6 个数是两两不同的， 否则会 Explore Bomb， 流程可以跟着代码中的注释走一遍留个印象。 另外要求这几个数在减 1 之后要小于等于 5， 因而可以肯定的是这几个数的范围是 1 到 6， 就是目前顺序还不确定。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">40110</span><span class="n">e</span><span class="o">:</span><span class="w">	</span><span class="m">41</span><span class="w"> </span><span class="n">bc</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">    	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%r12d
401114:	4c 89 ed             	mov    %</span><span class="n">r13</span><span class="p">,</span><span class="o">%rbp
401117:	41 8b 45 00          	mov    0x0(%</span><span class="n">r13</span><span class="p">),</span><span class="o">%eax
40111b:	83 e8 01             	sub    $0x1,%</span><span class="n">eax</span><span class="w">
</span><span class="m">40111</span><span class="n">e</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="n">f8</span><span class="w"> </span><span class="m">05</span><span class="w">             	</span><span class="n">cmp</span><span class="w">    </span><span class="o">$</span><span class="mh">0x5</span><span class="p">,</span><span class="o">%eax
401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt; # %</span><span class="n">eax</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="n">explore</span><span class="w"> </span><span class="n">bomb</span><span class="p">,</span><span class="w"> </span><span class="n">means</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="n">need</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="m">6</span><span class="w">
</span><span class="m">401123</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="m">12</span><span class="w"> </span><span class="m">03</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
</span><span class="m">401128</span><span class="o">:</span><span class="w">	</span><span class="m">41</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="m">01</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%r12d # %</span><span class="n">r12d</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">indicating</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="n">numbers</span><span class="w">
</span><span class="m">40112</span><span class="n">c</span><span class="o">:</span><span class="w">	</span><span class="m">41</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">fc</span><span class="w"> </span><span class="m">06</span><span class="w">          	</span><span class="n">cmp</span><span class="w">    </span><span class="o">$</span><span class="mh">0x6</span><span class="p">,</span><span class="o">%r12d
401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;
401132:	44 89 e3             	mov    %</span><span class="n">r12d</span><span class="p">,</span><span class="o">%ebx
401135:	48 63 c3             	movslq %</span><span class="n">ebx</span><span class="p">,</span><span class="o">%rax
401138:	8b 04 84             	mov    (%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%rax,4),%</span><span class="n">eax</span><span class="w"> </span><span class="c1"># int type, get input six number iteratively</span><span class="w">
</span><span class="m">40113</span><span class="n">b</span><span class="o">:</span><span class="w">	</span><span class="m">39</span><span class="w"> </span><span class="m">45</span><span class="w"> </span><span class="m">00</span><span class="w">             	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%eax,0x0(%</span><span class="n">rbp</span><span class="p">)</span><span class="w"> </span><span class="c1"># compare current value to first value for 5 times, needs to be not equal</span><span class="w">
</span><span class="m">40113</span><span class="n">e</span><span class="o">:</span><span class="w">	</span><span class="m">75</span><span class="w"> </span><span class="m">05</span><span class="w">                	</span><span class="n">jne</span><span class="w">    </span><span class="m">401145</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">x51</span><span class="o">&gt;</span><span class="w">
</span><span class="m">401140</span><span class="o">:</span><span class="w">	</span><span class="n">e8</span><span class="w"> </span><span class="n">f5</span><span class="w"> </span><span class="m">02</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">call</span><span class="w">   </span><span class="m">40143</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="n">explode_bomb</span><span class="o">&gt;</span><span class="w">
</span><span class="m">401145</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="m">01</span><span class="w">             	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%ebx
401148:	83 fb 05             	cmp    $0x5,%</span><span class="n">ebx</span><span class="w">
</span><span class="m">40114</span><span class="n">b</span><span class="o">:</span><span class="w">	</span><span class="m">7</span><span class="n">e</span><span class="w"> </span><span class="n">e8</span><span class="w">                	</span><span class="n">jle</span><span class="w">    </span><span class="m">401135</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">x41</span><span class="o">&gt;</span><span class="w">
</span><span class="m">40114</span><span class="n">d</span><span class="o">:</span><span class="w">	</span><span class="m">49</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c5</span><span class="w"> </span><span class="m">04</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="n">r13</span><span class="w"> </span><span class="c1"># move to next number</span><span class="w">
</span></code></pre></div></div>

<p>这段的逻辑比较清晰， 对每一项储存在堆栈上的数 <code class="language-plaintext highlighter-rouge">num[i]</code> 做 <code class="language-plaintext highlighter-rouge">num[i] = 7 - num[i]</code> 的操作， 对每个数进行重新赋值。 跳出循环的条件是 <code class="language-plaintext highlighter-rouge">%rsi</code> 中存储的地址和 <code class="language-plaintext highlighter-rouge">%rax</code> 一致。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">401153</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">74</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">18</span><span class="w">       	</span><span class="n">lea</span><span class="w">    </span><span class="mh">0x18</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">rsi</span><span class="w"> </span><span class="c1"># 0x18 = 24, move the last number address into %rsi</span><span class="w">
  </span><span class="m">401158</span><span class="o">:</span><span class="w">	</span><span class="m">4</span><span class="n">c</span><span class="w"> </span><span class="m">89</span><span class="w"> </span><span class="n">f0</span><span class="w">             	</span><span class="n">mov</span><span class="w">    </span><span class="o">%r14,%</span><span class="n">rax</span><span class="w"> </span><span class="c1"># initial stack base address</span><span class="w">
  </span><span class="m">40115</span><span class="n">b</span><span class="o">:</span><span class="w">	</span><span class="n">b9</span><span class="w"> </span><span class="m">07</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x7</span><span class="p">,</span><span class="o">%ecx
  401160:	89 ca                	mov    %</span><span class="n">ecx</span><span class="p">,</span><span class="o">%edx # iteratively use 7 to subtract the stored number and replace the orignal ones
  401162:	2b 10                	sub    (%</span><span class="n">rax</span><span class="p">),</span><span class="o">%edx
  401164:	89 10                	mov    %</span><span class="n">edx</span><span class="p">,(</span><span class="o">%rax)
  401166:	48 83 c0 04          	add    $0x4,%</span><span class="n">rax</span><span class="w">
  </span><span class="m">40116</span><span class="n">a</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">39</span><span class="w"> </span><span class="n">f0</span><span class="w">             	</span><span class="n">cmp</span><span class="w">    </span><span class="o">%rsi,%</span><span class="n">rax</span><span class="w">
  </span><span class="m">40116</span><span class="n">d</span><span class="o">:</span><span class="w">	</span><span class="m">75</span><span class="w"> </span><span class="n">f1</span><span class="w">                	</span><span class="n">jne</span><span class="w">    </span><span class="m">401160</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">x6c</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>做好上述工作后进入如下代码段， 本质上做了一个映射， 将 0x6032d0 起始， 以 0x10 为步长的地址中， 按照所给数据的顺序将对应的地址填入堆栈中。 例如 0x603320 对应数字 6， 数字 6 在第一个位置， 则 <code class="language-plaintext highlighter-rouge">0x20(%rsp)</code> 存储着 <code class="language-plaintext highlighter-rouge">0x603320</code> 这个地址。</p>
<blockquote>
  <p>通过调试可以清楚 <code class="language-plaintext highlighter-rouge">*(0x6032d0 + 8)=0x6032f0</code>， 即在这一过程中存在着链表结构， 当前链表节点中存储着下一个链表节点的地址。</p>
</blockquote>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">40116</span><span class="n">f</span><span class="o">:</span><span class="w">	</span><span class="n">be</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%esi
  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;
  401176:	48 8b 52 08          	mov    0x8(%</span><span class="n">rdx</span><span class="p">),</span><span class="o">%rdx # update %</span><span class="n">rdx</span><span class="w"> </span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="mh">0x6032d0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">8</span><span class="n">n</span><span class="err">，</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="mh">0x6032d0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">8</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x6032d0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w">
  </span><span class="m">40117</span><span class="n">a</span><span class="o">:</span><span class="w">	</span><span class="m">83</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="m">01</span><span class="w">             	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%eax
  40117d:	39 c8                	cmp    %</span><span class="n">ecx</span><span class="p">,</span><span class="o">%eax
  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;
  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;
  401183:	ba d0 32 60 00       	mov    $0x6032d0,%</span><span class="n">edx</span><span class="w">
  </span><span class="m">401188</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">89</span><span class="w"> </span><span class="m">54</span><span class="w"> </span><span class="m">74</span><span class="w"> </span><span class="m">20</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">%rdx,0x20(%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%rsi,2) # store the address into stack, whose address start from 20(%</span><span class="n">rsp</span><span class="p">)</span><span class="w">
  </span><span class="m">40118</span><span class="n">d</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c6</span><span class="w"> </span><span class="m">04</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%rsi
  401191:	48 83 fe 18          	cmp    $0x18,%</span><span class="n">rsi</span><span class="w">
  </span><span class="m">401195</span><span class="o">:</span><span class="w">	</span><span class="m">74</span><span class="w"> </span><span class="m">14</span><span class="w">                	</span><span class="n">je</span><span class="w">     </span><span class="m">4011</span><span class="n">ab</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">xb7</span><span class="o">&gt;</span><span class="w">
  </span><span class="m">401197</span><span class="o">:</span><span class="w">	</span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">0</span><span class="n">c</span><span class="w"> </span><span class="m">34</span><span class="w">             	</span><span class="n">mov</span><span class="w">    </span><span class="p">(</span><span class="o">%rsp,%</span><span class="n">rsi</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="o">%ecx # entry
  40119a:	83 f9 01             	cmp    $0x1,%</span><span class="n">ecx</span><span class="w">
  </span><span class="m">40119</span><span class="n">d</span><span class="o">:</span><span class="w">	</span><span class="m">7</span><span class="n">e</span><span class="w"> </span><span class="n">e4</span><span class="w">                	</span><span class="n">jle</span><span class="w">    </span><span class="m">401183</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">x8f</span><span class="o">&gt;</span><span class="w"> </span><span class="c1"># less or equal to 1 (you know must be 1)</span><span class="w">
  </span><span class="m">40119</span><span class="n">f</span><span class="o">:</span><span class="w">	</span><span class="n">b8</span><span class="w"> </span><span class="m">01</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%eax
  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%</span><span class="n">edx</span><span class="w">
  </span><span class="m">4011</span><span class="n">a9</span><span class="o">:</span><span class="w">	</span><span class="n">eb</span><span class="w"> </span><span class="n">cb</span><span class="w">                	</span><span class="n">jmp</span><span class="w">    </span><span class="m">401176</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">x82</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>上述代码完成工作后， <code class="language-plaintext highlighter-rouge">%rbx</code> 首先被赋值为排序后的栈顶 <code class="language-plaintext highlighter-rouge">0x20(%rsp)</code> 内容， <code class="language-plaintext highlighter-rouge">%rax</code> 则被赋值为排序后的栈顶偏移 8 byte 的地址 <code class="language-plaintext highlighter-rouge">0x28(%rsp)</code>， 而 <code class="language-plaintext highlighter-rouge">%rsi</code> 则填入栈底地址 <code class="language-plaintext highlighter-rouge">0x50(%rsp)</code>。</p>

<p>如下代码所要做的工作， 将堆栈栈顶 <code class="language-plaintext highlighter-rouge">0x20(%rsp)</code> 中的内容（该内容为一段地址）取出放在 <code class="language-plaintext highlighter-rouge">%rcx</code>， 并将相邻的 <code class="language-plaintext highlighter-rouge">0x28(%rsp)</code> 中的地址也取出放到 <code class="language-plaintext highlighter-rouge">%rdx</code>， 根据之前的描述 <code class="language-plaintext highlighter-rouge">*(0x6032d0 + 8n) = 0x6032d0 + 0x10 * n</code> 成立， 即表明这是一种链式结构， <code class="language-plaintext highlighter-rouge">mov    %rdx,0x8(%rcx)</code> 就是将当前栈中的链表节点存储的下一个链表节点地址， 更新为存储在堆栈相邻位置的链表节点的地址。 最后一个链表节点中则存一个空地址。 这样按照堆栈的存储顺序， 栈顶成了头节点， 栈底成了尾节点。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">4011</span><span class="n">ab</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">5</span><span class="n">c</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">20</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="mh">0x20</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">rbx</span><span class="w">
  </span><span class="m">4011</span><span class="n">b0</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">44</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">28</span><span class="w">       	</span><span class="n">lea</span><span class="w">    </span><span class="mh">0x28</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">rax</span><span class="w">
  </span><span class="m">4011</span><span class="n">b5</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">d</span><span class="w"> </span><span class="m">74</span><span class="w"> </span><span class="m">24</span><span class="w"> </span><span class="m">50</span><span class="w">       	</span><span class="n">lea</span><span class="w">    </span><span class="mh">0x50</span><span class="p">(</span><span class="o">%rsp),%</span><span class="n">rsi</span><span class="w">
  </span><span class="m">4011</span><span class="n">ba</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">89</span><span class="w"> </span><span class="n">d9</span><span class="w">             	</span><span class="n">mov</span><span class="w">    </span><span class="o">%rbx,%</span><span class="n">rcx</span><span class="w">
  </span><span class="m">4011</span><span class="n">bd</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">8</span><span class="n">b</span><span class="w"> </span><span class="m">10</span><span class="w">             	</span><span class="n">mov</span><span class="w">    </span><span class="p">(</span><span class="o">%rax),%</span><span class="n">rdx</span><span class="w">
  </span><span class="m">4011</span><span class="n">c0</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">89</span><span class="w"> </span><span class="m">51</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">mov</span><span class="w">    </span><span class="o">%rdx,0x8(%</span><span class="n">rcx</span><span class="p">)</span><span class="w">
  </span><span class="m">4011</span><span class="n">c4</span><span class="o">:</span><span class="w">	</span><span class="m">48</span><span class="w"> </span><span class="m">83</span><span class="w"> </span><span class="n">c0</span><span class="w"> </span><span class="m">08</span><span class="w">          	</span><span class="n">add</span><span class="w">    </span><span class="o">$</span><span class="mh">0x8</span><span class="p">,</span><span class="o">%rax
  4011c8:	48 39 f0             	cmp    %</span><span class="n">rsi</span><span class="p">,</span><span class="o">%rax
  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;
  4011cd:	48 89 d1             	mov    %</span><span class="n">rdx</span><span class="p">,</span><span class="o">%rcx
  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;
  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%</span><span class="n">rdx</span><span class="p">)</span><span class="w">
  </span><span class="m">4011</span><span class="n">d9</span><span class="o">:</span><span class="w">	</span><span class="m">00</span><span class="w"> 
</span></code></pre></div></div>

<p>最后就是遍历堆栈啦， <code class="language-plaintext highlighter-rouge">%rbx</code> 的值没有修改过仍然指向栈顶位置 <code class="language-plaintext highlighter-rouge">0x20(%rsp)</code>， 接着判断当前位置取到的值是否会比栈中下一个元素取得的值大或相等， 不满足则会 Explore Bomb。</p>

<div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="m">4011</span><span class="n">da</span><span class="o">:</span><span class="w">	</span><span class="n">bd</span><span class="w"> </span><span class="m">05</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">       	</span><span class="n">mov</span><span class="w">    </span><span class="o">$</span><span class="mh">0x5</span><span class="p">,</span><span class="o">%ebp
  4011df:	48 8b 43 08          	mov    0x8(%</span><span class="n">rbx</span><span class="p">),</span><span class="o">%rax
  4011e3:	8b 00                	mov    (%</span><span class="n">rax</span><span class="p">),</span><span class="o">%eax
  4011e5:	39 03                	cmp    %</span><span class="n">eax</span><span class="p">,(</span><span class="o">%rbx)
  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;
  4011e9:	e8 4c 02 00 00       	call   40143a &lt;explode_bomb&gt;
  4011ee:	48 8b 5b 08          	mov    0x8(%</span><span class="n">rbx</span><span class="p">),</span><span class="o">%rbx
  4011f2:	83 ed 01             	sub    $0x1,%</span><span class="n">ebp</span><span class="w">
  </span><span class="m">4011</span><span class="n">f5</span><span class="o">:</span><span class="w">	</span><span class="m">75</span><span class="w"> </span><span class="n">e8</span><span class="w">                	</span><span class="n">jne</span><span class="w">    </span><span class="m">4011</span><span class="n">df</span><span class="w"> </span><span class="o">&lt;</span><span class="n">phase_6</span><span class="m">+0</span><span class="n">xeb</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>我们知道存储值的地址分别为 <code class="language-plaintext highlighter-rouge">0x6032d0</code>， <code class="language-plaintext highlighter-rouge">0x6032e0</code>， <code class="language-plaintext highlighter-rouge">0x6032f0</code>， <code class="language-plaintext highlighter-rouge">0x603300</code>， <code class="language-plaintext highlighter-rouge">0x603310</code>， <code class="language-plaintext highlighter-rouge">0x603320</code>， 不妨都打印出来排个序， 顺序从大到小排序。 根据排序后的关系， 以及前述映射， 可以得到我们的输入为 <code class="language-plaintext highlighter-rouge">3 4 5 6 1 2</code>。 但是， 在此之前有一个 <code class="language-plaintext highlighter-rouge">7 - num[i]</code> 的转换， 因此正确答案应当为 <code class="language-plaintext highlighter-rouge">4 3 2 1 6 5</code>。</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">924 -&gt;</span><span class="w"> </span>0x6032f0 -&gt; 3
<span class="gp">691 -&gt;</span><span class="w"> </span>0x603300 -&gt; 4
<span class="gp">477 -&gt;</span><span class="w"> </span>0x603310 -&gt; 5
<span class="gp">443 -&gt;</span><span class="w"> </span>0x603320 -&gt; 6
<span class="gp">332 -&gt;</span><span class="w"> </span>0x6032d0 -&gt; 1
<span class="gp">168 -&gt;</span><span class="w"> </span>0x6032e0 -&gt; 2
</code></pre></div></div>

<h2 id="7-写在最后">7. 写在最后</h2>

<p>通关之后的情况如下， 最后一个 <code class="language-plaintext highlighter-rouge">phase_6</code> 有些坑人， 还有一层转换容易忘掉， 做的时候怎么都过不去人都懵了， 后来看了 <a href="https://github.com/Exely/CSAPP-Labs/blob/master/notes/bomb.md">Exely - Bomb</a> 做的 Bomb 的笔记才意识到这个问题。 GDB 仅用过 VSCode 的图形化版本， 对 CLI 版本非常不熟悉， 这次实验也算是锻炼了一下这方面的能力。</p>
<blockquote>
  <p>CSAPP 拿来复习基础知识是真的很不错！</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># result.txt</span>
Border relations with Canada have never been better.
1 2 4 8 16 32
7 327
1 0
IONEFG
4 3 2 1 6 5
</code></pre></div></div>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Congratulations! You've defused the bomb!
</span></code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="CSAPP" /><summary type="html"><![CDATA[Computer Systems: A Programmer’s Perspective, 3/E (CS:APP3e) – Bomb Lab， 实现源码可从 HangX-Ma/csapp: 02-bomblab 获取。]]></summary></entry><entry><title type="html">Vim Plugin: YouCompleteMe 旧版本装配</title><link href="https://hangx-ma.github.io/2023/12/06/YCM-config.html" rel="alternate" type="text/html" title="Vim Plugin: YouCompleteMe 旧版本装配" /><published>2023-12-06T00:00:00+08:00</published><updated>2023-12-06T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/12/06/YCM-config</id><content type="html" xml:base="https://hangx-ma.github.io/2023/12/06/YCM-config.html"><![CDATA[<p>YouCompleteMe 是 Vim 比较常用的一款代码补全插件， 在 neovim 盛行的当下， 这类补全插件也逐渐淡出了大众视野， 但也有一些场合使用 YouCompleteMe 也有自己的一席之地。</p>

<p>为了开发环境的稳定性， 有些服务器的操作系统版本比较低， 甚至在 CMake 这类编译工具的版本也比较低。 为了尽可能减少对低版本系统环境的更改， 我尝试尽可能通过手动编译配置的方式完成在这类开发环境的 Vim 配置。</p>
<blockquote>
  <p>其实无奈的是自己没有账户的 <code class="language-plaintext highlighter-rouge">sudo</code> 权限。</p>
</blockquote>

<p>我选择的是 YCM 的 <code class="language-plaintext highlighter-rouge">legacy-c++11</code> 版本， 还未升级到 C++17 因而对编译工具的要求会低一些。 官方在 Ubuntu 20.04 上做过适配是比较成功的， 但我在 Ubuntu 18.04 上也成功安装了。 我的装配环境如下：</p>

<ul>
  <li>Ubuntu 18.04</li>
  <li>GCC v7.5.0</li>
  <li>CMake v3.10.2</li>
  <li>Python 3.6.7</li>
  <li>Vim 8.2.1258</li>
  <li>YCM legacy-c++11</li>
</ul>

<blockquote>
  <p>如果是最新的 YCM 版本， GCC 至少需要 v8.x， Clang 版本需要 v7.x。</p>
</blockquote>

<h2 id="0-编译环境">0. 编译环境</h2>

<p>CMake 和 build-essential 最好能用 apt 的方式装好了， 不然得手动去装会很麻烦。 另外， 如果需要自己手动编译安装 python3， 那 <code class="language-plaintext highlighter-rouge">python3-dev</code> 也不是特别必要。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Ubuntu 16.04 and later</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>build-essential cmake python3-dev
</code></pre></div></div>

<h2 id="1-python36-安装">1. Python3.6 安装</h2>

<p>安装 Python3.6 的原因是这台服务器的 python3 在安装的时候没有支持 <code class="language-plaintext highlighter-rouge">--enable-shared</code> 或 <code class="language-plaintext highlighter-rouge">--enable-framework</code>， 另外也是本着不破坏原有编译环境的想法。 最重要的是 <strong>Requirements</strong> 明确声明了 python 3.6 runtime。</p>

<p>到 python 官网的 <a href="https://www.python.org/ftp/python/3.6.7/">https://www.python.org/ftp/python/3.6.7/</a> 找一找 <code class="language-plaintext highlighter-rouge">Python-3.6.7.tar.xz</code>， 用 wget 直接下载到自己的 home 目录下。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar </span>zxvf Python-3.6.7.tgz
<span class="nb">cd </span>Python-3.6.7
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.local/python3.6 <span class="nt">--enable-optimizations</span> <span class="nt">--enable-shared</span>
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>然后更改 <code class="language-plaintext highlighter-rouge">.bashrc</code> 增添相关的执行文件目录就行了。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .bashrc</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="k">${</span><span class="nv">PATH</span><span class="k">}</span>:<span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.local/python3.6/bin
</code></pre></div></div>

<h2 id="2-llvm-安装">2. LLVM 安装</h2>

<p>方便一些直接用 LLVM + Clang 的组合包， 省去了自己编译的麻烦事儿。 我选择的版本是 LLVM 12.0.0， 因为后续在安装 YCM 的时候 10.0.0 版本已经太老给删掉了， 找个稍微接近的新版本是可以平替的。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># wget 不成功直接去 github 的 release 版面下载</span>
wget https://github.com/ycm-core/llvm/releases/download/12.0.0/clang+llvm-12.0.0-x86_64-unknown-linux-gnu.tar.xz
xz <span class="nt">-d</span> clang+llvm-12.0.0-x86_64-unknown-linux-gnu.tar.xz
<span class="nb">tar</span> <span class="nt">-xvf</span> clang+llvm-12.0.0-x86_64-unknown-linux-gnu.tar
</code></pre></div></div>

<p>解压完之后就配置 <code class="language-plaintext highlighter-rouge">.bashrc</code> 即可， 记得 <code class="language-plaintext highlighter-rouge">source ~/.bashrc</code>。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .bashrc</span>
<span class="nb">export </span><span class="nv">LLVM_PATH</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/clang+llvm-12.0.0-x86_64-unknown-linux-gnu/bin
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="k">${</span><span class="nv">PATH</span><span class="k">}</span>:LLVM_PATH
</code></pre></div></div>

<h2 id="3-vim-安装">3. Vim 安装</h2>

<p>一般来说 Ubuntu 18.04 默认安装的 Vim 版本是 8.0 的， 而 YCM 的要求是 <strong>Vim v8.1.2269 huge build, compiled with Python 3.6 support</strong>， 所以不妨手动装个稍微高点的版本。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://codeload.github.com/vim/vim/tar.gz/v8.2.1258
<span class="nb">mv </span>v8.2.1258  vim-v8.2.1258.tar.gz
<span class="nb">tar</span> <span class="nt">-xvzf</span> vim-v8.2.1258.tar.gz
<span class="nb">cd </span>vim-8.2.1258
./configure <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.local<span class="se">\</span>
        <span class="nt">--with-python3-command</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.local/python3.6/bin/python3<span class="se">\</span>
        <span class="nt">--enable-python3interp</span><span class="o">=</span>dynamic<span class="se">\</span>
        <span class="nt">--enable-cscope</span><span class="se">\</span>
        <span class="nt">--with-features</span><span class="o">=</span>huge<span class="se">\</span>
        <span class="nt">--enable-multibyte</span><span class="se">\</span>
        <span class="nt">--with-python3-config-dir</span><span class="o">=</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.local/python3.6/lib/python3.6/config-3.6m-x86_64-linux-gnu/<span class="se">\</span>
        <span class="nt">--enable-largefile</span><span class="se">\</span>
        <span class="nt">--enable-fail-if-missing</span>
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
make <span class="nb">install</span>
</code></pre></div></div>

<p>这里需要注意的是 <code class="language-plaintext highlighter-rouge">--enable-python3interp=dynamic</code> 选项， 很多编译 vim 都跟你说要填 <code class="language-plaintext highlighter-rouge">yes</code>， 然后用 <code class="language-plaintext highlighter-rouge">LDFLAG='-rdynamic'</code> 开启相关的 dynamic 编译， 我试过并没有起作用。 安装完之后可以用如下代码检查是否有 <code class="language-plaintext highlighter-rouge">+python3/dyn</code> 的支持用以确认安装是否成功。 <code class="language-plaintext highlighter-rouge">python3/dyn</code> 也是 YCM 的安装要求之一， 并且仅支持 python3 版本， YCM 已经抛弃了对 python2 的支持， 除非切换到更老旧的对 python2 支持的 branch。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim <span class="nt">--version</span> | <span class="nb">grep </span>python3
</code></pre></div></div>

<h2 id="4-youcompleteme-安装">4. YouCompleteMe 安装</h2>

<ul>
  <li><strong>Vundle</strong></li>
</ul>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
</code></pre></div></div>

<ul>
  <li>直接拷贝 <code class="language-plaintext highlighter-rouge">legacy-c++11</code> 分支版本的 YCM</li>
</ul>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/.vim/bundle
git clone <span class="nt">--branch</span> legacy-c++11 https://github.com/ycm-core/YouCompleteMe.git
<span class="nb">cd</span> ~/.vim/bundle/YouCompleteMe
git submodule update <span class="nt">--init</span> <span class="nt">--recursive</span>
</code></pre></div></div>

<p>到这一步应该会说在 <code class="language-plaintext highlighter-rouge">~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/watchdog_deps/pathtools/docs/source/_themes</code> 下载不成功， 因为人家已经删掉了。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/watchdog_deps/pathtools/docs/source/
<span class="nb">rmdir </span>_themes
git clone https://github.com/pallets/flask-sphinx-themes.git _themes
checkout THE_VERSION_THAT_ASKS
</code></pre></div></div>

<ul>
  <li>安装 YCM 的 Clang Completer</li>
</ul>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/.vim/bundle/YouCompleteMe
python3.6 install.py <span class="nt">--clangd-completer</span>
</code></pre></div></div>

<p>然后又会遇到麻烦了， 说 clangd-10.0.0 这个包的 checksum 不对， 实际上是这个下载地址已经寄了， 那没办法了， 自己手动下载一个吧， 对于这个老的 YCM 版本下载的位置是相应的 <code class="language-plaintext highlighter-rouge">third_party</code> 的包的 <code class="language-plaintext highlighter-rouge">cache</code> 目录， 并不是传闻的 <code class="language-plaintext highlighter-rouge">clang_archives</code>。 为了和前述的 LLVM 的版本匹配我们也装 clangd 12.0.0 版本， 但需要改一下 <code class="language-plaintext highlighter-rouge">build.py</code> 的一些内容。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># cd ~/.vim/bundle/YouCompleteMe/third_party/ycmd/build.py
</span><span class="n">CLANGD_VERSION</span> <span class="o">=</span> <span class="sh">'</span><span class="s">12.0.0</span><span class="sh">'</span>
<span class="bp">...</span>

<span class="k">def</span> <span class="nf">DownloadClangd</span><span class="p">(</span> <span class="n">printer</span> <span class="p">):</span>
  <span class="n">CLANGD_DIR</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span> <span class="n">DIR_OF_THIRD_PARTY</span><span class="p">,</span> <span class="sh">'</span><span class="s">clangd</span><span class="sh">'</span><span class="p">,</span> <span class="p">)</span>
  <span class="n">CLANGD_CACHE_DIR</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span> <span class="n">CLANGD_DIR</span><span class="p">,</span> <span class="sh">'</span><span class="s">cache</span><span class="sh">'</span> <span class="p">)</span>
  <span class="n">CLANGD_OUTPUT_DIR</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span> <span class="n">CLANGD_DIR</span><span class="p">,</span> <span class="sh">'</span><span class="s">output</span><span class="sh">'</span> <span class="p">)</span>

  <span class="n">target</span> <span class="o">=</span> <span class="nc">GetClangdTarget</span><span class="p">()</span>
  <span class="n">target_name</span><span class="p">,</span> <span class="n">check_sum</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span> <span class="ow">not</span> <span class="n">IS_64BIT</span> <span class="p">]</span>
  <span class="n">target_name</span> <span class="o">=</span> <span class="n">target_name</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span> <span class="n">version</span> <span class="o">=</span> <span class="n">CLANGD_VERSION</span> <span class="p">)</span>
  <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">{}.tar.bz2</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span> <span class="n">target_name</span> <span class="p">)</span>
  <span class="n">download_url</span> <span class="o">=</span> <span class="sh">'</span><span class="s">https://github.com/ycm-core/llvm/releases?q={}/{}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span> <span class="n">CLANGD_VERSION</span><span class="p">,</span> <span class="n">file_name</span> <span class="p">)</span>

  <span class="n">file_name</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span> <span class="n">CLANGD_CACHE_DIR</span><span class="p">,</span> <span class="n">file_name</span> <span class="p">)</span>

  <span class="nc">MakeCleanDirectory</span><span class="p">(</span> <span class="n">CLANGD_OUTPUT_DIR</span> <span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">.</span><span class="nf">exists</span><span class="p">(</span> <span class="n">CLANGD_CACHE_DIR</span> <span class="p">):</span>
    <span class="n">os</span><span class="p">.</span><span class="nf">makedirs</span><span class="p">(</span> <span class="n">CLANGD_CACHE_DIR</span> <span class="p">)</span>
<span class="c1">#  elif p.exists( file_name ) and not CheckFileIntegrity( file_name, check_sum ):
#    printer( 'Cached Clangd archive does not match checksum. Removing...' )
#    os.remove( file_name )
</span>    <span class="bp">...</span>
</code></pre></div></div>

<p>这里我改掉了 <code class="language-plaintext highlighter-rouge">CLANGD_VERSION</code> 以及下载的文件地址和文件名， 另外注释掉了 Checksum 的检查。 一般来说这样也是能下载成功了， 要是还不行就手动给它整完。</p>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clangd/cache
wget https://github.com/ycm-core/llvm/releases/download/12.0.0/clangd-12.0.0-x86_64-unknown-linux-gnu.tar.bz2
</code></pre></div></div>

<h2 id="5-vimrc-配置">5. .vimrc 配置</h2>

<ul>
  <li>拷贝一下 YCM 的配置文件</li>
</ul>

<div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> ~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py ~/.vim
</code></pre></div></div>

<ul>
  <li>在 home 目录下创建 <code class="language-plaintext highlighter-rouge">.vimrc</code> 文件向其中写入以下内容， 关掉 vim 重启之后应该就自动帮你装好了 Vundle 和 YouCompleteMe， 或者用 vim 命令 <code class="language-plaintext highlighter-rouge">:PluginInstall</code> 手动安装一下。</li>
</ul>

<div class="language-vimscript copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">" Vundle</span>
<span class="k">set</span> <span class="nb">nocompatible</span>        " be iMproved<span class="p">,</span> required
<span class="k">filetype</span> off            " required

<span class="c">" set the runtime path to include Vundle and initialize</span>
<span class="k">set</span> <span class="nb">rtp</span><span class="p">+=~</span><span class="sr">/.vim/</span>bundle/Vundle<span class="p">.</span><span class="k">vim</span>
<span class="k">call</span> vundle#begin<span class="p">()</span>
<span class="c">" alternatively, pass a path where Vundle should install plugins</span>
<span class="c">"call vundle#begin('~/some/path/here')</span>

<span class="c">" let Vundle manage Vundle, required</span>
Plugin <span class="s1">'VundleVim/Vundle.vim'</span>
Plugin <span class="s1">'ycm-core/YouCompleteMe'</span>

<span class="c">" All of your Plugins must be added before the following line</span>
<span class="k">call</span> vundle#end<span class="p">()</span>            " required
<span class="k">filetype</span> plugin <span class="nb">indent</span> <span class="k">on</span>    " required

<span class="k">let</span> <span class="nv">g:syntastic_python_python_exec</span> <span class="p">=</span> <span class="s1">'${HOME}/.local/python3.6/bin/python3'</span>·
<span class="k">let</span> <span class="nv">g:ycm_server_python_interpreter</span><span class="p">=</span><span class="s1">'${HOME}/.local/python3.6/bin/python3'</span>
<span class="k">let</span> <span class="nv">g:ycm_python_sys_path</span> <span class="p">=</span> <span class="s1">'${HOME}/.local/python3.6/lib/python3.6'</span>
<span class="k">let</span> <span class="nv">g:ycm_global_ycm_extra_conf</span><span class="p">=</span><span class="s1">'~/.vim/.ycm_extra_conf.py'</span>
</code></pre></div></div>

<div class="premonition note"> <div class="header"> <i class="fas fa-sticky-note" style="color: #87d8f2;"></i> <div class="title"> 关于 YCM 的配置 </div> </div> <div class="content"> <p>喜欢折腾的同学肯定不想装完 YCM 就完事儿了， 把它调教成一键趁手的工具才是我们安装这个插件的初心， 这里推荐几篇还不错的配置文档供大家参阅。 我自己也配置了一份精简版的， 可参阅 <a href="https://github.com/HangX-Ma/dotfiles/blob/main/vim/.vimrc">HangX-Ma/dotfiles: vim/.vimrc</a>.</p>

<ul>
  <li><a href="https://cloud.tencent.com/developer/article/1745640">手把手教你配置linux下C++开发工具</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/33046090">知乎 - 韦易笑 YouCompleteMe 中容易忽略的配置</a></li>
  <li><a href="http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/">FengHao - Vim 自动补全插件 YouCompleteMe 安装与配置</a></li>
</ul>



 </div> </div>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="neovim" /><summary type="html"><![CDATA[记录 Vim 补全插件 YouCompleteMe C++11 老旧版本的安装与配置， 适用 Clang Completer]]></summary></entry><entry><title type="html">CMU15-445 Fa23: PROJECT2 - EXTENDIBLE HASH INDEX</title><link href="https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2.html" rel="alternate" type="text/html" title="CMU15-445 Fa23: PROJECT2 - EXTENDIBLE HASH INDEX" /><published>2023-11-28T00:00:00+08:00</published><updated>2023-11-28T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/11/28/cmu15445-fa23-p2.html"><![CDATA[<h2 id="1-理解-extendible-hash">1. 理解 Extendible Hash</h2>

<ul>
  <li><a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">Extendible Hashing (Dynamic approach to DBMS)</a></li>
  <li><a href="http://www.cs.emory.edu/~cheung/Courses/554/Syllabus/3-index/extensible-hashing-new1.html">Emory University: Extensible Hashing</a></li>
</ul>

<div class="premonition note"> <div class="header"> <i class="fas fa-sticky-note" style="color: #87d8f2;"></i> <div class="title"> note </div> </div> <div class="content"> <p>后续有空整理一下贴上自己写的测例， 有需要可留言给个邮箱。</p>



 </div> </div>
<h2 id="2-task1---readwrite-page-guards">2. task#1 - Read/Write Page Guards</h2>

<p><code class="language-plaintext highlighter-rouge">Page Guard</code> 的作用是实现一个基于 C++ 的 RAII(Resource Acquisition Is Initialization) 机制的 Page 管理类， 这个类能够通过析构或手动 <code class="language-plaintext highlighter-rouge">Drop</code> UnpinPage 并释放相应的 RLock 或者 WLock， 能够避免后续 Extendible Hash Index 实现时由于人为对读写锁的使用失误以及忘记 UnpinPage 导致 BufferPoolManager 的页管理出错。</p>

<h3 id="21-task1-实现细节提示">2.1 task#1 实现细节提示</h3>

<p>Project Specification 特地将这几个函数的实现放在一起是有其道理的， <code class="language-plaintext highlighter-rouge">BasicPageGuard</code> 删除了拷贝构造和拷贝赋值， 需要实现移动构造和移动赋值以及其析构函数。 这里会需要较多的代码的复用， 尤其是 <code class="language-plaintext highlighter-rouge">Drop</code> 函数。</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PageGuard(PageGuard &amp;&amp;that)</code>: Move constructor.</p>

    <blockquote>
      <p>对于 Basic 版本直接对 <code class="language-plaintext highlighter-rouge">page_</code>， <code class="language-plaintext highlighter-rouge">bpm_</code>， <code class="language-plaintext highlighter-rouge">is_dirty</code> 进行赋值， 出于习惯将右值 <code class="language-plaintext highlighter-rouge">that</code> 中的指针都置为 <code class="language-plaintext highlighter-rouge">nullptr</code>。 而 Upgrade 版本则可方便地通过 <code class="language-plaintext highlighter-rouge">std::move</code> 赋值 <code class="language-plaintext highlighter-rouge">guard_</code>。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">operator=(PageGuard &amp;&amp;that)</code>: Move operator.</p>

    <blockquote>
      <p>这里需要注意两点： 1. <code class="language-plaintext highlighter-rouge">that</code> 是否为自身； 2. 如果当前的 <code class="language-plaintext highlighter-rouge">guard_.page_</code> 或 <code class="language-plaintext highlighter-rouge">page_</code> 非 <code class="language-plaintext highlighter-rouge">nullptr</code>， 需要先 <code class="language-plaintext highlighter-rouge">Drop</code> 已存储在当前 PageGuard 中的 Page。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Drop()</code>: Unpin and/or unlatch.</p>

    <blockquote>
      <p>对 Basic 版本， 在 Page 有值的情况下需要调用 <code class="language-plaintext highlighter-rouge">UnpinPage</code> 进行资源释放。 而对于 Upgrade 版本则需要释放相应的读写锁并调用 Basic 的 <code class="language-plaintext highlighter-rouge">Drop</code>。 之前擅作主张添加了一个标志位表示是否已经调用过 <code class="language-plaintext highlighter-rouge">Drop</code>， 想要以此避免后续手动调用 <code class="language-plaintext highlighter-rouge">Drop</code> 函数可能出现的重复调用， 但实际上原有的对 page 指针的判断已经足够。 添加这个标志位反而引起 P3 的 shell 报错 deadlock。</p>
    </blockquote>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">~PageGuard()</code>: Destructor.</p>

    <blockquote>
      <p>直接调用 <code class="language-plaintext highlighter-rouge">Drop</code> 就行啦！</p>
    </blockquote>
  </li>
</ul>

<p>至于下面这两个函数则让我面目狰狞， 给的注释说的非常隐晦， 要保证在 Upgrade 的过程中 Page 不被 Evict， 又说 BasicPageGuard 在调用这个函数后会 invalid。 具体细节参考下一小节的 <a href="#pageguardtestbpmtest">PageGuardTest.BPMTest</a> 调试。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UpgradeRead()</code>: Upgrade to a ReadPageGuard</li>
  <li><code class="language-plaintext highlighter-rouge">UpgradeWrite()</code>: Upgrade to a WritePageGuard</li>
</ul>

<p>而下面这四个函数也是清晰的， 对有 Read 和 Write 需求的就相应的给上读/写锁， 但这里考虑到 WritePageGuard 可能会被更改， 我个人认为需要在 Fetch 的同时将相应的 Page 设置为 <em><strong>dirty</strong></em>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FetchPageBasic(page_id_t page_id)</code></li>
  <li><code class="language-plaintext highlighter-rouge">FetchPageRead(page_id_t page_id)</code></li>
  <li><code class="language-plaintext highlighter-rouge">FetchPageWrite(page_id_t page_id)</code></li>
  <li><code class="language-plaintext highlighter-rouge">NewPageGuarded(page_id_t *page_id)</code></li>
</ul>

<h3 id="22-task1-的调试与解析">2.2 task#1 的调试与解析</h3>

<h4 id="pageguardtestbpmtest">PageGuardTest.BPMTest</h4>

<p>Gradescope 中的 <strong>PageGuardTest.BPMTest</strong> 报错如下:</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">/autograder/source/bustub/test/storage/grading_page_guard_test.cpp:222: Failure
Expected equality of these values:
  2
</span><span class="gp">  page1copy-&gt;</span>GetPinCount<span class="o">()</span>
<span class="go">    Which is: 3
</span></code></pre></div></div>

<p>我自己模仿所给范例写了一些本地的测试都是通过的， 唯一感觉有些不确定的是 <code class="language-plaintext highlighter-rouge">BasicPageGuard::UpgradeRead()</code> 和 <code class="language-plaintext highlighter-rouge">BasicPageGuard::UpgradeWrite()</code> 这两个函数， 对于他们的实现细节我不是很清楚。 为了确定 Bug， 我用了 <code class="language-plaintext highlighter-rouge">LOG_DEBUG(...)</code> 打印所有与 <strong>pinCount</strong> 变更相关的信息， 再次提交 Gradescope 后得到了这样的输出：</p>

<div class="language-terminal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">2023-11-27 08:49:55 [buffer_pool_manager.cpp:210:NewPageGuarded] DEBUG - new basic page guard
2023-11-27 08:49:55 [buffer_pool_manager.cpp:61:NewPage] DEBUG - Create new page, page_id 0, pinCount [1]
2023-11-27 08:49:55 [buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 0 from buffer, pinCount from [1] to [2]
2023-11-27 08:49:55 [page_guard.cpp:23:Drop] DEBUG - page_id 0, pinCount from [2] to [1]
2023-11-27 08:49:55 [buffer_pool_manager.cpp:186:FetchPageBasic] DEBUG - fetch basic page
2023-11-27 08:49:55 [buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 0 from buffer, pinCount from [1] to [2]
2023-11-27 08:49:55 [page_guard.cpp:23:Drop] DEBUG - page_id 0, pinCount from [2] to [1]
2023-11-27 08:49:55 [buffer_pool_manager.cpp:210:NewPageGuarded] DEBUG - new basic page guard
2023-11-27 08:49:55 [buffer_pool_manager.cpp:61:NewPage] DEBUG - Create new page, page_id 1, pinCount [1]
2023-11-27 08:49:55 [buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 1 from buffer, pinCount from [1] to [2]
2023-11-27 08:49:55 [buffer_pool_manager.cpp:192:FetchPageRead] DEBUG - fetch read page
2023-11-27 08:49:55 [buffer_pool_manager.cpp:79:FetchPage] DEBUG - fetch page_id 1 from buffer, pinCount from [2] to [3]
2023-11-27 08:49:55 [page_guard.cpp:58:UpgradeRead] DEBUG - Upgrade BasicPageGuard to ReadPageGuard, page_id 1, pinCount from [2] to [3]
/autograder/source/bustub/test/storage/grading_page_guard_test.cpp:222: Failure
Expected equality of these values:
  2
</span><span class="gp">  page1copy-&gt;</span>GetPinCount<span class="o">()</span>
<span class="go">    Which is: 3

2023-11-27 08:49:55 [page_guard.cpp:99:~ReadPageGuard] DEBUG - ReadPageGuard deconstructor Drop
2023-11-27 08:49:55 [page_guard.cpp:86:Drop] DEBUG - read page guard is dropped.
2023-11-27 08:49:55 [page_guard.cpp:23:Drop] DEBUG - page_id 1, pinCount from [3] to [2]
2023-11-27 08:49:55 [page_guard.cpp:50:~BasicPageGuard] DEBUG - BasicPageGuard deconstructor Drop
2023-11-27 08:49:55 [page_guard.cpp:23:Drop] DEBUG - page_id 1, pinCount from [2] to [1]
</span></code></pre></div></div>

<p>可以看到错误就发生在 <code class="language-plaintext highlighter-rouge">BasicPageGuard</code> 转为 <code class="language-plaintext highlighter-rouge">ReadPageGuard</code> 的过程中， 按照我之前的理解， 理应 Upgrade 应当增加一次对相应的 Page 的访问， 所以最开始的代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeRead</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ReadPageGuard</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageRead</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但按照所给测例的输出， <code class="language-plaintext highlighter-rouge">BasicPageGuard</code> 应当在 Upgrade 之后释放原有的资源， 这意味着 <code class="language-plaintext highlighter-rouge">BasicPageGuard</code> 在 Upgrade 之后无法再通过 Upgrade 返回一个 <code class="language-plaintext highlighter-rouge">Read/WritePageGuard</code>， 在 Upgrade 完成后需要手动调用 <code class="language-plaintext highlighter-rouge">BasicPageGuard::Drop()</code> 释放原有的资源， 当然这个猜想在所给代码注释中得到了印证：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  * The protected page is not evicted from the buffer pool during the upgrade,
  * and the basic page guard should be made invalid after calling this function.
  */</span>
</code></pre></div></div>

<p>至于为什么用 <code class="language-plaintext highlighter-rouge">FetchPageRead</code> 而不是直接返回一个全新的 <code class="language-plaintext highlighter-rouge">ReadPageGuard</code>， 主要是考虑到在 Upgrade 过程中会 <strong>Drop</strong> 原有的 <strong>Basic Guard</strong>， 而 Upgrade 需要保证这个 Page 不会被缓存池的 LRU-K 算法 Evict， 那需要保证这个 Page 处于一个 Pin 的状态。 Fetch 可以增加一次 <code class="language-plaintext highlighter-rouge">pinCount</code>, 可以与 <code class="language-plaintext highlighter-rouge">Drop</code> 中调用的 <code class="language-plaintext highlighter-rouge">UnpinPage</code> 导致 <code class="language-plaintext highlighter-rouge">pinCount</code> 的一次减少抵消。</p>

<p>后续提交通过了 <strong>BMPTest</strong> 证明了我的猜想。</p>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// reference code</span>
<span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeRead</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ReadPageGuard</span> <span class="p">{</span>
  <span class="n">ReadPageGuard</span> <span class="n">read_guard</span> <span class="o">=</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageRead</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
  <span class="n">Drop</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">read_guard</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">BasicPageGuard</span><span class="o">::</span><span class="n">UpgradeWrite</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">WritePageGuard</span> <span class="p">{</span>
  <span class="n">WritePageGuard</span> <span class="n">write_guard</span> <span class="o">=</span> <span class="n">bpm_</span><span class="o">-&gt;</span><span class="n">FetchPageWrite</span><span class="p">(</span><span class="n">page_</span><span class="o">-&gt;</span><span class="n">GetPageId</span><span class="p">());</span>
  <span class="n">Drop</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">write_guard</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-task2---extendible-hash-table-pages">3. task#2 - Extendible Hash Table Pages</h2>

<p>相较往年 23Fall 版本增加了 Header Page， 但整体思路应当是一致的， 需要注意的是我们不能更改任何 private 和 public 域中的函数和变量， 在每个头文件的顶部说明规定了这些 Page 的结构和大小。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Header page format:
<span class="p">  ---------------------------------------------------</span>
 | DirectoryPageIds(2048) | MaxDepth (4) | Free(2044)
<span class="p">  ---------------------------------------------------
</span>
 Directory page format:
<span class="p">  --------------------------------------------------------------------------------------</span>
 | MaxDepth (4) | GlobalDepth (4) | LocalDepths (512) | BucketPageIds(2048) | Free(1528)
<span class="p">  --------------------------------------------------------------------------------------
</span>
 Bucket page format:
<span class="p">  ----------------------------------------------------------------------------</span>
 | METADATA | KEY(1) + VALUE(1) | KEY(2) + VALUE(2) | ... | KEY(n) + VALUE(n)
<span class="p">  ----------------------------------------------------------------------------
</span>
 Metadata format (size in byte, 8 bytes in total):
<span class="p">  --------------------------------</span>
 | CurrentSize (4) | MaxSize (4)
<span class="p">  --------------------------------
</span></code></pre></div></div>

<blockquote>
  <p>这里我偷偷改了 <code class="language-plaintext highlighter-rouge">GetDirectoryPageId</code> 的返回类型， 不然和 <code class="language-plaintext highlighter-rouge">directory_page_ids_</code> 数组的类型不统一。</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">ExtendibleHTableHeaderPage</span><span class="o">::</span><span class="n">GetDirectoryPageId</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">directory_idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">page_id_t</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="31-task2-实现细节提示">3.1 task#2 实现细节提示</h3>

<h4 id="hash-table-header-page">Hash Table Header Page</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Init</code></strong>： 需要将 <code class="language-plaintext highlighter-rouge">directory_page_ids_</code> 数组中的 page_id 都初始化为 <code class="language-plaintext highlighter-rouge">INVALID_PAGE_ID</code>， <code class="language-plaintext highlighter-rouge">max_depth</code> 是有它的上限的。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HashToDirectoryIndex</code></strong>： 就比较阴险了， 对于 header 而言， 要获取 directory 的索引值， 是通过 32 位 Hash 的 MSB 实现的。 设想 <code class="language-plaintext highlighter-rouge">max_depth</code> 为零， 32 位 Hash 右移 32 位仍是其本身。 因而需要特殊处理 <code class="language-plaintext highlighter-rouge">max_depth</code> 为零的情况， 应返回一个 0 值。</li>
</ul>

<h4 id="hash-table-directory-page">Hash Table Directory Page</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Init</code></strong>： 同样需要初始化 <code class="language-plaintext highlighter-rouge">local_depth_</code> 以及 <code class="language-plaintext highlighter-rouge">bucket_page_id_</code> 这两个数组。 <code class="language-plaintext highlighter-rouge">local_depth_</code> 以及 <code class="language-plaintext highlighter-rouge">global_depth_</code> 需要初始化为 0。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HashToBucketIndex</code></strong>： 有个比较巧妙的办法就是直接用 hash 值对 <code class="language-plaintext highlighter-rouge">Size()</code> 取模， 这和使用 <code class="language-plaintext highlighter-rouge">GetGlobalDepthMask</code> 是一样的。</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">GetSplitImageIndex</code></strong>： 主要得理解 Extendible Hash Index 的 Split 的思路， directory 部分扩大事实上就是左移了一个 global depth， 这导致 directory 数量变为原来的两倍。 例如 <code class="language-plaintext highlighter-rouge">00</code> 会分裂为 <code class="language-plaintext highlighter-rouge">000</code> 和 <code class="language-plaintext highlighter-rouge">100</code> 但二者都指向同一个 bucket。 所以我们只需要得到当前 bucket 并对其 global_depth 位取反， 就能得到镜像的 bucket 的索引值。</p>

    <div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">ExtendibleHTableDirectoryPage</span><span class="o">::</span><span class="n">GetSplitImageIndex</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">bucket_idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint32_t</span> <span class="p">{</span>
  <span class="c1">// Ensure the bucket local depth has increased!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">local_depths_</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">bucket_idx</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">local_depths_</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">IncrGlobalDepth</code></strong>： 结合上个函数的解析， 如果理解了 Extendible Hash Index 的实现思路， 增加 global_depth 要做的就是拷贝一份原有的 buckets， 如 bucket_idx <code class="language-plaintext highlighter-rouge">00</code> 分裂为 <code class="language-plaintext highlighter-rouge">000</code> 和 <code class="language-plaintext highlighter-rouge">100</code>， 把 <code class="language-plaintext highlighter-rouge">00</code> 的内容拷贝一份到 <code class="language-plaintext highlighter-rouge">100</code> 中即可。</p>

    <div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">ExtendibleHTableDirectoryPage</span><span class="o">::</span><span class="n">IncrGlobalDepth</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">global_depth_</span> <span class="o">&lt;</span> <span class="n">HTABLE_DIRECTORY_MAX_DEPTH</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">prev_expansion_num</span> <span class="o">=</span> <span class="n">Size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">prev_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">prev_expansion_num</span><span class="p">;</span> <span class="n">prev_idx</span> <span class="o">&lt;</span> <span class="n">prev_expansion_num</span><span class="p">;</span>
      <span class="n">prev_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">curr_idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">local_depths_</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_depths_</span><span class="p">[</span><span class="n">prev_idx</span><span class="p">];</span>
    <span class="n">bucket_page_ids_</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket_page_ids_</span><span class="p">[</span><span class="n">prev_idx</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">global_depth_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">CanShrink</code></strong>： 检查所有的 bucket 的 local_depth， 如果都比 global depth 要小， 就可以缩小 global_depth。 这个函数在后续 Merge 的时候需要用到。</li>
</ul>

<p>其他的该加加该减减就行， 不用想太多， 就是纯粹的增减！</p>

<h4 id="hash-table-bucket-page">Hash Table Bucket Page</h4>

<p>讲道理开始一点思路没有， 我看到有人在 <a href="https://zhuanlan.zhihu.com/p/664444839">知乎 - zihao 彼方 CMU15-445(2023FALL)-Project#2: Extendible Hash Index</a> 发了篇文章， 里面提到需要对 bucket 中的 <code class="language-plaintext highlighter-rouge">array_</code> 数组全部初始化为一个特殊值 ， <strong>坑爹啊！！！</strong> 这导致我后续花了将近 6 个小时找 <strong>GrowShrinkTest</strong> 的错误。</p>

<p>实际上 bucket 的实现非常简洁， 我后来在看 <code class="language-plaintext highlighter-rouge">PrintBucket</code> 的实现的时候得到了启发， BUSTUB 直接访问的前 <code class="language-plaintext highlighter-rouge">size_</code> 个元素。 说明每次 <code class="language-plaintext highlighter-rouge">Insert</code> 的时候利用 <code class="language-plaintext highlighter-rouge">size_</code> 可以对数组进行尾部插入， 这是因为 <code class="language-plaintext highlighter-rouge">size_</code> 始终指向下一个插入的位置。而每次 <code class="language-plaintext highlighter-rouge">Remove</code> 的时候只用 <code class="language-plaintext highlighter-rouge">size_</code> 指向当前数组的尾部数据 (人话就是 <code class="language-plaintext highlighter-rouge">size_ -= 1</code>)， 让这个尾部数据填充到 <code class="language-plaintext highlighter-rouge">RemoveAt</code> 的那个 bucket_idx 位置即可。</p>

<p>我们无需对数组进行初始化等操作， <code class="language-plaintext highlighter-rouge">size_</code> 表示当前的数据大小可以很好的控制访问权限。</p>

<h3 id="32-task2-的调试与解析">3.2 task#2 的调试与解析</h3>

<h4 id="growshrinktest">GrowShrinkTest</h4>

<p>对 Bucket Page 理解不到位， 重构后能够通过该测例。</p>

<h2 id="4-task3---extendible-hashing-implementation">4. task#3 - Extendible Hashing Implementation</h2>

<p>感觉没必要细说， 但需要写一下踩过的坑以及记录一些实现相关的细节。</p>

<blockquote>
  <p>大家真没辙了参考这位大佬 21 年实现的版本， <a href="https://github.com/epis2048/cmu_15445_2021/tree/ghess/p2-refinement">cmu15-445/2021</a>， 核心与框架都是一致的。</p>
</blockquote>

<h3 id="41-task3-实现细节提示">4.1 task#3 实现细节提示</h3>

<p>这里实现的时候需要考虑 <code class="language-plaintext highlighter-rouge">BasicPageGuard</code>， <code class="language-plaintext highlighter-rouge">ReadPageGuard</code>， <code class="language-plaintext highlighter-rouge">WritePageGuard</code> 的使用场景。 一般来说， 只有需要通过 <code class="language-plaintext highlighter-rouge">NewPageGuarded</code> 获取新 Page 才会用到 <code class="language-plaintext highlighter-rouge">BasicPageGuard</code>， 之后都会通过 Upgrade 函数将这个获取到的 Page 加上读写锁。 使用 PageGuard 原则就是看是否后续操作会产生对数据的更改， 如果不会更改就尽量使用 Read， 并在适当的时候通过 <code class="language-plaintext highlighter-rouge">Drop</code> 函数提前释放相关的读写锁， 以提高并行效率。</p>

<h4 id="migrateentries">MigrateEntries</h4>

<p>我相信很多人看到这个函数是懵的， 这个函数究竟什么作用根本没有提示。 这个函数和 <code class="language-plaintext highlighter-rouge">UpdateDirectoryMapping</code> 函数都是用在 <strong>Split Bucket</strong> 中的。 试想有一个 bucket_idx 为 <code class="language-plaintext highlighter-rouge">00</code> 的 bucket 存储了两个 KV 数据， 在我们增加 global_depth 和 local_depth 之后， 我们需要将 bucket_idx <code class="language-plaintext highlighter-rouge">00</code> 中的数据填充到新的 <code class="language-plaintext highlighter-rouge">000</code>(原 <code class="language-plaintext highlighter-rouge">00</code>) 和 <code class="language-plaintext highlighter-rouge">100</code> 这两个 bucket， 此时就要用到 <code class="language-plaintext highlighter-rouge">MigrateEntries</code> 函数。</p>

<p>首先将原有数据拷贝出来， 这里需要注意的是， 如果使用 <code class="language-plaintext highlighter-rouge">ExtendibleHTableBucketPage&lt;K, V, KC&gt;::EntryAt</code> 函数会有问题， 我们无法对一个 const 引用进行拷贝构造。 解决办法就是单独用 <code class="language-plaintext highlighter-rouge">KeyAt</code> 和 <code class="language-plaintext highlighter-rouge">ValueAt</code>配合 <code class="language-plaintext highlighter-rouge">std::make_pair</code> 构造一个新的 KV。</p>

<blockquote>
  <p>可以自己尝试用 LOG_DEBUG 看看结果， 不出意外的话 <code class="language-plaintext highlighter-rouge">copied</code> 的 KV 应都是 0 值。</p>
</blockquote>

<p>之后根据新的 local_depth 将拷贝的数据按照新的 bucket_idx 插入 old_bucket 或 new_bucket。</p>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">V</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">KC</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">DiskExtendibleHashTable</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;::</span><span class="n">MigrateEntries</span><span class="p">(</span><span class="n">ExtendibleHTableBucketPage</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">old_bucket</span><span class="p">,</span>
                                                       <span class="n">ExtendibleHTableBucketPage</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">new_bucket</span><span class="p">,</span>
                                                       <span class="kt">uint32_t</span> <span class="n">new_bucket_idx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">local_depth_mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Get valid items in old bucket */</span>
  <span class="kt">uint32_t</span> <span class="n">old_bucket_size</span> <span class="o">=</span> <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">copied</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">old_bucket_size</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">old_bucket_size</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">copied</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">KeyAt</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">ValueAt</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="cm">/* reset old bucket */</span>
  <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">(</span><span class="n">bucket_max_size_</span><span class="p">);</span>
  <span class="n">BUSTUB_ASSERT</span><span class="p">(</span><span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"old bucket should be reset"</span><span class="p">);</span>

  <span class="cm">/* Do rehashing */</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">old_bucket_size</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">target_bucket_idx</span> <span class="o">=</span> <span class="n">Hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">local_depth_mask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target_bucket_idx</span> <span class="o">==</span> <span class="n">new_bucket_idx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_bucket</span><span class="o">-&gt;</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">cmp_</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">old_bucket</span><span class="o">-&gt;</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">cmp_</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="updatedirectorymapping">UpdateDirectoryMapping</h4>

<p>这又是做什么？ 可以想象的是， 有时候我们有很多 bucket_idx 指向的是同一个 page_id， 如果不清楚请参考 <a href="#1-理解-extendible-hash">理解-extendible-hash</a> 我们在 Split Bucket 完成后， 需要让原来指向 split_bucket_idx 的那些 buckets 重新分配指向， 要么是 split_bucket_idx， 要么是 image_bucket_idx， 并且都需要设定新的 local_depth。</p>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">V</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">KC</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">DiskExtendibleHashTable</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">KC</span><span class="o">&gt;::</span><span class="n">UpdateDirectoryMapping</span><span class="p">(</span><span class="n">ExtendibleHTableDirectoryPage</span> <span class="o">*</span><span class="n">directory</span><span class="p">,</span>
                                                               <span class="kt">uint32_t</span> <span class="n">new_bucket_idx</span><span class="p">,</span> <span class="n">page_id_t</span> <span class="n">new_bucket_page_id</span><span class="p">,</span>
                                                               <span class="kt">uint32_t</span> <span class="n">new_local_depth</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">local_depth_mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">msb_diff</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">new_local_depth</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">new_bucket_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">msb_diff</span><span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="n">msb_diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetBucketPageId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_bucket_page_id</span><span class="p">);</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetLocalDepth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_local_depth</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">new_bucket_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">directory</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">msb_diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetBucketPageId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_bucket_page_id</span><span class="p">);</span>
    <span class="n">directory</span><span class="o">-&gt;</span><span class="n">SetLocalDepth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_local_depth</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-task2-的调试与解析">4.2 task#2 的调试与解析</h3>

<h4 id="getvalue-和-remove">GetValue 和 Remove</h4>

<p>这两个函数的接口都是 <code class="language-plaintext highlighter-rouge">key</code>， 说明有时候可能这个 <code class="language-plaintext highlighter-rouge">key</code> 是不存在于 BufferPool 的， 我们需要在获取 directory index 的时候就可以判断， 如果 directory_idx 为 <code class="language-plaintext highlighter-rouge">INVALID_PAGE_ID</code> 可以提早返回结果， 因为这个 <code class="language-plaintext highlighter-rouge">key</code> 并不存在。</p>

<p>另外注意 Fall 2023 版本是 unique-key， 不存在一个 key 对应多个值的情况。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">GetValue</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">Transaction</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">Remove</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">Transaction</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="insert">Insert</h4>

<p><code class="language-plaintext highlighter-rouge">Insert</code> 中在 directory 的 page_id 为 <code class="language-plaintext highlighter-rouge">INVALID_PAGE_ID</code> 时调用 <code class="language-plaintext highlighter-rouge">InsertToNewDirectory</code>， 在 <code class="language-plaintext highlighter-rouge">InsertToNewDirectory</code> 中调用 <code class="language-plaintext highlighter-rouge">InsertToNewBucket</code>， 这是这两个函数的使用方式。</p>

<ul>
  <li>如果发现 directory 索引超过了 header 的最大限制， 需要直接返回 false。</li>
  <li>判断当前需要插入的 bucket 的情况， 如果没有满则可以直接调用 bucket 的 Insert 函数， 如果满了则调用 <code class="language-plaintext highlighter-rouge">SplitInsert</code> 函数。</li>
</ul>

<h4 id="splitinsert">SplitInsert</h4>

<p>这个函数不进行任何插入操作， 插入操作仅在 <code class="language-plaintext highlighter-rouge">Insert</code> 中进行， 因而在该函数完成对 global_depth 和 local_depth 的扩容后， 需要再次调用 <code class="language-plaintext highlighter-rouge">Insert</code> 完成数据插入。</p>

<p><strong>需要注意以下几点</strong>：</p>

<ol>
  <li>当前的 bucket_idx 获取的 local_depth 已经与传入的 <code class="language-plaintext highlighter-rouge">directory_max_depth_</code> 相等了， 说明 directory 已经扩容到最大， bucket 也扩容到最多， 无法继续扩容， 直接返回 <code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li>如果上述条件不满足， 说明还可以继续扩容， 如果 local_depth 已经和 global_depth 相等了， 先增加 global_depth。</li>
  <li>增加 local_depth。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">MigrateEntries</code> 以及 <code class="language-plaintext highlighter-rouge">UpdateDirectoryMapping</code>（有两次） 完成扩容。</li>
  <li>重新尝试 <code class="language-plaintext highlighter-rouge">Insert</code>。</li>
</ol>

<h4 id="merge">Merge</h4>

<p>需要注意的是 Recursive Merge， 因为很可能一次 Merge 后还能够接着下一次 Merge 直到最小单位。 由于 Merge 的时候会将当前的 bucket 指向 image bucket 以达到 Merge 的目的， 所以如果要递归进行 Merge， 就要以 image_bucket_idx 和 new_local_depth 生成新的 bucket_idx 进行下次 Merge 的调用。</p>

<p><strong>另外注意 Merge 的几个先后条件</strong>：</p>

<ol>
  <li>local_depth 为 0， 说明已经到达 Merge 的极限了， 直接返回。</li>
  <li>当前的 bucket_idx 得到的 local_depth 和镜像的 image_bucket_idx 得到的 image_local_depth 不一致， 深度不一致则不能 Merge， 也需要直接返回。</li>
  <li>我们需要在 Merge 的过程中对 bucket_idx 再进行一次 <code class="language-plaintext highlighter-rouge">IsEmpty</code> 的判断， 如果非空直接返回。 这是因为在 <code class="language-plaintext highlighter-rouge">Remove</code> 函数中我们判断 bucket 为空后， 释放 latch 的瞬间这个 latch 被 Insert 拿走了， 这个 bucket 可能又被塞入了新的值， 后续 Merge 函数获取到锁的时候就可能看到的是这个新值了。</li>
  <li>删除 bucket_idx 对应的 Page 后要将之前所有指向这个 bucket_idx 存储的 Page 的那些 buckets 重新直线新的 image_bucket 对应的 Page 以及设置新的 local_depth。</li>
  <li>需要循环调用 <code class="language-plaintext highlighter-rouge">CanShrink</code> 缩小 global_depth。</li>
</ol>

<div class="language-cpp copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="cm">/* recursive merge */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">directory_write_page</span><span class="o">-&gt;</span><span class="n">GetGlobalDepth</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">next_bucket_idx</span> <span class="o">=</span> <span class="n">image_bucket_idx</span> <span class="o">&amp;</span> <span class="n">new_local_depth</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">next_image_bucket_idx</span> <span class="o">=</span> <span class="n">directory_write_page</span><span class="o">-&gt;</span><span class="n">GetSplitImageIndex</span><span class="p">(</span><span class="n">next_bucket_idx</span><span class="p">);</span>


    <span class="n">Merge</span><span class="p">(</span><span class="n">directory_idx</span><span class="p">,</span> <span class="n">next_bucket_idx</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
    <span class="n">Merge</span><span class="p">(</span><span class="n">directory_idx</span><span class="p">,</span> <span class="n">next_image_bucket_idx</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="5-task4--concurrency-control">5. task#4  Concurrency Control</h2>

<p>实现的时候给 <code class="language-plaintext highlighter-rouge">Insert</code>， <code class="language-plaintext highlighter-rouge">Remove</code> 以及自定义的一些会更改 directory 或 bucket 的函数都加上了一把 latch， 在 return 或进入另一个函数前释放 latch， 能完美通过测试。</p>

<h2 id="6-写在最后">6. 写在最后</h2>

<p>不枉这一个星期的努力， P2 顺利收官了！</p>

<p>虽然最后成功通过了 P2 的所有测试， 但整个 Project 并没有完全独立完成， 设计上也有参考前述的 2021 年的 Extendible Hash Index 的实现。 除了所给函数没注释导致对其功能的理解上的缺失， 还有阅读 Specification 和代码注释不仔细， 对 Extendible Hash Index 的原理以及概念不熟悉不透彻。 对于 Debug 目前能用的就是 <code class="language-plaintext highlighter-rouge">LOG_DEBUG</code> 以及配置 VSCode 的 CodeLLDB 实现图形化调试， 一旦遇到多线程的情况， 大多只能依赖 <code class="language-plaintext highlighter-rouge">LOG_DEBUG</code>， 可想而知 P4 将是个令人望而生畏的任务。</p>

<div align="center">
    <img src="/norobots/images/2023-11-28-cmu15445-fa23-p2/p2-leaderboard-rank.png" alt="Project2 LeaderBoard Rank, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Project2 LeaderBoard Rank, HangX-Ma</u></font>
</div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cmu15-445" /><summary type="html"><![CDATA[学习 CMU15-445 Fall 2023， 该章与 Extendible Hash Index 相关， 介绍 Extendible Hash 的原理与实施细节]]></summary></entry><entry><title type="html">Cpp-Quiz</title><link href="https://hangx-ma.github.io/2023/11/14/cpp-details.html" rel="alternate" type="text/html" title="Cpp-Quiz" /><published>2023-11-14T00:00:00+08:00</published><updated>2023-11-14T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/11/14/cpp-details</id><content type="html" xml:base="https://hangx-ma.github.io/2023/11/14/cpp-details.html"><![CDATA[<p>Google 搜到了 Knatten 大佬开发的 <a href="https://github.com/knatten/cppquiz">cppquiz</a> 题库， 题库网址是 <a href="http://cppquiz.org">http://cppquiz.org</a>。 很多问题都是依据比较新的 C++17 的标准出的， 短小精悍而且有详细的解析， 很有当时做 Rust Quiz 的感觉， 但这个题库的使用体验可好多了， 能很好考察梳理自己对 C++ 语法以及执行细节的掌握程度！</p>

<blockquote>
  <p>解析的依据是 <a href="https://timsong-cpp.github.io/cppwp/">Working Draft: Programming Languages — C++</a></p>
</blockquote>

<h2 id="question-list">Question List</h2>

<p>不贴源代码， 只记录问题解析中的重点。</p>

<h3 id="question-14"><a href="https://cppquiz.org/quiz/question/14?result=OK&amp;answer=abcBCA&amp;did_answer=Answer">Question 14</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/basic.start.dynamic#4">basic.start.dynamic</a> 做了相关的解释， 对于 <strong>non-local</strong>， <strong>non-inline</strong> 的 <strong>static storage</strong> 变量， 其初始化过程是 dynamic 的， 要么在 <code class="language-plaintext highlighter-rouge">main()</code> 之前， 或者推迟到进入 <code class="language-plaintext highlighter-rouge">main()</code> 函数之后但先于任何在 <code class="language-plaintext highlighter-rouge">main()</code> 函数中的构造函数。 而具备 <strong>static storage</strong> 属性的变量， 如全局变量， 声明为 static 的变量的析构发生在正常变量之后， 且 <strong>先构造的后释放(reverse order)</strong>。</p>

<h3 id="question-16"><a href="https://cppquiz.org/quiz/question/16?result=OK&amp;answer=abBA&amp;did_answer=Answer">Question 16</a></h3>

<p>成员函数的初始化在构造函数之前， 析构函数在任何成员函数析构之前。</p>

<h3 id="question-48"><a href="https://cppquiz.org/quiz/question/48?result=OK&amp;answer=z&amp;did_answer=Answer">Question 48</a></h3>

<p>TODO</p>

<h3 id="question-126"><a href="https://cppquiz.org/quiz/question/126?result=OK&amp;answer=11&amp;did_answer=Answer">Question 126</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.unqual#13">basic.lookup.unqual</a> 做了相关解释， 其本意表示 class 或 struct 中的静态成员变量会优先使用定义在该 class 或 struct 中的静态成员函数， 即便外部有同名的函数存在。</p>

<h3 id="question-312"><a href="https://cppquiz.org/quiz/question/312?result=CE&amp;answer=&amp;did_answer=Answer">Question 312</a></h3>

<p><a href="https://timsong-cpp.github.io/cppwp/n4659/class.access.base#1">class.access.base</a>，<a href="https://timsong-cpp.github.io/cppwp/n4659/class.access.base#2">class.access.base</a> 介绍了继承相关的内容。 class 和 struct 在多继承中的默认继承类型和 class 以及 struct 默认成员函数和成员变量类型是一致的， class 中默认的都是 <code class="language-plaintext highlighter-rouge">private</code> 而 struct 都默认 <code class="language-plaintext highlighter-rouge">public</code>。</p>]]></content><author><name>HangX-Ma</name></author><category term="C++" /><summary type="html"><![CDATA[做 C++ Quiz 遇到一些有意思的语法细节记录，钻牛角尖的那种。]]></summary></entry><entry><title type="html">cs61b Proj3-BYoW</title><link href="https://hangx-ma.github.io/2023/10/21/cs61b-proj3.html" rel="alternate" type="text/html" title="cs61b Proj3-BYoW" /><published>2023-10-21T00:00:00+08:00</published><updated>2023-10-21T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/10/21/cs61b-proj3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/10/21/cs61b-proj3.html"><![CDATA[<p><strong>Github Repo:</strong> <a href="https://github.com/HangX-Ma/cs61b-sp21">https://github.com/HangX-Ma/cs61b-sp21</a></p>

<p>在实现这个项目之前自己先尝试摸索着做了一些工作， 构思了一下工程结构， 但确实由于项目经验较少， 很难做到 Josh Hug 课上说的 Strategic Programming， 刚开始就对 <code class="language-plaintext highlighter-rouge">interactWithInputString</code> 的字符串处理部分重构了多次。 既然没办法避免 Tactical Programming， 我的想法是先看看别人实现的文件架构以及构建框架， 这样能够有个比较清晰的实现脉络。</p>

<p>我参考的是 <a href="https://github.com/YinY1/CS61B-sp21">YinY1</a> 的 Proj3 实现， 但我认为具体的细节是需要自己去思考的， 文件结构的设计已经给了我足够的启发。 这篇文章就详细介绍一下地图的生成， 这块难度比较高， Phase2 关于游戏交互的我就完成了基础功能没啥好说的。</p>

<blockquote>
  <p>最近有些焦虑， 感受到末尾保研和前位保研的差距了， 同届的同学已经参加过之江实验室的项目， 以及百度 Paddle 的夏令营， 现在在延续他的夏令营开源项目担任助教。 而对自己来说， 规划的一整个研一时间和半个研二时间是拿来补基础课程的， 毕竟平时还有实验室任务。 不过人家确实也很认真， 每天留到快 23:00 才回宿舍。 且不说了， 之后还有一门数据库的课程要补上。</p>
</blockquote>

<h2 id="1-文件目录">1. 文件目录</h2>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>byow
  ├─Core
  │  │  Engine.java
  │  │  Main.java
  │  │  Pair.java
  │  │  Point.java
  │  │  Property.java
  │  │  RandomUtils.java
  │  │  Utils.java
  │  │  World.java
  │  │
  │  ├─Avatar
  │  │      Avatar.java
  │  │      Tofu.java
  │  │
  │  ├─HUD
  │  │      Frame.java
  │  │
  │  └─Maps
  │          Road.java
  │          Room.java
  │          Wall.java
  │
  ├─InputDemo
  │      DemoInputSource.java
  │      InputSource.java
  │      KeyboardInputSource.java
  │      RandomInputSource.java
  │      StringInputDevice.java
  │
  ├─lab12
  │      BoringWorldDemo.java
  │      HexWorld.java
  │      project3prep.md
  │      RandomWorldDemo.java
  │
  ├─lab13
  │      MemoryGame.java
  │
  ├─Networking
  │      BYOWClient.java
  │      BYOWServer.java
  │
  └─TileEngine
          TERenderer.java
          TETile.java
          Tileset.java
</code></pre></div></div>

<h2 id="2-phase1-world-generation">2. Phase1: World Generation</h2>

<p>Phase1 要求生成随机的地图， 地图要求由不同大小的 Rooms 以及联通这些 Room 的通道构成。 一般的实现办法就是生成多个 Rooms 的区块， 然后将这些 Rooms 通过 Path 联通起来， 而如何生成 Path 真的非常考验人。 我自己尝试过用类似 Hexagon World 中扫描的方式， 让每个 Rooms 紧贴着生成， 也尝试过生成 Rooms 后用生成迷宫的方式去生成 Path， 但这些方法都不能很好的做到和 Josh Hug 给出的样例类似。</p>

<p>花了一天的时间考虑算法， 闭门造车真的不行， 有幸刷到了这样一篇知乎 <a href="https://zhuanlan.zhihu.com/p/30724817">【游必有方】一种 RogueLike 地图生成算法</a> 作者对原文 <a href="https://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/">Rooms and Mazes: A Procedural Dungeon Generator</a> 进行了简化和翻译。 第一次了解到这种 2D 场景的类似的游戏被称为 <strong>RogueLike Game</strong>， 文章介绍的内容和 Proj3 所介绍的需求非常类似。</p>

<p>生成地图的主要步骤：</p>

<ul>
  <li>在给定大小的地图区域内随机生成一些房间；</li>
  <li>将除房间以外的区域用随机生成的迷宫填充；</li>
  <li>将所有房间和迷宫通过少数节点连接起来；</li>
  <li>删除不必要的迷宫死胡同，降低地图复杂度。</li>
</ul>

<p>对我来说链接迷宫和房间并降低地图复杂度这块是最为困惑的和不解的， 迫不及待想要了解作者的巧妙构思了。 其实这块自然而然会想到课上介绍的 Union 的概念， 尤其是一提到联通路径的时候， 就会想到 Prim 和 Kruskal 这两个最小生成树算法。 <a href="https://www.cnblogs.com/shiroe/p/15506909.html">【UE4 C++】迷宫生成——DFS、Prim、Kruskal算法实现</a> 这篇文章介绍了几种算法在生成 Maze 时的区别， 当时我自己实现了 kruskal 的迷宫， 但效果和课程所给的相去甚远。</p>

<h3 id="21-创建独立的-room-areas">2.1 创建独立的 Room Areas</h3>

<p>按照文章所述， 算法需要保证地图的宽高尺寸， 以及房间尺寸， 房间所在位置均为奇数， 这样能与生成的 Maze 路径对齐， 保证 Maze 所经过的路径与 Rooms 仅有一个 tile 的距离， 这样能够保证后续连接 Rooms 和 Maze Path 的时候的便利。</p>

<p>至于创建随机且不重叠的 Room Areas 的思路也很粗暴， 随机生成 Room 的尺寸以及位置， 判断生成区块是否与已存在的 Room 存在重叠， 迭代一定次数即可。 对于一个有限地图而言， 没必要迭代太多次， 越往后重叠的概率越大反倒浪费资源。 这里需要注意的一个点是, Room 之间是需要留有一个 tile 的空隙的。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/room_and_maze.png" alt="Rooms and maze, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Room and maze, HangX-Ma</u></font>
</div>

<p>对于 Rooms 生成我用了 <strong>Inflation</strong> 的思想， 既然需要留有一个 Tile 的间隔， 不如在生成 Rooms 时将原点位置向左下移动一个单位， 将宽和高都扩大两个单位， 想象一下一个 5x5 的格子， 膨胀为 7x7 的格子。</p>

<h3 id="22-剩余空间填充迷宫墙">2.2 剩余空间填充迷宫墙</h3>

<p>原作者基于 <a href="http://www.odedwelgreen.com/karcero/">Karcero</a> 尝试生成迷宫墙以及前述的房间， 发现 <strong>Room then maze</strong> 的方式会更加高效， 其实道理也非常明晰， 先生成 Maze 并进行裁剪留下的空间用以生成 Rooms 其实极大限制了 Rooms 的生成区域， 而 maze 的填充仅占用 1 个 tile， 相比较动辄几十个 pixel 开销的 Rooms 区域而言， 其发生碰撞的概率会小很多。</p>

<p>作者生成 Maze 的方式用了图形学中常用的 <strong>Flood Fill</strong> 算法（似乎之前听过， 但第一次系统学完数据结构还没用过）。 从一个合格的节点出发，生成迷宫， 直到这段迷宫不能继续生长为止。 然后换个合格节点继续生成， 直到整个地图被迷宫填充。</p>

<p>这块比较困惑的地方是如何生成用以生长 Maze Path 的节点， 作者的思路很巧妙， 他规定了整个地图的尺寸是奇数的 <strong>W x H</strong> 大小， 同样也规定了生成的 Rooms 的尺寸也是奇数的， 且 Rooms 的原点位置也是奇数， 这样在我们遍历整个地图的时候， 只要将奇数位置填充为 <strong>Wall</strong> 类型， 就能够创建潜在的生成 Maze Path 的节点， 这些节点都能够和相邻的 Rooms 对齐且相聚一个 Tile 距离， 这是非常重要的一个属性。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/maze_path_tiles.png" alt="Essential maze path tiles, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Essential maze path tiles, HangX-Ma</u></font>
</div>

<p>在我们遍历完整个地图后， 就能够得到充满这些潜在可能转为 Maze Path 的 Wall Tile， 此时运用 <strong>Flood Fill</strong> 算法就能生成填充 Rooms 之间间隙的 Maze Path 了。 这里的思路也是遍历整张图找之前设定的 <strong>Wall Tile</strong>， 找到之后我们在该点的上下左右四个方向中找到沿该方向行进 2 格的 Tile（保证奇数这个属性）， 这个 Tile 的属性是 Wall， 并且落在设定的地图范围内。 连接当前点和目标点时， 我们设定这些 Tiles 的属性为 Floor， 这样在遍历完整个地图后就能得到 Maze Path。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/rooms_with_maze_path_without_connection.png" alt="Rooms with maze path but no connections, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Rooms with maze path but no connections, HangX-Ma</u></font>
</div>

<h3 id="23-连接-rooms-和-paths">2.3 连接 Rooms 和 Paths</h3>

<p>此时一个重要的问题落在了面前， 如何连接 Rooms 和 Paths 使得整个地图联通。 一般来说我们都会想到用 Union 来解决这个问题， 但这里有个 trick， 我们需要将之前的各个独立的 Maze Path 视作一个单位而不单独去考虑组成 Maze Path 各个 Tiles， 所以在生成 Maze Path 的时候， 用 Kruskal Union 算法将这些组成 Paths 的 Tiles 加入联通集中， 对于 Rooms 中的 Tiles 也要进行相同的操作。 当然现在又有一个问题， 如何找到这些潜在的可成为 Passage 的 Tile？</p>

<p>其实和之前的思路很类似， 也是要扫描整个图， 当扫到 Rooms 和 Paths 之前的空白区域的时候我们就开始进行筛选， 检查这个节点的上下左右四个方向的相邻节点是不是不为 Nothing 属性， 如果符合条件的相邻节点的数量大于两个， 说明这是一个潜在的 Passage Tile， 加入候选的集合中。</p>

<p>之后我们就随机选取潜在的 Passage Connector， 如何该 Tile 还不在 Kruskal Union 中， 就将该 Tile 加入 Kruskal Union 中。</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/rooms_with_maze_path_and_connection.png" alt="Rooms with maze path and connections, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Rooms with maze path and connections, HangX-Ma</u></font>
</div>

<h3 id="24-优化生成的地图">2.4 优化生成的地图</h3>

<ul>
  <li>
    <p>地图过于拥挤</p>

    <p>现在生成的地图和样例所给的相去甚远， 太拥挤了， 有没有办法将生成的 Maze Path 缩小一些？ 我的比较粗浅的想法就是限制之前的 Wall Tiles 锚点的位置， 在判断是否落在地图范围内的时候就直接缩小地图的比例， 例如设定一个 <code class="language-plaintext highlighter-rouge">GEN_RATIO</code> 的系数约束生成区域。</p>
  </li>
  <li>
    <p><strong>Dead End</strong> 过多</p>

    <p>地图中出现很多死胡同是很糟心的， 这也是之前的 Maze Path 的一个重要问题， 需要一种算法去优化生成的 Maze Path 以减少死胡同的数量。 得益于之前地图的奇数尺寸的设定， 判断死胡同的方式很简单， 只需要检查这个点的邻居点是否有 3 个 Tile 的属性都是 Nothing， 这说明这个 Tile 没能够与另一个区域直接相连。</p>

    <p>那么， 在遍历整张图找相应的 Dead End 的时候， 我们可以将其邻居点中不为 Nothing 的点作为下一个检查点或以此为下个检查方向， 直到死胡同消失或者达到我们设定的处理次数限制后， 我们再继续遍历地图。</p>
  </li>
  <li>
    <p>生成地图的墙</p>

    <p>前面将 Rooms 以及 Paths 都生成并优化了， 却发现有些灵魂缺失， 原来是关键的墙体没有生成。 再来一次暴力全图搜索， 找到不是空白的 Tile， 这次我们需要检查这些 Tile 的八邻居节点， 将这些节点中为 Nothing 属性的 Tile 设置为 Wall 属性。</p>
  </li>
</ul>

<p>最后生成的地图如下所示：</p>

<div align="center">
    <img src="/norobots/images/2023-10-21-cs61b-proj3/optimized_world.png" alt="Optimized world, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Optimized world, HangX-Ma</u></font>
</div>

<h2 id="3-写在最后">3. 写在最后</h2>

<p>原来是想边写 Blog 边做 Proj3 的， 结果人懒了硬是拖了两个星期才写写成了总结。 感觉整个设计如果深挖还会遇到很多未知的困难， 但就是这样一个初具雏形的游戏却让我在初期感到束手无措， 这种感觉做 Proj2 的时候也有。 但相较于 Proj2 的严格要求， Proj3 的发挥空间和余地都很足， 难度上也简单一些。 虽然这俩 Proj 为了提升效率我都去借鉴了别人的框架， 虽然都很有收获， 但思考的机会少了。</p>

<p>总的来说， cs61b 给我的提升非常大， 在数据结构基础这块至少已经有了一个底子， 最近刷 LeetCode 的时候就明显感觉到学的内容能用得上， 并且很多设计思路都在实际使用的时候得到了思维上的强化。 cs61b 虽然学了很久， 但确实是一门不能急躁的课， 每个 slides 都要仔细阅读， discussion 以及 examprep 有精力有时间一定得自己独立去做， 这样印象会很深！</p>

<blockquote>
  <p>说一句题外话， 有些同学可能看到 cs61b 用的是 java 语言就觉得生疏， 或者日后用不着就不想学。 其实每个语言都有其各自的特性， 我有一个很明显的感受， 学完 java 的基础特性之后对面向对象的很多概念有了很深的理解， 尤其是 discussion 讲基类和子类的函数调用那块。 甚至我觉得最近很火的 Rust 有很多特性也是借鉴了 java。 当然语言这块在精不在多， 能博采众长是好事， 也需要潜心钻研不断深耕。</p>
</blockquote>

<p>就写到这儿， 日后再多复习复习课件， 温故而知新！</p>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs61b" /><category term="Java" /><summary type="html"><![CDATA[UCB cs61 spring 2021 Proj3-BYoW 设计思路与记录]]></summary></entry><entry><title type="html">miniFOC 原理阐述与多模式应用</title><link href="https://hangx-ma.github.io/2023/07/28/miniFOC-concept.html" rel="alternate" type="text/html" title="miniFOC 原理阐述与多模式应用" /><published>2023-07-28T00:00:00+08:00</published><updated>2023-07-28T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/28/miniFOC-concept</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/28/miniFOC-concept.html"><![CDATA[<p>还是遇到一些需要记录的地方， 毕竟电机控制这部分仅仅在 <em>运动控制技术</em> 这么课听过一点点（老师不咋讲， 学生不咋听）， 实践的时候和理论还是有已经的距离的。</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://space.bilibili.com/382415040/channel/collectiondetail?sid=1401820">电机FOC软硬件一条龙服务【STM32、自制IPM驱动板】 - 热心市民翔先生 Bilibili</a></li>
  <li><a href="https://blog.csdn.net/loop222/article/details/121201638">SimpleFOC、ODrive和VESC 教程链接汇总 - loop222 CSDN</a></li>
  <li><a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.788.recommend_more_video.2&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">【开源】自制超级无敌宇宙超迷你FOC磁场定向控制的无刷伺服电机矢量控控制器【烂核】 - 小男孩gugugu Bilibili</a></li>
  <li><a href="https://wwjk.lanzoub.com/igCqS0jx5fwf">mini_FOC - 小男孩gugugu Bilibili</a></li>
</ul>

<h2 id="x1-零点标定">X1. 零点标定</h2>

<div align="center">
    <img src="/norobots/images/2023-07-28-miniFOC-concept/zero_angle.png" alt="Zero angle concept, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Zero angle concept, HangX-Ma</u></font>
</div>

<p>标定初始电角度的原因在于， 一般情况下我们会将转子磁场方向与 \(\alpha\) 正向重合的方向作为转子的零点位置（转子角度为 \(0^{\circ}\)）。 但是， 上电的时候电机还为经过电角度标定， 转子的位置对于控制器而言是未知的， 如果转子此时正好与 \(\beta\) 轴重合， 即以前述定义描述此时的转子角度已经处于 \({90}^{\circ}\)， 而控制器以为其仍处于 \(0^{\circ}\) 位置而产生了一个超前 \({90}^{\circ}\) 的 \(I_{q}\)， 那么 \(I_{q}\) 与转子此时完全重合。 只有 \(I_{q}\) 与转子存在角度差才能在切向产生力做功， 而此时重合的情况就会导致电机卡死不动。</p>

<p>零点标定的原理就是进行一个开环控制， 给定一个 \(\alpha\) 轴的电流， 使得电机转子转向并固定在 \(\alpha\) 轴， 此时的电角度就是需要标定的电角度偏移量。 因而有如下条件成立：</p>

\[\begin{equation*}
  \begin{aligned}
    U_{\alpha} &amp;= Const \\
    U_{\beta} &amp;= 0 \\
  \end{aligned}
\end{equation*}\]

<p>经过 Park 变换后可以得到如下结果：</p>

\[\begin{equation*}
  \begin{aligned}
    U_{q} &amp;= 0                          \qquad U_{d} = \alpha                   \qquad electrical\_angle = 0 \\
    U_{q} &amp;= \alpha                     \qquad U_{d} = 0                        \qquad electrical\_angle = -\pi/2 \\
    U_{q} &amp;= \frac{\sqrt{2}}{2}\alpha   \qquad U_{d} = \frac{\sqrt{2}}{2}\alpha \qquad electrical\_angle = -\pi/2 \\
  \end{aligned}
\end{equation*}\]

<p>一般来说第二条比较方便， 需要注意的是这个初始给的 \(U_{q}\) 不能太大， 小电机 0.5 V 开始网上调能带动就行。 我们可以通过开环状态下， 多次循环 <code class="language-plaintext highlighter-rouge">set_phase_voltage(float Uq, float Ud, float e_angle)</code> 以达到固定角度的目的。</p>

<h2 id="x2-角度对齐与极对数计算">X2. 角度对齐与极对数计算</h2>

<p>角度对齐是基于电角度与机械角度方向需要一致的需求， 若电角度和机械角度相反， 电机会发生原位卡死的问题。 已经解决零点标定问题， 我们只需要让电机从零点开始以 \(2\pi\) 电角度为偏移量进行转动， 通过中间角度的正负值即可判断电机的转动方向（因为我们转动后还需要转回原来的零点位置， 所以这个 \(2\pi\) 角算是中间角）。 这里需要注意 <code class="language-plaintext highlighter-rouge">电角度 = 机械角度 * 极对数</code>， \(2\pi\) 的电角度不会导致电机转一整圈， 现在的 PMSM 一般都有 6 个极对数。</p>

<p>此时我们还能进行极对数的计算， 因为转动 \(2\pi\) 后我们能读到一个机械角度量， 而电角度是机械角度的极对数倍（也就是整数倍）， 进行涉入取整计算即可得到极对数。</p>

<blockquote>
  <p><a href="https://www.bilibili.com/video/BV1C44y1j77b/?spm_id_from=333.788&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">project_3 实现角度反馈及电机力矩控制 - 热心市民翔先生</a>
<a href="https://blog.csdn.net/loop222/article/details/120471390">SimpleFOC移植STM32（四）—— 闭环控制 - loop222 CSDN</a></p>
</blockquote>

<h2 id="x3-foc-多应用模式">X3. FOC 多应用模式</h2>

<h3 id="x31-ratchet-棘轮模式">X3.1 Ratchet 棘轮模式</h3>

<p>棘轮模式目的是通过 FOC 力矩反馈使人感触到棘轮齿的一种力矩控制模式。 由于我的 miniFOC 的电流环调试效果并不好， 低速状态下存在抖动， 因而用 <code class="language-plaintext highlighter-rouge">Uq</code> 电压直接控制力矩大小。 棘轮模式的主要原理就是人为设定几个 <strong>引力点（Attractor）</strong>， 利用当前机械角度与引力点之间的位置误差， 控制输出的力矩大小， 一般来说我们可以直接使用 PID 中的比例控制直接决定输出力矩的以模拟棘轮的不同刚度。</p>

<p>可参阅如下代码， 例如我们将机械角度 360° 等分为 6 份， 也就是设定每 60° 会有一个吸引点， 当前的电机转轴机械角度为 <code class="language-plaintext highlighter-rouge">shaft_angle</code>， 那么与 <code class="language-plaintext highlighter-rouge">attract_angle</code> 之间的角度误差为 <code class="language-plaintext highlighter-rouge">attract_angle - shaft_angle</code>， 就可以将该误差项作为输入给到力矩控制器， 力矩控制器会进行比例调整， 并对输出的电压或电流进行限幅。 每个控制周期我们都需要重新确认邻近的棘轮引力点以保证棘轮感触的位置的正确性。</p>

<div class="language-c copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// attractor angle variable</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">attract_angle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
<span class="c1">// distance between attraction points</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">attractor_distance</span> <span class="o">=</span> <span class="mi">60</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">/</span> <span class="mi">180</span><span class="p">.</span><span class="n">f</span> <span class="o">*</span> <span class="n">_PI</span><span class="p">;</span> <span class="c1">// dimp each 45 degrees</span>

<span class="kt">float</span> <span class="nf">find_attractor</span><span class="p">(</span><span class="kt">float</span> <span class="n">angle</span><span class="p">){</span>
    <span class="kt">uint32_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">qfp_fadd</span><span class="p">(</span><span class="n">qfp_fdiv</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">attractor_distance</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">qfp_fmul</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">idx</span><span class="p">,</span> <span class="n">attractor_distance</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ratchet_mode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g_tor_ctrl</span><span class="p">.</span><span class="n">target_torque</span> <span class="o">=</span> <span class="n">attract_angle</span> <span class="o">-</span> <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">;</span>
    <span class="n">attract_angle</span> <span class="o">=</span> <span class="n">find_attractor</span><span class="p">(</span><span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下图是参阅博客园对棘轮模式原理的电压与角度关系图， 这里设定的棘轮角度为 45°， 可以看到棘轮的作用力的分界点在 <code class="language-plaintext highlighter-rouge">45°/2 = 22.5°</code> 的位置。</p>

<p>这很容易理解， 这个点是两个棘轮齿的中心点， 若 <code class="language-plaintext highlighter-rouge">shaft_angle &gt; 22.5°</code> 则 <code class="language-plaintext highlighter-rouge">find_attractor</code> 会找到下一个棘轮位置， 反之则仍是当前的棘轮位置。 我们知道闭环负反馈的作用是使作用对象稳定在目标位置， 在 <code class="language-plaintext highlighter-rouge">[0;22.5°]</code> 之间， 越靠近中心点 <code class="language-plaintext highlighter-rouge">22.5°</code> 距离误差越大， 受到反向的力矩越大； 而一旦跨过中心点位置， 棘轮齿更新为下一个位置， 此时的距离误差方向就与原来的相反了， 因而受到的是正向力矩的推力， 这里会有一个明显的电压的方向的改变， 力矩方向顺应改变， 这是人感受到棘轮齿的重要原因。</p>

<div align="center">
    <img src="/norobots/images/2023-07-28-miniFOC-concept/ratchet_mode.png" alt="Ratchet mode Voltage-Angle relationship, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Ratchet mode Voltage-Angle relationship, HangX-Ma</u></font>
</div>

<blockquote>
  <p><a href="https://www.cnblogs.com/21207-iHome/p/16898471.html">无刷电机力矩控制模拟棘轮 - XXX已失联 博客园</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 相关的原理， 包括 FOC， SVPWM， 零点检测等， 主要记录自己不熟悉的部分， 另外也记录一些基于 FOC 实现的有趣的应用。]]></summary></entry><entry><title type="html">STM32F103 Vofa+ 配置与调试指南</title><link href="https://hangx-ma.github.io/2023/07/19/vofaplus.html" rel="alternate" type="text/html" title="STM32F103 Vofa+ 配置与调试指南" /><published>2023-07-19T00:00:00+08:00</published><updated>2023-07-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/19/vofaplus</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/19/vofaplus.html"><![CDATA[<p>为了阐述清晰和 miniFOC 的开发进行的区分， 单独一章讲一讲这个上位机调试工具 <a href="https://www.vofa.plus/">Vofa+</a>， 当时是看到 B 站 Up <a href="https://space.bilibili.com/662875973">mandzy</a> 的视频以及 Vofa+ 精致的界面感觉这个工具能够帮上不少忙。 目前 Vofa+ 支持三种传输协， <em>FileWater</em>， <em>JustFloat</em>， <em>RawData</em>。 对于电机控制而言， 传输波形的数据需要用到浮点， 第二个传输浮点数据的协议就比较合适了， 具体选用哪种协议示情况而定。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_demo.png" alt="Vofa+ demo, HangX-Ma" width="800" />
    <br />
    <font size="2" color="#999"><u>Vofa+ demo, HangX-Ma</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://www.vofa.plus/">Vofa plus</a></li>
  <li><a href="https://www.vofa.plus/downloads/?index=1&amp;plugin_index=2">Vofa plus - plugins</a></li>
  <li><a href="https://www.bilibili.com/video/BV1DP411C7Xe/?spm_id_from=333.999.0.0&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32使用HAL库生成USB虚拟串口连接VOFA+输出波形 - mandzy Bilibili</a> <a id="vofa_demo"></a></li>
  <li><a href="https://www.bilibili.com/video/BV15V411T7Gg/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32F4使用DMA串口通信连接VOFA软件进行电机调试和波形显示 - mandzy Bilibili</a></li>
  <li><a href="https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">ST RM0008 Reference manual</a></li>
</ul>

<h2 id="1-stm32-virtual-serial-port">1. STM32 Virtual Serial Port</h2>

<p>本质上是用 USB 虚拟串口进行数据收发， 没想到 F103 系列也支持， 但是后来看了看 F103 虚拟串口没有 DMA 功能， 这个就比较致命了。 按照现有设计， 除了进行指令的交互， MCU 还需要通过串口向上位机传输数据， 如果直接交由 CPU 进行处理会极大浪费计算资源， 一般来说需要通过 DMA 规避 CPU 对这些数据的处理。 所以， 对于 F103 系列还是老老实实用 USARTx + DMA 的组合比较合适。</p>

<h2 id="2-vofa-justfloat-protocol">2. Vofa+: JustFloat Protocol</h2>

<p>具体的协议内容可以看官网的 <a href="https://www.vofa.plus/plugin_detail/?name=justfloat">JustFloat</a> 说明， 除了采样数据解析外， 该协议还能进行图像解析。 目前我只用到了数据采样解析部分， 搞懂这个也就一通百通了， 可以看到滚放定义的数据帧如下所示， 帧尾是一个 4 字节的特定数据 <code class="language-plaintext highlighter-rouge">0x00, 0x00, 0x80, 0x7f</code>， 这是小端的顺序， 大端需要调换一下数据的存储顺序。 也就是说， 我们在发送完希望传输的数据后， 需要紧跟在这些数据后面发送一个尾帧， 才能让 Vofa+ 识别数据帧的内容并进行可视化以及文本打印。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CH_COUNT 通道数量
</span><span class="k">struct</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">fdata</span><span class="p">[</span><span class="n">CH_COUNT</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tail</span><span class="p">[</span><span class="mi">4</span><span class="p">]{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>一般来说， 串口是无法接收 float 类型的数据的， 但 float 类型在 STM32 中占据 4 个字节， 因而我们可以定义这样一个 union 联合体结构解决 float 数据传输的问题。 <code class="language-plaintext highlighter-rouge">fdata</code> 和 <code class="language-plaintext highlighter-rouge">chars</code> 共用一块内存区域并且都占据 4 个字节， 这样在使用串口发送数据的时候就能将 <code class="language-plaintext highlighter-rouge">fdata</code> 拆分成 4 个 <code class="language-plaintext highlighter-rouge">chars</code> 进行发送。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief Use union to decompose the float_data into 4 bytes char.
 *        Because the USART only transfer bytes.
 */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">Format</span><span class="p">{</span>
    <span class="kt">float</span>    <span class="n">fdata</span><span class="p">;</span>    <span class="c1">// little-endian float</span>
    <span class="kt">uint8_t</span>  <span class="n">chars</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Format_Typedef</span><span class="p">;</span>

<span class="n">Format_Typedef</span> <span class="n">send_data</span><span class="p">[</span><span class="n">VOFA_SEND_CH_COUNT</span><span class="p">];</span>
<span class="n">Format_Typedef</span> <span class="n">recv_data</span><span class="p">[</span><span class="n">VOFA_RECV_CH_COUNT</span><span class="p">];</span>
</code></pre></div></div>

<p>这样， 根据这个协议， 我们仅需要定义两个数据就能完成 USART 的收发， 将这两个数组的地址分别配置为发送部分 DMA 的内存地址， 以及接收部分的内存地址。 当然， 在设置 DMA 的传输数据总量的时候也需要考虑到末尾 4 个字节的特定数据帧。</p>

<p>具体的配置可以查看 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Inc/vofa_usart.h">vofa_usart.h</a> 和 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Src/vofa_usart.c">vofa_usart.c</a> 这两个文件。</p>
<blockquote>
  <p>特别感谢 B 站 mandzy Up 提供的代码参考！</p>
</blockquote>

<h2 id="3-vofa-components">3. Vofa+ Components</h2>

<p>Vofa+ 还提供了一系列控件方便我们进行对下位机的调试， 这里以这个 <code class="language-plaintext highlighter-rouge">ExtraButtonToggle</code> 控件为例。</p>

<p>将这个控件拖出到新的 Tab 中， 右击可以看到一个 <code class="language-plaintext highlighter-rouge">事件与参数</code> 的选项， 这是表示按钮在 <strong>激活</strong> 以及 <strong>关闭</strong> 的时候会发送的指令。 如果我们的下位机协议非常简单， 配置这个控件的这个选项的参数就能实现功能， 但我们经常会需要对指令包装一个帧头以区分不同功能的指令， 并在解析帧头后继续接收数据， Vofa+ 提供了一个 <code class="language-plaintext highlighter-rouge">命令</code> 区块方便我们发送 <strong>帧头+数据</strong> 这种组合。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_components.png" alt="Vofa+ components, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Vofa+ components, HangX-Ma</u></font>
</div>

<p>以上图为例， 我定义了一段命令的内容为 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">%% 00 00 00</code>， 前半部分是我定义的帧头数据， 只有识别到 <code class="language-plaintext highlighter-rouge">AA</code> 和 <code class="language-plaintext highlighter-rouge">FF</code> 我才会继续解析指令， 将末尾的 <code class="language-plaintext highlighter-rouge">01</code> 作为区分不同指令的具体标识。</p>

<p>而后半段则是我定义的数据帧， <code class="language-plaintext highlighter-rouge">%%</code> 标识占位符， 这样一组 <code class="language-plaintext highlighter-rouge">%%</code>占位一个字节， 我在这个按钮控件的 <code class="language-plaintext highlighter-rouge">事件与参数</code> 部分设置了激活态发送 <code class="language-plaintext highlighter-rouge">01</code>， 关闭态发送 <code class="language-plaintext highlighter-rouge">02</code>， 这样在我按下按钮后， 根据当前按钮的状态， <code class="language-plaintext highlighter-rouge">%%</code> 会被替换为 <code class="language-plaintext highlighter-rouge">01</code> 或者 <code class="language-plaintext highlighter-rouge">02</code>。 这样， 每次按下按钮后， Vofa+ 都会向 STM32 发送 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">01 00 00 00</code> 或者 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">02 00 00 00</code>。</p>

<p>可以结合我在 USART 中 DMA 接收部分对数据的解析方式进行理解。</p>

<div class="language-c copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">USARTx_DMA_RX_IRQHandler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If data receiving complete, clear the TC5 flag</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LL_DMA_IsActiveFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LL_DMA_ClearFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">);</span>
        <span class="c1">// receive frame header: 0xAA 0xFF</span>
        <span class="n">Format_Typedef</span> <span class="n">recv_header</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xAA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="n">Format_Typedef</span> <span class="n">recv_data</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mh">0x01</span><span class="p">:</span>                         <span class="c1">// control motor start/stop</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// start</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">start_pwm</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// stop</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">stop_pwm</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x02</span><span class="p">:</span> <span class="c1">// set velocity</span>
                <span class="n">g_target_motor_vel</span> <span class="o">=</span> <span class="n">recv_data</span><span class="p">.</span><span class="n">fdata</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// we need to disable dma rx channel and reset the transfer length</span>
        <span class="n">usart_rx_dma_reload</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>这里为什么设置的发送帧为 8 个字节？ 这是因为目前使用的是 <strong>JustFloat</strong> 协议， 协议发送和接收都是依据 float 的格式与大小进行的。 而我定义了接收帧为大小为 2 的 <code class="language-plaintext highlighter-rouge">Format_Typedef</code> 数组， 正好是 2 个 float， 8 个字节大小。 若是不理解可以看看 mandzy 的相关 <a href="#vofa_demo">视频</a>。</p>
</blockquote>

<h2 id="4-调试记录">4. 调试记录</h2>

<p>一个简单的 USART + DMA 配置， 结果配完 USART1 后发现没有数据发送出来， 也没有数据接收到。</p>

<ul>
  <li>将 USART1 更换为 USART2 以及 USART3 都是一样的情况。</li>
  <li>检查了 DMA 的配置， 发现 <code class="language-plaintext highlighter-rouge">recv_frame</code> 和 <code class="language-plaintext highlighter-rouge">send_frame</code> 的地址忘记写目标地址上了， 但是还是不行。</li>
  <li>单独测试收的过程， 在指令中加入一个翻转 LED 的命令， 无效， cortex-debug 也接收不到中断。</li>
  <li>主程序可以跑通， 加入 LED 翻转指令有效， 通过 cortex-debug 插件也没有发现数据有问题。</li>
  <li>用自己之前写的可以工作的 USART1 的程序进行回环测试， 无效， 基本确定 CH340 硬件坏了。</li>
  <li>用逻辑分析仪测了一下输出脚 <em><strong>PB6(Tx)</strong></em> 有不同的输出波形， 说明 DMA 通信不成问题了， 协议部分还不清楚， 但 CH340 肯定坏了。</li>
  <li><code class="language-plaintext highlighter-rouge">JustFloat</code> 协议测试可用。</li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="C" /><category term="STM32" /><summary type="html"><![CDATA[上位机调试工具 Vofa+ 食用指南， 结合电机调试进行说明， 感谢 Bilibili 大学。]]></summary></entry><entry><title type="html">OOP C Programming</title><link href="https://hangx-ma.github.io/2023/07/18/oopc.html" rel="alternate" type="text/html" title="OOP C Programming" /><published>2023-07-18T00:00:00+08:00</published><updated>2023-07-18T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/18/oopc</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/18/oopc.html"><![CDATA[<p>研究这部分内容的动机主要还是编写 STM32 的 C 代码的时候， 期望有一个固有的类能够管理其方法， 这样能够比较清晰的管理这些同属于一类的代码结构。 其实这里就涉及到了 <strong>面向对象</strong> 的编程思想， 将数据抽象为 <strong>类</strong> 和 <strong>方法</strong>， 类能表征数据的属性， 而方法则是数据属性及状态改变的一种行为。</p>

<p>之前在接触 Linux 驱动的时候其实就浅浅地接触到了 C 面向对象的思想， 例如 MTD 层抽象接口提供给 Block， 我们直接从顶层通过代码索引的方式是没办法找到具体的 Block 调用方法的。 我们只能看到 MTD 抽象出来的接口， 这一定程度上提供了数据的私有化的能力。</p>

<p>网上的相关文章众说纷纭， 但目前看来就是 <em><strong>C 现代编程</strong></em> 这本书讲的最清晰最明白， LW_OOPC 则是 高焕堂 以及其团队 MISOO 设计的方便 C 面向对象的宏定义模块， 能方便相关的开发。 其实这些文章读过来， 主要还是需要开发者用好 <code class="language-plaintext highlighter-rouge">struct</code>， <code class="language-plaintext highlighter-rouge">Macro</code>， <code class="language-plaintext highlighter-rouge">pointer</code>  这三类资源。 <code class="language-plaintext highlighter-rouge">struct</code> 可谓是重中之重， 可以看到在 C++ 中的 struct 和 class 仅在数据接口的私有性上存在差异， 而在 Rust 中则直接删除了 class 的定义， 转向了 struct + trait 的编程模式。</p>

<p>这篇文章不定期更新 OOP C 的一些想法， 其实读 <em><strong>C 现代编程</strong></em> 还是有很多疑惑的， 但是没用到就没太深刻的印象， 有问题再好好研究记录！</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://pan.baidu.com/s/1qf2VAPh5zU8PAToU9RHbCg?pwd=l9ry">C 现代编程 - 百度网盘</a>
    <blockquote>
      <p>这本书最关键， 下面的感觉写的都不如这本书详细清晰。</p>
    </blockquote>
  </li>
  <li><a href="https://pan.baidu.com/s/1bda2tBK7KZxSOlMUcWMccQ?pwd=secu">UML+OOPC嵌入式C语言开发精讲 - 百度网盘</a></li>
  <li><a href="https://github.com/Akagi201/lw_oopc/tree/master">lw_oopc - Github</a></li>
  <li><a href="https://ooc-coding.sourceforge.net/">Object Oriented C - ooc</a></li>
  <li><a href="https://mp.weixin.qq.com/s/V8xil48IoQE6QB82_5o2_w">真的可以，用C语言实现面向对象编程OOP - 李肖遥 WeChat</a></li>
  <li><a href="https://www.cnblogs.com/kendoziyu/p/c_object-oriented_programming_example_by_struct.html">C语言使用结构体面向对象编程举例讲解 - 极客子羽 博客园</a></li>
</ul>

<h2 id="1-使用-struct-模块化编程">1. 使用 struct 模块化编程</h2>

<p>主要想法还是利用 struct 管理方法函数， 利用 <code class="language-plaintext highlighter-rouge">static</code> 对 <code class="language-plaintext highlighter-rouge">.c</code> 文件中的函数进行私有化处理防止命名冲突。</p>

<p>另外， struct 也能起到虚函数的功能， 如下定义了一个 <code class="language-plaintext highlighter-rouge">page_t</code> 的结构体， 这个结构体规定了其内实现的方法函数的接口。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">painter</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span> <span class="n">page_t</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="2-跨文件的全局变量">2. 跨文件的全局变量</h2>

<p>另外在整个工程中会需要跨文件使用相关的变量， 例如我在 <code class="language-plaintext highlighter-rouge">encoder.h</code> 定义了一个 <code class="language-plaintext highlighter-rouge">struct Encoder</code> 作为编码器类， 而我希望通过一个 <code class="language-plaintext highlighter-rouge">g_encoder</code> 变量作为跨文件的全局变量被不同文件使用。 例如在 <code class="language-plaintext highlighter-rouge">encoder.c</code> 中初始化方法函数， 而在其他文件中调用这些方法， 此时通过一个全局的变量就非常方便了。 这里需要区分 <strong>声明</strong> 和 <strong>定义</strong> 这两个概念。</p>

<dl>
  <dt>声明</dt>
  <dd>向编译器说明一个变量或函数的信息，包括：名字、类型、初始值等，即声明变量、函数的属性细节， 包含该声明的模块在连接阶段从其它模块寻找外部函数和变量。</dd>
  <dt>定义</dt>
  <dd>指明变量、函数存储在哪里，当定义发生时，系统为变量或函数分配内存单元。</dd>
</dl>

<p>我在这里是这样构想的， 对于特定功能的类， 例如 <code class="language-plaintext highlighter-rouge">Encoder</code> 编码器类， 则直接在 <code class="language-plaintext highlighter-rouge">encoder.c</code> 中定义一个这个类型的变量 <code class="language-plaintext highlighter-rouge">g_encoder</code>， 在 <code class="language-plaintext highlighter-rouge">encoder.h</code> 中则通过 <code class="language-plaintext highlighter-rouge">extern</code> 声明 <code class="language-plaintext highlighter-rouge">g_encoder</code>。 这样， 任何包含 <code class="language-plaintext highlighter-rouge">encoder.h</code> 的文件都能直接使用这个变量。 而一些影响设备属性的 primitive 类型的变量则通过 <code class="language-plaintext highlighter-rouge">config.h</code> 以及 <code class="language-plaintext highlighter-rouge">config.c</code> 进行声明和定义。 这样能够分离文件的职能， 不会导致 <code class="language-plaintext highlighter-rouge">config.h</code> 这个管理全局变量的文件不断 include 各种子设备而导致文件管理过于繁杂和臃肿。 但我需要在 <code class="language-plaintext highlighter-rouge">config.h</code> 用注释说明这些全局变量的位置以及功能， 方便后续进行查阅检索。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Encoder</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Encoder</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://www.cnblogs.com/wangh0802PositiveANDupward/archive/2012/08/06/2624827.html">C语言：全局变量在多个c文件中公用的方法 - 奔流聚海 博客园</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="C" /><summary type="html"><![CDATA[结合 OOP 思想进行 C 语言编程， 这篇文章并不从头介绍相关的知识， 而是记录个人学习的疑难点以及参考资料等资源。]]></summary></entry><entry><title type="html">miniFOC Driver Development</title><link href="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html" rel="alternate" type="text/html" title="miniFOC Driver Development" /><published>2023-07-17T00:00:00+08:00</published><updated>2023-07-17T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/17/miniFOC-dev</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html"><![CDATA[<p>研 0 的时候不知好歹自己做了一块驱动板， 但是没有任何经验也不知道怎么开发， 结果上电就烧。 直到最近看到了 B 站 Up <a href="https://space.bilibili.com/382415040">热心市民翔先生</a> 发的 FOC 开发的系列视频感觉这个项目是有救了。 这也算是圆了自己 STM32 开发的愿望， 之前只学习做过一些 demo， 导师甚至把 MCU 称之为玩具（相对他高大上的嵌入式 Linux 而言确实如此）。 但无论如何， 学习的过程中总是会有收获的， 我不认为他们口中简单的东西在没有接触之前都是简单的， 至少我需要这个开发经历。</p>

<blockquote>
  <p>目前板子设计借鉴了 <a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">小男孩gugugu</a> Up 的这部分内容（视频标题太长啦！）， 不想自己从头找元件然后再一个个建模搭了， 太费时间了这样就本末倒置了。</p>
</blockquote>

<ul>
  <li><strong>MCU:</strong> STM32F103C8T6, 64K Flash, 20K SRAM</li>
  <li><strong>Dev Tool:</strong> CMake, OpenOCD, STLink-v2, STM32CubeMX</li>
  <li><strong>Serial Communication:</strong> Vofa+</li>
  <li><strong>PCB Design:</strong> Altium Designer 23</li>
  <li><strong>Editor:</strong> VSCode</li>
  <li><strong>Debugger:</strong> Cortex-Debug</li>
  <li><strong>Third Party Library:</strong>
    <ul>
      <li>Float-point Calculation Optimization: Qfplib-M3</li>
      <li>OLED Display: u8g2</li>
    </ul>
  </li>
</ul>

<p>项目地址 <a href="https://github.com/HangX-Ma/miniFOC">HangX-Ma/miniFOC</a>， 项目将持续更新， 这次挺有信心的！</p>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/miniFOC.svg" alt="miniFOC design, HangX-Ma" width="800" />
    <br />
    <font size="2" color="#999"><u>miniFOC design, HangX-Ma</u></font>
    <br />
    <br />
</div>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/all-components.png" alt="miniFOC driver board and other components, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>miniFOC driver board and other components, HangX-Ma</u></font>
</div>

<h2 id="1-sc60228-磁编码器">1. SC60228 磁编码器</h2>

<p>SC60228 是一款非接触式高精度磁编码器芯片， 芯片中心内置了霍尔感应点矩阵， 可用以测量无刷电机的转子角度。 通过 PWM 或 SPI 的方式输出 12 bit 绝对式位置信息， 检测速率可达 20K rpm， 不难得知该款芯片能检测一周最多 4096 个位置。 相较读取 PWM 输出计算角度而言， 使用 SPI 协议读取数据的精度会更高， 代码编写也比较方便且具备通用性。</p>

<blockquote>
  <p>用这款芯片也是历史遗留问题了， 当时做了这个板子不忍心浪费， 网上有 Simple FOC 提供的 <a href="https://github.com/simplefoc/Arduino-FOC-drivers/tree/master/src/encoders/sc60228">SC60228 SimpleFOC driver</a> 可参考代码部分， 虽然看起来事情不多， 但理解数据手册进行配置和代码编写也对学习很有帮助。</p>
</blockquote>

<h3 id="11-时序图与-spi-基本配置">1.1 时序图与 SPI 基本配置</h3>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/encoder-spi-time-diagram.png" alt="Encoder SPI time diagram, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI time diagram, HangX-Ma</u></font>
</div>

<p>这款芯片只需要配置 SPI 口在主机接收 <strong>(Receive Only Master)</strong> 数据即可， 不涉及双向数据传输。 我原来计划使用 DMA 传输 SPI 的数据， 但实际上 DMA 在小数据量以及高速读取的情况下并不合适， 这里的位置信息仅 16 位， 有些多此一举了。</p>

<p>可以看到上图数据手册提供的读取绝对式角度数据的时序表， 根据 SPI 协议 SCLK 空闲时低电平， 另外根据数据手册， 在 SCLK 上升沿之后需要保持 \(t_{DO}\) 时间以使得 MISO 数据有效， 那么只能在下降沿进行数据采样。 不难确定 SPI 协议的 <strong>CPOL(Clock Polarity)</strong> 为 <strong>Low</strong>， <strong>CPHA(Clock Phase)</strong> 为 <strong>Second Edge</strong>。</p>

<p>另外， 手册指出 <strong>\(t_{CLK}\)（SCLK 周期）</strong> 最小需要 100ns， 这里我查了一下 STM32CubeMX 配置中的 Baud Rate 的含义， 如果没理解错就相当于 SPI 中的 SCLK。 对于预设 72MHz 时钟频率的板子， 8 分频 9.0 MBits/s ≈ 111 ns， 另外 <strong>\(t_{DO}\)（SCLK 的上升沿到 MISO 数据有效之间的时间）</strong>_ 其值最大能达到 50 ns， 那么当前算是极限的速率配置了。 为了保险起见我选择设置 16 分频约 222 ns 周期， 防止数据出现丢失以及未定义的情况。</p>

<blockquote>
  <p>这里配置的是 SPI1 的， 我后面改成 SPI2 之后由于总线的时钟频率不一样， SPI2 只需要 8 分频。 改这个总线的原因还是因为 SPI2 的 DMA 通道给 USART1 给占了， 想玩玩 OLED 得用 SPI + DMA 的方式速率才能跟得上， 虽然最后可能会因为计算资源问题不上 OLED。</p>
</blockquote>

<p>除此之外数据手册中的 \(t_{L}\)， \(t_{H}\)， \(t_{CS}\) 这几个关键量需要在编程时在特定位置延时。 LL 库仅定义了毫秒级的延时， 一个简单的办法实现 us 级的延时就是通过 <code class="language-plaintext highlighter-rouge">__NOP</code> 指令， 这样至少不会浪费定时器资源而且目前也不需要这么高精度的延时（64 个 <code class="language-plaintext highlighter-rouge">__NOP</code> 就足够了。 72MHz 主频一个 <code class="language-plaintext highlighter-rouge">__NOP</code> 为 1/72 us）。</p>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/spi1-parameter-settings.png" alt="Encoder SPI1 parameter settings, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI1 parameter settings, HangX-Ma</u></font>
</div>

<blockquote>
  <p>后续测试若有问题则可将分频倍数调得更高一些， 400 ns 应该也是能接受的， 手册说明最大转速可测 20K rpm， 小电机能有 5K rpm 也不得了了。</p>
</blockquote>

<p>另外 16-bits 的数据中， 除了 MSB 开始的 <code class="language-plaintext highlighter-rouge">[D11..D0]</code> 角度数据， 后续有用的还有 <code class="language-plaintext highlighter-rouge">ERR</code>， 能够识别磁铁安装位置是否合适， 在装机的时候非常有用。 <code class="language-plaintext highlighter-rouge">PARC</code> 用以进行奇偶校验， 该位需要和前 15 位数据保持奇数特性。</p>

<p>另外配置片选引脚的时候需要默认输出为高并且将其配置为上拉模式， 这是根据时序图所示， 芯片是在 CS 脚为低的时候工作的， 这样能保证在必要的时候选中相应的片选脚进行数据传输。</p>

<blockquote>
  <p><a href="https://www.cnblogs.com/blogernice/articles/12531133.html">详解SPI中的极性CPOL和相位CPHA - blogernice 博客园</a><br />
<a href="https://zhuanlan.zhihu.com/p/26509678">秒懂 奇偶校验码 - 车卡门 知乎</a><br />
<a href="https://blog.csdn.net/ftswsfb/article/details/104321901">奇偶校验原理及C实现 - ftswsfb CSND</a><br />
<a href="https://blog.csdn.net/weixin_43593122/article/details/119253544">硬件探索——STM32F4通过SPI总线读取GMR（磁编码器） - 123-wqy CSDN</a><br />
<a href="https://zhuanlan.zhihu.com/p/632955358">STM32——DMA数据转运 - 柯宝最帅 知乎</a><br />
<a href="https://blog.51cto.com/u_13682052/4990083">stm32利用通用定时器实现函数运行时间精确测量 - biao2488890051 51CTO</a></p>
</blockquote>

<h3 id="12-spi-片选的说明">1.2 SPI 片选的说明</h3>

<p>SPI 片选对 SPI 设备是通用的， 不管是从机还是主机， 都需要配置片选引脚。 我在 CubeMX 中看到 NSS 引脚分为硬件和软件两种， NSS 就是平常所说的片选脚， 对于主机而言片选脚需要拉高的， 这样才能保证主机 SPI 处于工作状态。 如果选择软件配置， 那么在我们选择 STM32 作为主机的时候， LL 库自动帮我们配置了 SSI 引脚作为主机的片选。 而硬件配置则会根据芯片特定的 NSS 引脚决定相应的状态。</p>

<p>而 SPI 主机硬件配置时可以将 Hardware NSS Signal 配置为 <strong>Hardware NSS Output Signal</strong>， 这样 NSS 脚就能自动输出低电平使能从设备。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_44509533/article/details/104110454">STM32 SPI的NSS引脚配置 - 星水天河 CSDN</a><br />
<a href="https://blog.csdn.net/m0_46272475/article/details/121152512">STM32 SPI 软件NSS和硬件NSS解读 - fanyuandrj CSND</a></p>
</blockquote>

<h3 id="13-关于磁编码器的一些建议">1.3 关于磁编码器的一些建议</h3>

<ul>
  <li>一般来说磁编码器就只需要 1 或 2 个滤波电容外加芯片就行， 设计起来很方便， 时间成本允许就自己打样， 还能针对电机安装孔进行定制化设计。</li>
  <li>SPI 在芯片上的顺序一般都是 <code class="language-plaintext highlighter-rouge">CS</code>, <code class="language-plaintext highlighter-rouge">SCLK</code>, <code class="language-plaintext highlighter-rouge">MISO</code>, <code class="language-plaintext highlighter-rouge">MOSI</code>， 顺序搞错接线会很麻烦。</li>
  <li>磁编码器似乎不是特别耐高温， 我自己把之间用热风枪吹上的芯片拆下来又装到新板子， 老会出毛病， 如果一直出现返回 error 指不定是编码器坏了。</li>
  <li>磁铁需要买径向磁铁， <em>N 极</em> 和 <em>S 极</em> 对向水平分布。</li>
  <li>为了安装磁铁买了 AB 胶， 非常管用， 但除此之外还买了 3mm 轴套增加安装接触面积（热胶枪装不上）。</li>
</ul>

<h2 id="2-cortex-m3-浮点计算优化">2. Cortex-M3 浮点计算优化</h2>

<p><strong><a href="https://www.quinapalus.com/qfplib.html">Qfplib: a family of floating-point libraries for ARM Cortex-M cores</a></strong></p>

<p>一年前就找到了这个库了， 一直没尝试用过。 在 miniFOC 的项目中我是将所有的外部库都放到了 <code class="language-plaintext highlighter-rouge">Driver</code> 这个文件夹下面， 我创建了一个 <code class="language-plaintext highlighter-rouge">Qfplib-M3</code> 的文件夹存储浮点计算的库文件， 只需要在 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> 中添加这个库的路径就能使用了。 经过测试， 使用这个浮点库对计算性能有非常大的提升， 在单步调试的时候， 普通的浮点数除法比利用 qfplib 的浮点数除法有肉眼可见的差距。</p>

<h2 id="3-u8g2-库的使用">3. u8g2 库的使用</h2>

<p>u8g2 库的使用参考了两份代码（用的是 SSD1306 驱动芯片）， 但实际上这两篇文章都没有解决我使用 LL 库配置 SPI + DMA 进行数据传输的问题。 很遗憾我没解决这个问题， 最后使用了普通的 SPI 传输的办法， 这是因为我在几个论坛上发现很多人用了 SPI + DMA 就无法做到数据的正常传输， 必须等到 SPI + DMA 的数据传输完成后才能进行下一次传输， 而这需要通过 while 循环不断检查是否传输完毕。 既然需要 CPU 的参与， 不如直接用 SPI 还更省心。</p>

<ul>
  <li>SPI 发送数据， 需要通过 <code class="language-plaintext highlighter-rouge">LL_SPI_IsActiveFlag_TXE(SPI1)</code> 检查当前传输是否完成， 当前字节传输完成后才能开启下一次传输。</li>
  <li>除此之外， u8g2 将 CS 引脚拉高之前 （Deselect）， 需要确认 SPI 的传输已经结束， 否则会造成数据错误。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nf">u8x8_byte_4wire_hw_spi</span><span class="p">(</span>
    <span class="n">U8X8_UNUSED</span> <span class="n">u8x8_t</span> <span class="o">*</span><span class="n">u8x8</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">msg</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">arg_int</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">arg_ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_SEND</span><span class="p">:</span> <span class="c1">// Use SPI to send 'arg_int' bytes</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arg_int</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LL_SPI_TransmitData8</span><span class="p">(</span><span class="n">SPI1</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">__NOP</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_END_TRANSFER</span><span class="p">:</span>  <span class="c1">// Software CS is needed. (deselect)</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_BSY</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SET</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__NOP</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">gpio_and_delay_cb</span><span class="p">(</span><span class="n">u8x8</span><span class="p">,</span> <span class="n">U8X8_MSG_DELAY_NANO</span><span class="p">,</span> <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">display_info</span><span class="o">-&gt;</span><span class="n">pre_chip_disable_wait_ns</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">LL_GPIO_SetOutputPin</span><span class="p">(</span><span class="n">OLED_CS_SCK_MOSI_GPIO_PORT</span><span class="p">,</span> <span class="n">OLED_CS_PIN</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/AagsAags/stm32f103c8t6_u8g2_hw_spi">AagsAags/stm32f103c8t6_u8g2_hw_spi - Github</a><br />
<a href="https://www.izilzty.com/?post=15">在STM32上使用U8g2图形库并配合DMA发送显示数据（LL库） - izilzty的小窝</a></p>
</blockquote>

<h2 id="4-oled-菜单与动画">4. OLED 菜单与动画</h2>

<p>调完 FOC 之后开始不务正业了， 不过实现一个丝滑的 OLED 菜单确实帅得优雅， 也为之后做一个集成主控芯片以及按钮的 FOC 驱动板打下基础。 我在 B 站也找了一些参考， 目前来说 <a href="https://www.bilibili.com/video/BV1wA411o7VJ/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32 稚晖君丝滑菜单 - uYanki Bilibili</a> 的实现是比较符合我目前的工程需求的， 不过他提供的 <a href="https://github.com/uYanki/board-stm32f103rc-berial/tree/main/7.Example/hal/gui/u8g2/02_menu">menu</a> 的库的仓库还包含了一堆其他的东西， 真的是非常庞大。</p>

<p>我第一步想实现的就是简单的菜单动画， 但在查看他编写的代码的时候， 发现这些实现需要基于 easing 这个类。 于是， 我上网找了一圈， 发现这其实是一个补间动画相关类， <a href="https://easings.net/zh-cn">easings.net</a> 网站提供了基于各种缓动函数的动画样例， 非常直观清晰。 另外， tween.js 是有详细的文档说明的， 可以进行查阅。 为了移植方便， 我在网上找到了几个 C/C++ 版本的 tween.js 的实现， 参照这个 Up 的代码进行相关结构体的学习。</p>

<p>在我自己的工程里， 为了保证在 STM32F103 这类 Cortex-M3 内核的计算效率， 我会对 easing 的主体函数用 Qfplib-m3 库进行优化。</p>

<blockquote>
  <p><a href="https://easings.net/zh-cn">easings.net</a><br />
<a href="https://github.com/tweenjs/tween.js/blob/main/docs/user_guide_zh-CN.md">tween.js - wiki</a><br />
<a href="https://github.com/mobius3/tweeny">tweeny</a><br />
<a href="https://github.com/rynmth/ctween">ctween</a><br />
<a href="https://blog.csdn.net/siyacaodeai/article/details/113766006">C++实现缓动动画效果，使用Tween算法（含详细代码） - Coding14 CSDN</a>
<a href="https://www.jb51.net/article/135077.htm">tween.js缓动补间动画算法示例 - 李俊杰 脚本之家</a><br />
<a href="https://blog.csdn.net/S_clifftop/article/details/89490422">Tween动画及缓动函数 - S_clifftop CSDN</a></p>
</blockquote>

<h2 id="5-ina199x1-电流采样配置">5. INA199x1 电流采样配置</h2>

<p>这个配置是真的痛苦啊， 前后加起来快有一天了， 主要是对通过 TIM 定时器对 ADC 触发多通道转换这部分的含义不了解。 关于电流采样， 我设想通过 ADC1 完成多通道采样， 并通过定时器定时出发采样， 使用 DMA 对转换结果进行传输。 依据这个思路需要配置 TIM 的 PWM 以及 ADC 的外部触发。</p>

<p>在 STM32CubeMX 对 ADC 的配置中会看到 <code class="language-plaintext highlighter-rouge">External Trigger Conversion Source</code>， 这个配置网上说啥的都有， 当时我参照 B 站 Up 在 FOC 的配置中选择的 <code class="language-plaintext highlighter-rouge">Timer 2 Capture Compare 2 event</code> 照猫画虎， 配置完后发现根本没办法采到数据。 我发觉这个 Capture Compare 有点像比较器的输出部分， 而 TIM 中配置的则是 <code class="language-plaintext highlighter-rouge">PWM Generation No Output</code>， 这显然对不上。</p>

<p>后续参考尝试了很多代码， 最后在 <a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a> 看到了对这几个参数的相关解释， 发现只有 ADC1 仅对 TIM3 有一个 <code class="language-plaintext highlighter-rouge">Timer 3 Trigger Out event</code> 的选项。</p>

<ul>
  <li><strong>Regular Conversion launched by software:</strong> 规则的软件触发， 调用函数触发即可</li>
  <li><strong>Timer X Capture Compare X event:</strong> 外部引脚触发</li>
  <li><strong>Timer X Trigger Out event:</strong> 定时器通道输出触发， 需要设置相应的定时器设置</li>
</ul>

<p>根据 ADC 中的选项的字面意思， TIM3 中的 <code class="language-plaintext highlighter-rouge">Trigger Event Selection</code> 配置为 <code class="language-plaintext highlighter-rouge">Update Event</code>， 最后终于能采到数据了。</p>

<p>另外需要注意配置中的几个点：</p>

<ul>
  <li>DMA 配置需要在 ADC 配置之前。</li>
  <li>ADC 的外部触发需要定义为上升沿触发， 这一点可以在数据手册的 ADC 章节看到。 LL 库需要调用 <code class="language-plaintext highlighter-rouge">LL_ADC_REG_StartConversionExtTrig</code> 函数。</li>
  <li>PWM 有 Mode 1 和 Mode 2 两种， 分别表示计数器在达到 ARR 值之有为有效电平， 以及在达到 ARR 后为有效电平。 因而对于上升沿触发的要求， 需要配置 PWM 的极性为 Mode 1 为 Low， Mode 2 为 High。 这样， Mode 1 有效电平为 Low， 而 Mode 2 有效电平为 High， 均能达到上升沿的效果。</li>
  <li>
    <p>ADC 校准的代码如下所示， 需要注意结合不同的型号进行差异化配置。 F103 要求在校准之前开启 ADC， 并且需要等待 ADC 的电压稳定。</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//* start ADC1</span>
  <span class="n">LL_ADC_Enable</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="c1">// wait until internal voltage reference stable</span>
  <span class="n">delay_nus_72MHz</span><span class="p">(</span><span class="n">LL_ADC_DELAY_TEMPSENSOR_STAB_US</span><span class="p">);</span>

  <span class="c1">// wait at least 2 ADC cycles after ADC power-on but before calibration</span>
  <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="c1">// wait until ADC calibration done</span>
  <span class="n">LL_ADC_StartCalibration</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">LL_ADC_IsCalibrationOnGoing</span><span class="p">(</span><span class="n">ADC1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><a href="https://blog.51cto.com/u_520887/5290076">STM32F0使用LL库实现DMA方式AD采集</a><br />
<a href="https://codeantenna.com/a/1MnFm9oX2G">STM32L476多通道TIM+DMA+ADC采样（LL库）</a><br />
<a href="https://blog.51cto.com/u_15456236/4801335">STM32 定时器触发 ADC 多通道采集，DMA搬运至内存</a><br />
<a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a></p>
</blockquote>

<h2 id="6-速度环调试">6. 速度环调试</h2>

<p>力矩环在电压控制的情况下就是开环的， 因而测试过后就调力矩环的外环电流环。 电流环遇到一个问题就是给定速度后， 电机转到某个位置就会发生明显的卡顿情况， 视觉上的感受就是这个地方电机遇到了一个非常大的阻力停顿了一下， 这在速度为 <code class="language-plaintext highlighter-rouge">10 - 20 rad/s</code> 时非常明显， 整个电机都会因为这个卡顿而发生弹跳。 但一旦速度达到 <code class="language-plaintext highlighter-rouge">40 rad/s</code> 及以上之后， 这种卡顿因为速度的提升会转变为一种高频且轻微的抖动， jitter。</p>

<p>用 PI 控制器几乎没办法解决这个问题， 凑巧的是我到 SimpleFOC 的官方文档看了看， 我发现他们的速度环实际上是用 PID 控制器实现的， 其中微分 Kd 仅为 0.001 大小。 微分的作用就是应对控制量的快速变化， 意识到这一点后我认为速度环电机的电角度的快速变化很可能让 PI 控制器没办法以较快的响应速度稳定到需要控制的角度， 因而产生了控制的滞后， 这在电机上的表现就是卡顿与抖动。 尝试加入了微小的微分量后， 电机的速度环果然稳定了下来并且表现优异。</p>

<h2 id="7-位置环调试">7. 位置环调试</h2>

<h3 id="71-关于位置环的比例控制">7.1 关于位置环的比例控制</h3>

<p>位置环需要对输出到速度环的电机转速进行限制。 另外我发现用 PI 控制器的位置环始终存在着稳态误差， 我在知乎上看到一则解答：</p>

<p><em>当位置环下还有速度环时，速度和位置是对同一个刚体运动的不同数学描述，在物理上其实是同一个量。它们之间只存在严格的数学关系，并没有实际的物理过程。这就意味着位置是速度的积分这一模型是绝对精确的，因此不会产生稳态误差，自然也就不需要积分环节。</em></p>

<p>当然除了对位置环仅需要比例控制外， 这则回答还解释了为什么速度环和电流环都需要积分环节去调节其中的非线性环节。 根据这则回答的指导， 我将 PI 控制转为了 P 控制后， 位置环的稳态误差几乎不存在了。 但是， 位置环在误差及其微小的状态下仍驱动电机在工作， 我认为在 12-bits 的位置反馈下精度过大是没有必要的， 因而我对位置环还引入了一个 <strong>死区</strong>， 限制在误差为 0.05 rad 机械角度以下的情况让位置环的比例控制输出始终为零， 不仅能对电机与电机芯片进行保护， 还能避免电机在某些情况下因为调节精度问题而产生的抖动问题。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// P controller</span>
<span class="kt">float</span> <span class="nf">PID_angle</span><span class="p">(</span><span class="kt">float</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">proportional</span><span class="p">,</span> <span class="n">output</span><span class="p">;</span>

    <span class="c1">// If the 'err' is too small, I don't want the motor to adjust itself.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// u_p  = P *e(k)</span>
    <span class="n">proportional</span> <span class="o">=</span> <span class="n">qfp_fmul</span><span class="p">(</span><span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">pid</span><span class="p">.</span><span class="n">Kp</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">proportional</span><span class="p">;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">velocity_limit</span><span class="p">,</span> <span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">velocity_limit</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="72-位置环与速度环切换的电机跳动问题">7.2 位置环与速度环切换的电机跳动问题</h3>

<p>位置环和速度环切换出现电机的跳动， 也就是切换之后电机基于当前的状态值会产生转动速度， 本质上的原因就是前一个环的状态量没有处理妥当。 如下代码所示， 我是这样解决的：</p>

<ul>
  <li>位置传感器仿照电机初始化时的流程， 让当前的从位置传感芯片的 SPI 获取到的 <code class="language-plaintext highlighter-rouge">raw_angle_data</code> 赋值给 <code class="language-plaintext highlighter-rouge">raw_angle_data_prev</code>， 那么在调用 <code class="language-plaintext highlighter-rouge">get_angle</code> 的时候， 返回值会重新归零。</li>
  <li>获取转轴速度的时候是基于当前的角度以及与上次获取的角度差的， 因而重新更新 <code class="language-plaintext highlighter-rouge">angle_prev</code> 为当前的角度， 那么后续获取 <code class="language-plaintext highlighter-rouge">get_velocity</code> 的时候返回值就为零了， 那么电机的状态中的速度也就归零了。</li>
  <li>另外我们需要更新当前的机械角度值为 <code class="language-plaintext highlighter-rouge">get_shaft_angle</code>， 这是叠加上 Sensor Dir 的机械角度值， 本质上是调用了 <code class="language-plaintext highlighter-rouge">get_angle</code>， 此时的值也归零。</li>
  <li>最后设定位置环的目标位置 <code class="language-plaintext highlighter-rouge">target_angle</code> 为当前的机械角度， 这样就不产生位置误差， 位置环能保持静止。 另外直接设定速度环的 <code class="language-plaintext highlighter-rouge">target_speed</code> 为 0， 这样速度环也没有速度量的输出。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">encoder_reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotation_turns_angles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">raw_angle_data_prev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">read_raw_angle</span><span class="p">();</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">angle_prev</span> <span class="o">=</span> <span class="n">get_angle</span><span class="p">();</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_speed</span> <span class="o">=</span> <span class="n">get_velocity</span><span class="p">();</span> <span class="c1">// must be zero</span>
    <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span> <span class="o">=</span> <span class="n">get_shaft_angle</span><span class="p">();</span>
    <span class="c1">// Set current shaft angle as the target angle.</span>
    <span class="c1">// So the motor can stop after motion mode being switched.</span>
    <span class="n">g_ang_ctrl</span><span class="p">.</span><span class="n">target_angle</span> <span class="o">=</span> <span class="n">g_foc</span><span class="p">.</span><span class="n">state_</span><span class="p">.</span><span class="n">shaft_angle</span><span class="p">;</span>
    <span class="n">g_vel_ctrl</span><span class="p">.</span><span class="n">target_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外需要注意， Sensor Dir 对机械方向的判断需要保留， 2023-07-30 晚上拆了一下设备重新装上之后， 突然转不起来了。 第二天早上 checkout 到之前的版本， 发现引入位置反馈都转不起来， 发现是 CW 和 CCW 没有设置对， 导致机械角度的方向和电角度方向不一致， 因而电机无法正常旋转。</p>

<blockquote>
  <p><a href="https://www.zhihu.com/question/294695335/answer/493495590">为什么伺服驱动器位置环只有比例控制? - 全力的一度狐的回答 知乎</a></p>
</blockquote>

<h2 id="8-电流环调试">8. 电流环调试</h2>

<p>电流环调试感觉非常困难， 目前没有彻底解决问题。 最开始发现电流环给出的反馈波形非常奇怪， Q 和 D 两轴的波形竟然都是带截止的。 后来一路查到 ADC 转换出来的值， 发现是 A 相的电流采样芯片的放大倍数以及中心点都发生了严重偏移， 更换芯片后两路采样都重新回到了 1.65 V 的参考电压在以正弦波波形在波动。</p>

<p>当时实际调试的时候， 设定 \(^{Q}K_{p}\) 和 \(^{D}K_{p}\) 的值为 0.6 的时候， 转矩设定为 0.6 以上电机才能够平稳旋转， 而这也直接导致套上速度环和位置环后， 在误差较小时电机的运行是不平稳的， 会产生抖动。 我原来想通过 Ki 弥补稳态误差， 但这个给定值非常难找， 经常导致电流环出现不收敛而发生电机转速疯狂飙升的情况。 目前暂时没有解决电流环的调试问题。</p>

<h2 id="x-stm32-ll-库配置踩坑">X. STM32 LL 库配置踩坑</h2>

<p>在网上搜了一番发现 STM32 用 LL 库开发的效率和配置寄存器差不多， HAL 库的封装太多层了， 虽然移植性比较好但效率显著低于 LL 库。 但是， LL 库资源少而且有坑， 不过对于爱折腾的人以及从 51 那套开始习惯读寄存器的人而言， 倒也不是太大的问题。</p>

<h3 id="x1-debug">X.1 Debug</h3>

<p>CubeMX 中的 <code class="language-plaintext highlighter-rouge">SYS</code> 需要配置 <strong>Serial Wire</strong> 才能用 stlink-v2 进行调试。 但是我实际测试用 vscode 的 cortex-debug 插件， 开启这个设置会导致调试偏移到很奇怪的地方， 反倒是不用开也能调试。</p>

<h3 id="x2-tim1-配置-pwm-输出">X.2 TIM1 配置 PWM 输出</h3>

<p>LL 库通过 STM32CubeMX 生成的 TIM1 基础配置存在一定的问题。 见 <code class="language-plaintext highlighter-rouge">Core/Src/tim.c</code> 中对 <code class="language-plaintext highlighter-rouge">Prescaler</code> 以及 <code class="language-plaintext highlighter-rouge">Autoreload</code> 的配置， 会把 <code class="language-plaintext highlighter-rouge">36 - 1</code> 配置成 <code class="language-plaintext highlighter-rouge">36 - LL_TIM_IC_FILTER_FDIV1_N2</code> 怀疑这个与 CubeMX 不支持配置中运算有关系。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Core/Src/tim.c</span>
<span class="kt">void</span> <span class="nf">MX_TIM1_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Prescaler</span> <span class="o">=</span> <span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Autoreload</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 要使能 TIM1 的输出， <code class="language-plaintext highlighter-rouge">LL_TIM_CC_EnableChannel</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableCounter</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableAllOutputs</code> 这几条函数必须逐个使用， 具体含义可以参考 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj4k_zr4ZWAAxUKAt4KHS_0D60QFnoECBwQAQ&amp;url=https%3A%2F%2Fwww.st.com%2Fresource%2Fen%2Fuser_manual%2Fum1850-description-of-stm32f1-hal-and-lowlayer-drivers-stmicroelectronics.pdf&amp;usg=AOvVaw1DzMCa42sT0JPpOP1EH-0j&amp;opi=89978449">ST - Description of STM32F1 HAL and low-layer drivers</a></p>

<blockquote>
  <p><a href="https://www.cnblogs.com/yhpbook/p/yhp_stm32_tim.html">关于STM32CubeMX使用LL库设置PWM输出</a></p>
</blockquote>

<h3 id="x3-spi">X.3 SPI</h3>

<p>需要增加 <code class="language-plaintext highlighter-rouge">LL_SPI_Enable</code> 函数使能相关的 SPIx 设备。</p>

<p>另外发现一个问题， SPI 的收发需要共用一个函数（纯发送不用， 我在 OLED 中测试过）， 这是因为 SPI 从机没有自己的 SCLK 时钟， 这就需要主机提供。 而双工 SPI 的接收和发送是用两套缓存空间的， 因而可以通过主机向从机发送相应的字节提供 SCLK 时钟， 才能进行同步进行数据接收。 因而， 磁编码器的 SPI 接收函数是这样的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">spi2_transmit_rw</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">outdata</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// wait until the SPI Tx buffer to be empty</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">LL_SPI_TransmitData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">,</span> <span class="n">outdata</span><span class="p">);</span>
    <span class="c1">// wait for 16 bits data receiving complete</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_RXNE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">LL_SPI_ReceiveData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可算是懂了为什么磁编码器的数据手册里面 MOSI 是全 0 的数据了。 不过忘记买磁铁了， 调了半个晚上以为电机轴承那边是有磁性的， 结果一直读到 error 的数据， 后来问了好兄弟才知道那块地方是钢， 他推荐我实现 <strong>无感 FOC</strong>， 外贴磁铁会影响电机的磁场可能会有问题。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_42832780/article/details/96424775">STM32 SPI发送与接收用一个函数实现的问题 - VX13260562029 CSDN</a></p>
</blockquote>

<h3 id="x4-dma">X.4 DMA</h3>

<p>DMA 的配置需要在任何主配置， 如 USART， SPI 这些配置之前完成， 当时 USART 接收有问题， 看网上资料把 DMA 的配置放到了 USART 配置之前就解决问题了。</p>

<h4 id="x41-usart-dma">X.4.1 USART DMA</h4>

<p>USART 的 DMA 开启有几个 LL 库的函数需要注意：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Enable DMA Mode for reception</span>
<span class="n">LL_USART_EnableDMAReq_RX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
<span class="c1">// Enable DMA Mode for transmission</span>
<span class="n">LL_USART_EnableDMAReq_TX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
</code></pre></div></div>

<p>除此之外， 对于配置了 <code class="language-plaintext highlighter-rouge">NORMAL</code> 类型的 DMA 传输， 需要在下一次 DMA 传输开启之前重新配置 <strong>传输的内存地址</strong> 以及 <strong>传输的数据大小</strong>。 值得注意的是， 在配置之前需要 <strong>失能</strong> 相关的 DMA 通道， 另外 <strong>传输的数据大小</strong> 和该传输方向定义的数据宽度相关。 也就是说， 如果此时我定义了 DMA 从外设到内存的传输数据宽度为 <code class="language-plaintext highlighter-rouge">Byte</code>， 那么这个传输的数据大小若设置为 4 则表示传输 4 个字节。 若定义的数据宽度为 <code class="language-plaintext highlighter-rouge">HalfWord</code>， 则传输的数据大小为 4 表示传输 4 个半字 （2 个字节）。</p>

<h3 id="x5-重定向-printf">X.5 重定向 printf</h3>

<p>还得是知乎大佬 <a href="https://zhuanlan.zhihu.com/p/369380259">STM32用gcc编译printf重定向到串口 - gyx鑫 知乎</a> 这篇文章， 除了如下更改还需要在串口初始化的时候调用 <code class="language-plaintext highlighter-rouge">setvbuf(stdout, NULL, _IONBF, 0)</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">__io_putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_USART_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">LL_USART_TransmitData8</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd</span><span class="p">;</span> <span class="c1">// avoid unused warning</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__io_putchar</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="x6-printf-浮点输出">X.6 printf 浮点输出</h3>

<p>但是这种办法还不能输出 float 浮点数， 这是因为 STM32 默认是关闭浮点输出的， STM32 社区论坛有一条帖子说明， 通过如下链接指令打开 GCC 中的浮点打印的编译。 但是， 我自己测试之后还是无法输出 float 类型， 即便将优化等级调整为 <code class="language-plaintext highlighter-rouge">-O0</code>。</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">add_link_options</span><span class="p">(</span>LINKER:-u _printf_float<span class="p">)</span>
</code></pre></div></div>

<p>尝试了很多办法， Vofa+ 上位机程序应该对接收进行了解析所以才能输出 float 类型数据， 直接通过串口一个个发 4 bytes 的 float 还得自己去转换太麻烦了， 干脆就转成整数相关类型输出算了。</p>

<p><em><strong>2023-08-04 UPDATE:</strong></em> 这个编译选项还是需要打开的， 我后来在 OLED 中使用 <code class="language-plaintext highlighter-rouge">sprintf</code> 做浮点数转义的时候， 如果不开启这个编译选项是无法成功将 float 类型转为字符串类型的。</p>

<blockquote>
  <p><a href="https://community.st.com/t5/stm32-mcu-products/printf-and-float/td-p/108690">printf and float - ST Community</a><br />
<a href="https://community.st.com/t5/stm32cubeide-mcu/how-to-use-float-in-printf/td-p/323872/page/2">how to use float in printf? - ST Community</a><br />
<a href="https://stackoverflow.com/questions/28746062/snprintf-prints-garbage-floats-with-newlib-nano">snprintf() prints garbage floats with newlib nano - StackOverflow</a>\</p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 驱动板开发的记录， 涉及 STM32 配置， 所用器件， 以及相关通信协议。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 8</title><link href="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 8" /><published>2023-07-15T00:00:00+08:00</published><updated>2023-07-15T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/15/rcore-note-ch8</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html"><![CDATA[<blockquote>
  <p>这个章节整理完 Tutorial 还有一个与 I/O 设备管理相关的第九章， 准备之后慢慢琢磨然后不断扩展内核功能， 连续一个月高强度 rCore 的学习心理上有些浮躁了。 最近想把多年未竟的 FOC 项目捡起来好好研究一下， 顺带用上 FreeRTOS 用另一个角度看 OS。</p>
</blockquote>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第八章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/">[ch8]</a> <code class="language-plaintext highlighter-rouge">TODO</code></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-thread-coroutine-os">1. Thread Coroutine OS</h2>

<p>Thread Coroutine OS 增加了在用户态管理的用户态线程/用户态协程， 以及在内核态管理的用户态线程。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/thread-coroutine-os-detail.png" alt="Thread Coroutine OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Thread Coroutine OS details, rCore</u></font>
</div>

<h3 id="11-线程">1.1 线程</h3>

<p><strong>线程</strong> 能够将一个进程内多个可并行执行的任务通过能细粒度的方式被操作系统调度， 实现进程内的并发执行。 进程是线程的资源容器， 线程成为了程序的基本执行实体。 一个进程可以包含多个线程， 同属于一个进程的线程能够共享进程的资源， 如地址空间， 文件等。 线程基本上由线程ID、 执行状态、 当前指令指针(PC)、 寄存器集合和栈组成。</p>

<p>线程能被操作系统或用户态调度器独立调度（Scheduling）， 分派（Dispatch）， 执行（Perform）， 并且由于同一个进程下多个线程同属于一块地址空间并共享资源， 相比较进程之间的 IPC 机制通信， 线程可以通过 <strong>共享内存</strong> 进程数据交互， 之前在做 CUDA 课程的大作业的时候深有感触， 用好线程 <strong>归约</strong> 能让计算效率几何倍提升。</p>
<blockquote>
  <p>基于 CUDA 语言的热扩散仿真模型： <a href="https://github.com/HangX-Ma/CUDA-HeatTransfer-3D">CUDA-HeatTransfer-3D</a>， 有兴趣的同学可以看看 <em>CUDA By Example</em> 这本书了解 CUDA 并行计算。</p>
</blockquote>

<p>但线程最大的问题就是需要 <strong>保持共享资源数据一致性</strong>， 修改数据可能会因为多个线程执行顺序的不可预知而产生 <strong>竞态条件（Race Condition）</strong>， 这是调度的不可控导致的， 而进程独享一片地址空间而不会与其他进程产生数据的地址交叉， 虽然也会被操作系统调度， 但不会遇到这样的问题。</p>

<p>为了解决访问与改写共享资源带来的问题， 操作系统需要提供一些保障机制， 如 <strong>互斥锁（Mutex Lock）</strong>， <strong>信号量（Semaphore）</strong>， <strong>条件变量（Condition Variable）</strong> 等， 这也是这个章节 rCore 所需要解决的第二个问题 —— 为线程提供上述保障。</p>

<h3 id="12-用户态的线程管理">1.2 用户态的线程管理</h3>

<p>用户态的线程管理不受操作系统的约束， 这种线程一般被称为 <strong>Green Threads</strong>， 这与协作式调度非常类似， 线程的管理权限全都交由用户。 rCore 这样设计了线程的基本结构：</p>

<ul>
  <li><strong>线程 ID</strong>： 用以标识与区分不同的线程。</li>
  <li><strong>执行状态</strong>： 同样分为 <strong>空闲（Available）</strong>， <strong>Ready（就绪）</strong>， 以及 <strong>Running（正在执行）</strong>。</li>
  <li><strong>栈</strong>： 为分配每个线程的运行函数栈。</li>
  <li><strong>上下文</strong>： 根据 RISC-V 的函数调用约定需要保存 Callee 寄存器， 同时需要保存 PC 指针以保证执行地址的正常切换。</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>            <span class="c1">// 线程ID</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>       <span class="c1">// 栈</span>
    <span class="n">ctx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>     <span class="c1">// 当前指令指针(PC)和通用寄存器集合</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span>         <span class="c1">// 执行状态</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">TaskContext</span> <span class="p">{</span>
    <span class="c1">// 15 u64</span>
    <span class="n">x1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//ra: return address，即当前正在执行线程的当前指令指针(PC)</span>
    <span class="n">x2</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//sp</span>
    <span class="n">x8</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s0,fp</span>
    <span class="n">x9</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s1</span>
    <span class="n">x18</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//x18-27: s2-11</span>
    <span class="n">x19</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">x27</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">nx1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//new return address, 即下一个要执行线程的当前指令指针(PC)</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">Available</span><span class="p">,</span> <span class="c1">// 初始态：线程空闲，可被分配一个任务去执行</span>
    <span class="n">Running</span><span class="p">,</span>   <span class="c1">// 运行态：线程正在执行</span>
    <span class="n">Ready</span><span class="p">,</span>     <span class="c1">// 就绪态：线程已准备好，可恢复执行</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 对用户态的线程管理通过如下几个函数完成：</p>

<ul>
  <li><strong>线程初始化</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::new</code>： 创建当前处于 <code class="language-plaintext highlighter-rouge">Running</code> 的一个主线程， 并将剩余的线程资源初始化为 <code class="language-plaintext highlighter-rouge">Available</code> 以向量的形式存储在 <code class="language-plaintext highlighter-rouge">Runtime</code> 结构体中方便后续的资源线程创建和管理。</li>
      <li><code class="language-plaintext highlighter-rouge">Runtime::init</code>： 传递 Runtime 对象的地址至全局变量 <em>RUNTIME</em>， 方便其他函数获取相应的资源线程。</li>
    </ul>
  </li>
  <li><strong>线程创建</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::spawn</code>： 在存储线程资源的向量中查找一个状态为 <code class="language-plaintext highlighter-rouge">Available</code> 的空闲线程， 为调度准备 <em>old return address</em> 以及 <em>new return address</em> 并分配新的空间并设置栈顶的位置， 在返回前将该线程状态设置为 <code class="language-plaintext highlighter-rouge">Ready</code>。
        <blockquote>
          <p>实际上这里的 <em>old return address</em> 被设置为了 <code class="language-plaintext highlighter-rouge">guard</code> 函数的地址， 该函数内部调用了 <code class="language-plaintext highlighter-rouge">t_return</code> 将当线程的状态重新设置为 <code class="language-plaintext highlighter-rouge">Available</code> 后会调用 <code class="language-plaintext highlighter-rouge">t_yield</code> 进行线程的切换。 这种设计的作用在讲述 <strong>线程切换</strong> 后再详细说明。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>线程切换</strong>
  线程切换应当是调度中最重要的一个模块， 主要功能由 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 以及 <code class="language-plaintext highlighter-rouge">switch</code> 这两个函数提供。 之前提及的 <code class="language-plaintext highlighter-rouge">Runtime::t_return</code>， <code class="language-plaintext highlighter-rouge">Runtime::guard</code> 以及 <code class="language-plaintext highlighter-rouge">Runtime::yield_task</code> 都封装了 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 以完成相应的调度的功能。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::t_yield</code>： 从当前位置开始查找一个状态为 <code class="language-plaintext highlighter-rouge">Ready</code> 的线程， 没找到会返回 false。 如果当前的线程不是 <code class="language-plaintext highlighter-rouge">Available</code>（说明在 <code class="language-plaintext highlighter-rouge">Running</code>） 就将当前的线程重新放到 <code class="language-plaintext highlighter-rouge">Ready</code> 数组中， 另外就是将找到的 <code class="language-plaintext highlighter-rouge">Ready</code> 线程切换为 <code class="language-plaintext highlighter-rouge">Running</code>。 最后调用 <code class="language-plaintext highlighter-rouge">switch</code> 交换新旧线程的上下文。</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">switch</code>： 完成对 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 未进行切换的 <em>当前指令指针(PC)、 通用寄存器集合和栈</em> 的切换， 关键的任务切换在于如何对 PC 指针进行切换。 <code class="language-plaintext highlighter-rouge">x1(ra)</code> 寄存器保存着当前 <code class="language-plaintext highlighter-rouge">switch</code> 函数的返回地址， rCore 设计从 offset 为 0x00 到 0x68 的寄存器都按序存储， 其中也包括了 <code class="language-plaintext highlighter-rouge">ra</code>。 而在 offset 0x70 的位置又存储了一次 <code class="language-plaintext highlighter-rouge">ra</code>， 其作用也很明显， 后续 <code class="language-plaintext highlighter-rouge">ld t0, 0x70(a1)</code> 这句指令载入了新的 Context 中的 <code class="language-plaintext highlighter-rouge">ra</code>， 通过 <code class="language-plaintext highlighter-rouge">jr t0</code> 就能在 switch 之后直接跳转到新的指令运行的位置。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[naked]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">switch</span><span class="p">(</span><span class="n">old</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// a0: _old, a1: _new</span>
    <span class="nd">asm!</span><span class="p">(</span>
        <span class="s">"
        sd x1, 0x00(a0)
        ...
        sd x1, 0x70(a0)

        ld x1, 0x00(a1)
        ...
        ld t0, 0x70(a1)

        jr t0
    "</span><span class="p">,</span>
        <span class="nf">options</span><span class="p">(</span><span class="n">noreturn</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>线程执行</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::run</code>： 用一个 while 循环调用 <code class="language-plaintext highlighter-rouge">t_yield</code> 进行调度， 所有线程执行完后会退出。</li>
    </ul>
  </li>
</ul>

<p>从整体的 rCore 线程设计可以看出， 线程的调度几乎就是按序执行， 所以 <code class="language-plaintext highlighter-rouge">Runtime::spawn</code> 会放入一个 <code class="language-plaintext highlighter-rouge">guard</code> 函数地址作为 <em>old return address</em> 以释放线程资源， 因为当下一次线程位置又切换到这个线程的时候， 实际上该线程已处理完了。 这个设计只能等当前运行的线程主动让出处理器使用权后， 线程管理运行时才能切换检查。</p>

<p>具体实现细节不表了， rCore 在 <code class="language-plaintext highlighter-rouge">user/src/bin/ch8b_stackful_coroutine.rs</code> 中实现了对用户态的线程管理。</p>

<h3 id="13-内核态的线程管理">1.3 内核态的线程管理</h3>

<p>内核态的线程管理扩展了时钟中断， 能基于时钟中断来直接打断当前用户态线程的运行， 实现对线程的调度和切换等。 rCore 在该章节对进程的结构进行了细化， 通过线程来表示对处理器的虚拟化， 使得进程成为了管理线程的容器。 虽然没有父子关系， 但多个线程中的第一个创建的线程一般被称为主线程， 并被分配 0 号进程标识符（TID）。</p>

<p>除了主线程仍然是从程序入口点开始执行， 其余的 <strong>线程的生命周期都与一个函数进行一次绑定</strong>， 从这个角度而言， 主线程其实和进程的声明周期绑定了。</p>

<p>除了具备前述用户态线程的基本特性， rCore 设计的线程模型额外具备如下功能：</p>

<ul>
  <li>线程有三种状态：就绪态、 运行态和阻塞态（阻塞这个知识点解答了我对 poll 函数的疑惑！）；</li>
  <li>线程可以被操作系统调度以分时占用 CPU；</li>
  <li>线程可动态创建与退出；</li>
  <li>线程能通过系统调用获得操作系统的服务， 但 <strong>进程系统调用</strong> 和 <strong>线程系统调用</strong> 不能混用。</li>
</ul>

<blockquote>
  <p>rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html">线程模型与重要系统调用</a> 章节对理解线程模型和设计非常关键。</p>
</blockquote>

<h4 id="131-线程系统调用">1.3.1 线程系统调用</h4>

<ul>
  <li>
    <p><strong>线程创建</strong> 的系统调用 <code class="language-plaintext highlighter-rouge">sys_thread_create</code> 通过 <strong>TID(Thread Identifier)</strong> 区分不同线程， 与进程的 PID 设计很类似， 内核会为每个线程分配专属资源： 用户栈、 Trap 上下文还有内核栈， 前两个在进程地址空间中， 内核栈在内核地址空间中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_thread_create</span><span class="p">(</span><span class="n">entry</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong>线程管理</strong> 通过 TID， <code class="language-plaintext highlighter-rouge">gettid</code> 系统调用能获取当前线程的 TID。</li>
  <li><strong>线程退出</strong> 通过 <code class="language-plaintext highlighter-rouge">exit</code> 系统调用完成， 约定线程从绑定的函数返回的时候都需要调用 <code class="language-plaintext highlighter-rouge">exit</code> 通知操作系统进行资源回收， 更细粒度的线程取代了进程的作为操作系统的调度单元。</li>
  <li><strong>线程资源回收</strong> 通过 <code class="language-plaintext highlighter-rouge">waittid</code> 回收收线程占用的用户态和内核态资源。 这个工作一般是进程/主线程完成， 但若是 <strong>主线程</strong> 调用了 <code class="language-plaintext highlighter-rouge">exit</code> <strong>其子线程</strong> 都会全部退出， 被 <strong>父进程</strong> 回收资源。</li>
</ul>

<p>rCore 之前描述的线程模型提到不能混用进程和线程的系统调用， 原因在于其设计对线程和进程进行了分离。 若是调用了 <code class="language-plaintext highlighter-rouge">sys_thread_create</code> 生成子线程就只考虑多个线程在一个进程内的交互， 如果涉及到父子进程的交互， 就等价为进程模型。</p>

<h4 id="132-软硬件资源管理">1.3.2 软硬件资源管理</h4>

<p>主要干了三件事儿。</p>

<ol>
  <li>
    <p>把原来分配 PID 的数据结构用更通用的 <code class="language-plaintext highlighter-rouge">RecycleAllocator</code> 描述， 能为 PID 以及 TID 分配提供描述结构。 PID 的分配还是延续之前章节， 使用 <code class="language-plaintext highlighter-rouge">PID_ALLOCATOR</code> 这个全局变量。 而线程归属于进程容器， 所以在每个进程控制块的内部可变结构 <code class="language-plaintext highlighter-rouge">ProcessControlBlockInner</code> 中占据一个变量位置， 由进程控制块 <code class="language-plaintext highlighter-rouge">ProcessControlBlock</code> 进行管理。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/process.rs</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
     <span class="c1">// immutable</span>
     <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
     <span class="c1">// mutable</span>
     <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="p">}</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除了 TID 之外， 每个线程都有自己独立的用户栈和 Trap 上下文， 且它们在所属进程的地址空间中的位置可由 TID 计算得到。 新的进程地址空间如下所示：</p>

    <div align="center">
     <img src="/norobots/images/2023-07-15-rcore-note-ch8/app-as-full-with-threads.png" alt="Process address space with threads, rCore" width="600" />
     <br />
     <font size="2" color="#999"><u>Process address space with threads, rCore</u></font>
 </div>

    <p>这个就和第三章的结构非常类似了， 为此 rCore 提供了 <code class="language-plaintext highlighter-rouge">trap_cx_bottom_from_tid</code> 以及 <code class="language-plaintext highlighter-rouge">ustack_bottom_from_tid</code> 这两个函数索引每个线程的用户栈以及 Trap 上下文的具体位置。</p>
  </li>
  <li>
    <p>线程资源整合 <code class="language-plaintext highlighter-rouge">TaskUserRes</code>， 将线程的 TID 、用户栈和 Trap 上下文与线程打包， 由于声明周期一致， 能够进行统一的资源分配和回收。</p>
  </li>
  <li>
    <p>内核栈不再与 PID 或 TID 挂钩， 而与 <code class="language-plaintext highlighter-rouge">kstack_id</code> 这个新的内核标识符相关。 需要增加一个 <code class="language-plaintext highlighter-rouge">KSTACK_ALLOCATOR</code> 的通用资源分配器对内核标识符进行分配。</p>
  </li>
</ol>

<h4 id="133-进程和线程控制块">1.3.3 进程和线程控制块</h4>

<p>对进程和线程两块资源进行分离， 线程已经成为了 CPU 资源的调度单位， 因而与代码执行相关的内容则分配至 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">process</span><span class="p">:</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kstack</span><span class="p">:</span> <span class="n">KernelStack</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">res</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TaskUserRes</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">trap_cx_ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>进程控制块中则保留进程内所有线程共享的资源：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/process.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">is_zombie</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">memory_set</span><span class="p">:</span> <span class="n">MemorySet</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">fd_table</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">File</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tasks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
    <span class="o">...</span> <span class="c1">// 其他同步互斥相关资源</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="134-结语">1.3.4 结语</h4>

<p>任务管理器 <code class="language-plaintext highlighter-rouge">TaskManager</code> 与处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 仅在接口上有所改变。 线程相关的数据结构的实现可以直接阅读 rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html#id19">线程管理机制的设计与实现</a> 章节因而不赘述了。 若是从 chapter7 过渡到 chapter8， 到此时的改写还不足以支撑操作系统的正常运行， 还需添加线程管理的相关机制。</p>

<h2 id="2-sync-mutex-os">2. Sync Mutex OS</h2>

<p>Sync Mutex OS 增加了 <strong>互斥锁（Mutex）</strong>、 <strong>信号量（Semaphore）</strong> 和 <strong>条件变量（Condvar）</strong> 这三种资源， 并提供了与这三种同步互斥资源相关的系统调用。 这样多线程应用就可以使用这三种同步互斥机制来解决各种同步互斥问题， 如生产者消费者问题、 哲学家问题、 读者写者问题等。 在完成对操作系统的线程改写之后， 其实就遇到了引入线程带来的共享资源的访问问题， Thread Coroutine OS 与 Sync Mutex OS 耦合关系较强， 后者是前者功能性的延续。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/syncmutex-os-detail.png" alt="Sync Mutex OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Sync Mutex OS details, rCore</u></font>
</div>

<p>共享资源 (Shared Resources) 是多个线程均能够访问的资源， 线程对于共享资源进行操作的那部分代码被称为 <strong>临界区 (Critical Section)</strong>， 多线程访问共享资源要求这种访问是互斥的。 这与 Rust 的引用是非常类似的， 可变引用只能同时间有一个， 这是因为改引用具备 <strong>写权限</strong>， 而不可变引用仅有 <strong>读权限</strong>， 可以说， <strong>写操作</strong> 才是导致共享资源需要互斥访问的根源。</p>

<p>现代指令集架构提供了 <strong>原子指令(Atomic Instruction)</strong> 保护单内存位置的简单操作， 原子指令涉及到数据的 <strong>读，改，写</strong>， 只是将临界区的范围缩小为一条指令， 这意味着原子指令无法被打断， 这是由硬件层面提供相应的保障。 但对于复杂的数据结构， 简单的原子指令就无能为力了。</p>

<h3 id="21-互斥锁">2.1 互斥锁</h3>

<p><em>锁</em> 是附加在一种共享资源上的一种标记， 具有 <strong>上锁</strong> 和 <strong>空闲</strong> 这两种状态。 对共享资源的访问采用锁的机制后， 在进入临界区之前需要获取锁， 之后再访问临界区的共享资源， 在离开临界区时释放锁， 这三个步骤中如何获取锁是关键。 rCore 用以下指标权衡锁的实现：</p>

<ol>
  <li><strong>忙则等待：</strong> 当一个线程占有锁之后也就占有了共享资源， 其他线程必须等待该线程释放锁才能有机会获取锁， 以进入临界区。</li>
  <li><strong>空闲则入：</strong> 资源空闲且有线程尝试进入临界区， 则操作系统能在一定时间内选择一个线程。</li>
  <li><strong>有界等待：</strong> 要求每个线程在较大时间尺度上对锁的占有是公平的， 每个线程都有获取锁的机会而不会因为获取不到锁进入 <strong>饥饿(Starvation)</strong> 态。</li>
</ol>

<h4 id="211-软件锁的尝试">2.1.1 软件锁的尝试</h4>

<p>rCore 尝试在用户态通过软件的办法实现锁， 如下代码所示尝试使用 <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 这个全局变量表示锁。 可以看到没有获取到锁之前 CPU 会在 while 循环内忙等， 这种策略被称为 <strong>自旋</strong>， 在正确的实现中自旋锁会保证该过程不会被操作系统的调度打断。 在单核操作系统上， 自旋会造成极大的资源浪费， 在分配的一个时间片中， 第一次执行判断后陷入自旋， 由于没有外部量对这个判断条件中的数据进行更改， 自旋的条件始终成立， 相当于这个时间片都会被自旋所浪费。</p>

<p>在该实现中， <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 实际成了一种共享资源， 操作系统可以随时打断当前线程的运行调度到另一个线程， 可以发现这样一种情况： T0 线程发现 <code class="language-plaintext highlighter-rouge">OCCUPIED = false</code> 后准备将 <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 修改为 <code class="language-plaintext highlighter-rouge">true</code> (5 - 6 行之间)， 此时突然被操作系统打断调度到 T1 线程， 会导致 T1 也认为其具备进入临界区的权限进而尝试修改 <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 的值。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// user/src/bin/adder_simple_spin.rs</span>
<span class="k">static</span> <span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="nd">vload!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">OCCUPIED</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">OCCUPIED</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">OCCUPIED</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了解决这个问题， rCore 详细介绍了适用于单核的 Peterson 多标记算法保证两个线程之间的互斥访问， 除此之外还有适用双线程的 Dekkers 算法， 以及多线程的 Eisenberg &amp; McGuire 算法。 但这些算法都具有时代的局限性， 在当前多核系统上使用需要付出极大的资源代价， 并且还很难理解。</p>

<h4 id="212-硬件锁机制">2.1.2 硬件锁机制</h4>

<p>事实上， 硬件层面为我们提供了锁的机制的支持， 包括 <strong>关闭中断</strong> 与 <strong>原子指令</strong>。</p>

<p><strong>关闭中断</strong> 在 MCU 裸机环境下经常会用到， 操作系统的抢占式调度是由时钟中断触发， 因而关闭中断能够防止线程在临界区被操作系统调度。 但是， 下放中断权限可能导致恶意的用户资源占用（恶意永久关闭中断）； 且对于 RISC-V 多特权级架构而言， 用户态对 S-Mode 和 M-Mode 的中断修改会导致异常； 另外， 关闭中断在多核 CPU 上仅仅是关闭了当前 CPU 的中断， 并不能阻止其他 CPU 的线程进入临界区。</p>

<p><strong>原子指令</strong> 在之前提到过， 它的执行无法被操作系统打断， <strong>原子指令是整个计算机系统中最根本的原子性和互斥性的来源</strong>。 比较常见的指令有 <strong>CAS（Compare-And-Swap）</strong> 以及 <strong>TAS（Test-And-Set）</strong>。 这两条是我之前一直没太理解的， 还有 RISC-V 的 <strong>（Load Reserved / Store Conditional） LR/SC</strong> 原子指令， rCore 对此解释的非常清晰。</p>

<ul>
  <li><strong>CAS（Compare-And-Swap）：</strong> 其基本用法是 <code class="language-plaintext highlighter-rouge">CAS rd, rs1, rs2, rs3</code>， <code class="language-plaintext highlighter-rouge">rs1</code> 中是内存存放的某个值 <em>source</em>， 这个值会与 <code class="language-plaintext highlighter-rouge">rs2</code> 中的 <em>expected</em> 值进行比较， 若 <em>source == expected</em> 则将 <code class="language-plaintext highlighter-rouge">rs1</code> 的值替换为 <code class="language-plaintext highlighter-rouge">rs3</code> 中的 <em>new</em> 值。 <code class="language-plaintext highlighter-rouge">rs1</code> 最开始存储的 <em>source</em> 值会被存入 <code class="language-plaintext highlighter-rouge">rd</code> 目标寄存器， 这不受比较结果影响。
    <blockquote>
      <p>具体的使用例程可以参考 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/2lock.html#cas-tas">常用的 CAS 和 TAS 指令</a> 部分 <code class="language-plaintext highlighter-rouge">adder_atomic.rs</code> 部分。</p>
    </blockquote>
  </li>
  <li>
    <p><strong>TAS（Test-And-Set）：</strong> 其基本用法是 <code class="language-plaintext highlighter-rouge">TAS rd, rs1, rs2</code>， <code class="language-plaintext highlighter-rouge">rs1</code> 中是内存存放的某个值 <em>source</em>， 他会被直接设置为 <code class="language-plaintext highlighter-rouge">rs2</code> 中的 <em>expected</em> 值， 而 <code class="language-plaintext highlighter-rouge">rd</code> 返回 <code class="language-plaintext highlighter-rouge">rs1</code> 中原来的 <em>source</em> 值。 这个设计也能实现自旋锁， 以如下伪代码为例， 如果有多个线程执行 TAS 原子指令， 仅有一个线程的输入 <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 的值为 0， 那么 TAS 返回会为 0， 该线程就能退出循环进入后续的临界区， 而其他的线程只会看到 <code class="language-plaintext highlighter-rouge">OCCUPIED</code> 值为 1 而陷入 while 的自旋中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static</span> <span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">lock</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="nf">TAS</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">OCCUPIED</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>LR（Load Reserved）：</strong> 其基本用法是 <code class="language-plaintext highlighter-rouge">LR rd, rs1</code>， 将 <code class="language-plaintext highlighter-rouge">rs1</code> 内存中存放的值写入 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器中。 该指令不能单独使用， 需要配合 SC 指令。</p>
  </li>
  <li><strong>SC（Store Conditional）：</strong> 其基本用法是 <code class="language-plaintext highlighter-rouge">SC rd, rs1, rs2</code>， 将 <code class="language-plaintext highlighter-rouge">rs1</code> 的值 <em>source</em> 修改为 <code class="language-plaintext highlighter-rouge">rs2</code> 中存放的 <em>new</em> 值， 若修改成功 <code class="language-plaintext highlighter-rouge">rd</code> 返回 0， 否则 <code class="language-plaintext highlighter-rouge">rd</code> 返回任意值。 修改的前提是 LR 和 SC 指令之间， 之前 LR 指令中 <code class="language-plaintext highlighter-rouge">rs1</code> 内存的值没有改变， 这通过 RISC-V 框架下的 <strong>保留集（Reservation Set）</strong> 进行判断。</li>
</ul>

<p>在 RISC-V 架构中可以通过 LR/SC 指令是实现 CAS/TAS 指令的功能。</p>

<h4 id="213-让权等待">2.1.3 让权等待</h4>

<p>在涉及到上述这种某种条件不满足就需要在原地 <strong>等待</strong> 的情况， 操作系统设计了多种等待方式， 包括 <strong>忙等</strong>， <strong>yield 调度</strong>， <strong>阻塞</strong>。</p>

<ul>
  <li><strong>忙等</strong>
    <ul>
      <li><strong>优点：</strong> 在忙等有意义的前提下， 忙等的优势是在条件成立的第一时间就能够进行响应， 对于事件的响应延迟更低， 实时性更好， 而且不涉及开销很大的上下文切换。</li>
      <li><strong>缺点：</strong> 它的缺点则是不可避免的会浪费一部分 CPU 资源在忙等上， 且单核环境下会浪费一整个时间片。</li>
    </ul>
  </li>
  <li><strong>yield 调度</strong>
    <ul>
      <li><strong>优点：</strong> 让出 CPU 资源， 避免忙等对 CPU 的占用。</li>
      <li><strong>缺点：</strong> 增加了上下文切换的次数， 而上下文切换开销很大， 并且会破坏缓存资源（刷新 TLB）造成缓存命中率降低， 若 yield 非常频繁这种情况更会加剧。 另外， yeild 可能会导致当前事件的响应延时过久造成响应时间不可接收的局面。</li>
    </ul>
  </li>
  <li><strong>阻塞</strong>
    <ul>
      <li><strong>优点：</strong> 操作系统可标记需要等待事件的线程为 <strong>阻塞态</strong>， 并将该线程从调度器队列移除， 而在等待事件到来后唤醒该线程将其加入就绪队列， 操作系统可以定义唤醒后的线程在队列中的优先级进行优先资源配置。 由于不参与调度， 因此阻塞不会浪费时间片， 以及造成上下文开销。</li>
      <li><strong>缺点：</strong> 机制比较复杂， 并且难以避免地产生两次上下文切换（调度器移除与移入）， 在事件产生频率较高的时候不如忙等来的划算。</li>
    </ul>
  </li>
</ul>

<p>rCore 实现了 Sync Mutex OS 中的 <strong>阻塞 - 唤醒</strong> 机制， 具体原理参考 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/2lock.html#id18">实现阻塞与唤醒机制</a>。 但需要注意的是， rCore 的实现是在单核 CPU 上， 并且 RISC-V 架构规定从用户态陷入内核态之后所有（内核态）中断默认被自动屏蔽， 因而在内核中实现 Mutex 仅需要用单标记而无需使用原子指令。</p>

<h3 id="22-信号量机制">2.2 信号量机制</h3>

<p>信号量机制能够满足线程的同步要求， 即 A 线程执行到某个阶段后， B 线程通过信号量可以继续向下执行， 或者， 可以通过信号量使 N 个线程具备在临界区中访问共享资源的需求， 这些都是纯粹的 Mutex 互斥锁无法做到的。 实际上， 信号量在实现的时候还会用到 <strong>互斥锁和原子指令</strong>， 它是更高一级的同步互斥机制， 在特殊情况下， 信号量甚至与互斥锁等价。</p>

<p>信号量支持两种操作：<strong>P 操作（Proberen， 表示尝试）</strong> 和 <strong>V 操作（Verhogen ，表示增加）</strong>，P 操作表示线程尝试占用一个资源， 而与之匹配的 V 操作表示线程将占用的资源归还， 这同样基于 <strong>阻塞 - 唤醒</strong> 机制实现。</p>

<ul>
  <li>当进行 P 操作的时候， 如果此时没有可用的资源， 则当前线程会被阻塞；</li>
  <li>当进行 V 操作的时候， 如果返还之后有了可用的资源， 且此时有线程被阻塞， 那么就可以考虑唤醒它们。</li>
</ul>

<p>信号量的初始资源可用数量 N 是一个非负整数，它决定了信号量的用途。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">N &gt; 0</code>， 称其为 <strong>计数信号量 (Counting Semaphore)</strong> 或 <strong>一般信号量 (General Semaphore)</strong>， 当 <code class="language-plaintext highlighter-rouge">N = 1</code> 时， 称其为 <strong>二值信号量 (Binary Semaphore)</strong>， 其与互斥锁等价。</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">N = 0</code>， 信号量与资源管理无关， 但可用作同步量。 如下图， 在线程 A 需要等待的时候可以对该信号量进行 P 操作， 于是线程会被阻塞。 在线程 B 执行完指定阶段之后再对该信号量进行 V 操作就能够唤醒线程 A 向下执行。 但需要注意 <strong>唤醒丢失</strong> 的问题。</p>

    <div align="center">
      <img src="/norobots/images/2023-07-15-rcore-note-ch8/semaphore-sync.png" alt="Semaphore sync, rCore" width="400" />
      <br />
      <font size="2" color="#999"><u>Semaphore sync, rCore</u></font>
  </div>
  </li>
</ul>

<p>除了作为同步原语解决同步问题， rCore 还介绍了一个基于有限缓冲协作的 <strong>生产者与消费者</strong> 问题， 其实就是利用了信号量共享资源计数， 在无资源能进行阻塞的特点， 但还需注意的是， 共享资源仍需要通过互斥锁进行保护。 详见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/3semaphore.html#id8">生产者和消费者问题</a>。 虽然信号量解决了条件同步和生产者与消费者问题， 但对程序员而言要求较高， 其开发和阅读都具备一定难度。</p>

<h3 id="23-条件变量机制">2.3 条件变量机制</h3>

<p>信号量与互斥锁的组合虽然能解决一些问题， 但其仍存在局限性：</p>

<ul>
  <li>信号量本质上为一个整数， 无法描述所有类型的等待事件或等待条件；</li>
  <li>信号量需要 P 和 V 组合使用， 还容易导致死锁问题。</li>
</ul>

<p>rCore 实现了 <strong>条件变量 + 互斥锁</strong> 这样一个组合来模拟 <strong>管程</strong> 的实现， 以打破上述组合的局限性。 <strong>管程 (Monitor)</strong> 最早在 Pascal 语言中实现， 现在的 C 以及 Rust 并没有相关的实现机制， 由过程（现在的函数）、共享变量及数据结构等组成。 程序员可以自定义管程的过程和共享资源， 通过过程间接访问这些共享资源。</p>

<p>管程仍是通过互斥锁满足 <strong>互斥访问</strong> 的需求， 另外还支持线程间的同步机制， 通过 <strong>阻塞-唤醒</strong> 实现条件同步。 阻塞和唤醒就是所谓的 <strong>条件变量</strong>， 而在管程的概念中将条件变量的阻塞和唤醒操作分别叫做 <code class="language-plaintext highlighter-rouge">wait</code> 和 <code class="language-plaintext highlighter-rouge">signal</code> 。 一个管程中可以有多个不同的条件变量， 每个条件变量代表多线程并发执行中需要等待的一种特定的条件， 并保存所有阻塞等待该条件的线程。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">wait</code> 和 <code class="language-plaintext highlighter-rouge">signal</code> 有比较特殊的设计：</p>

<ul>
  <li><strong>wait</strong>： <code class="language-plaintext highlighter-rouge">wait</code> 操作会阻塞当前的线程， 但 <strong>不能在持有锁的情况下陷入阻塞</strong>， 在管程过程中线程是持有锁的， 因而 <code class="language-plaintext highlighter-rouge">wait</code> 需要做两件事： 释放锁， 然后阻塞线程。</li>
  <li><strong>signal</strong>： <code class="language-plaintext highlighter-rouge">signal</code> 则是唤醒当前的线程， 处于互斥访问的需求， 线程被唤醒后需要获取锁， 然后再 <code class="language-plaintext highlighter-rouge">wait</code> 返回继续执行。</li>
</ul>

<p>由于互斥锁的存在， signal 操作也不只是简单的唤醒操作。 rCore 介绍了基于线程优先级条件的三种唤醒操作语义： Hoare， Hansen， Mesa， 详情可见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/4condition-variable.html#id4">管程与条件变量</a>。 在 rCore 内核中实现的是 Mesa 语义， Mesa 语义涉及到锁的竞争， 因而 wait 操作返回之时不见得线程等待的条件一定成立， 有必要重复检查确认之后再继续执行。</p>

<p>另外， rCore 介绍了条件变量的两种用法 <strong>条件同步问题</strong> 以及 <strong>同步屏障问题</strong>， 尤其同步屏障问题在多线程编程中会经常遇到， 深有体会。 对此可详见 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/4condition-variable.html#id6">条件变量的使用方法</a> 学习。</p>

<p>TODO…</p>]]></content><author><name>HangX-Ma</name></author><category term="Rust" /><category term="rCore" /><summary type="html"><![CDATA[第八章：并发， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry></feed>