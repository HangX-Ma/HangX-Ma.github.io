<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-07-03T00:13:54+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">rCore OS Note - Chapter 3</title><link href="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 3" /><published>2023-07-01T00:00:00+08:00</published><updated>2023-07-01T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/01/rcore-note-ch3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html"><![CDATA[<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第三章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rcore-sp23/tree/ch3-lab">[ch3-lab]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>隔了这么就才整到第三章， 毕竟最近杂活儿有点多， 另外第二章的编程题也是安排很不合理， 把后面的内容提前扔给读者结果第三章实验部分要推倒重来太浪费时间了。 更新这章的 OS 框架的时候变动的地方有些多， 尤其是 <code class="language-plaintext highlighter-rouge">Makefile</code> 部分以及 <code class="language-plaintext highlighter-rouge">build.rs</code> 部分和 <em>rCore-Tutorial-Guide-2023S</em> 中进行了同步以及微调。</p>
</blockquote>

<h2 id="1-multi-program-os">1. Multi-program OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/multiprog-os-detail.png" alt="Multi-program OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Multi-program OS Details, rCore</u></font>
</div>

<p>要满足 <strong>任务切换</strong> 的要求， 所以程序需要预先被加载到一个固定的内存地址， 而不是所有程序共用一个入口地址。 rCore 添加了 <code class="language-plaintext highlighter-rouge">user/build.py</code> 读取 <code class="language-plaintext highlighter-rouge">os/src/link_app.S</code> 并对每个程序的地址空间进行更改以适应前述要求。</p>

<p>与 Trap 不同， Mult-program OS 中的任务切换发生在内核态 （S Mode） 且不涉及特权级切换， 通过 <code class="language-plaintext highlighter-rouge">__switch</code> 函数实现两个不同的 <code class="language-plaintext highlighter-rouge">Task Context</code> 的切换。</p>

<blockquote>
  <p><strong>为什么 <code class="language-plaintext highlighter-rouge">__switch</code> 需要通过汇编的完成主要功能？</strong><br />
由于任务切换不涉及特权级的改变， 因而需要保存的上下文就比较少， 仅需要保存 <code class="language-plaintext highlighter-rouge">ra</code> 入口地址， <code class="language-plaintext highlighter-rouge">sp</code> 栈指针， 以及 Callee 负责寄存器 <code class="language-plaintext highlighter-rouge">s0~s11</code> 即可。 高级程序语言会在函数中自己使用一些通用的寄存器， 可能会发生意料之外的控制流， 另外 <code class="language-plaintext highlighter-rouge">__switch</code> 函数仅作为 label 存在不会被 Rust/C 编译器处理， 这些都是使用汇编完成 <code class="language-plaintext highlighter-rouge">__switch</code> 主体功能的原因。</p>
</blockquote>

<h2 id="2-cooperative-os">2. Cooperative OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/more-task-multiprog-os-detail.png" alt="Cooperative OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Cooperative OS Details, rCore</u></font>
</div>

<p>Multi-program OS 仅仅介绍了任务切换中的 <strong>换栈</strong> 需求， 任务切换还需要指示任务的状态， 维护这一信息。 这里我仅记录初始化流程中的几个自己困惑的细节。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">in</span> <span class="n">tasks</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">task</span><span class="py">.task_cx</span> <span class="o">=</span> <span class="nn">TaskContext</span><span class="p">::</span><span class="nf">goto_restore</span><span class="p">(</span><span class="nf">init_app_cx</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">task</span><span class="py">.task_status</span> <span class="o">=</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/task/context.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">goto_restore</span><span class="p">(</span><span class="n">kstack_ptr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">__restore</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">ra</span><span class="p">:</span> <span class="n">__restore</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sp</span><span class="p">:</span> <span class="n">kstack_ptr</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TASK_MANAGER</code> 通过 <code class="language-plaintext highlighter-rouge">init_app_cx</code> 函数初始化了每个 task 的内核栈， 而 <code class="language-plaintext highlighter-rouge">goto_restore</code> 的设计就非常巧妙， 这里并没有进入 <code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 标签处， 而是将任务栈的 <code class="language-plaintext highlighter-rouge">ra</code> 初始化为 <code class="language-plaintext highlighter-rouge">__restore</code> 地址， 这样当 <code class="language-plaintext highlighter-rouge">__switch</code> 完成后 <code class="language-plaintext highlighter-rouge">ret</code> 就能直接进入<code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 恢复到用户态继续执行任务。 相应的其中的 <code class="language-plaintext highlighter-rouge">sp</code> 指针被初始化为内核栈指针。</p>

<blockquote>
  <p><strong>丢失的 <code class="language-plaintext highlighter-rouge">mv sp, a0</code></strong></p>

  <ul>
    <li>
      <p>可以顺着控制流梳理一遍， 第一次用到 <code class="language-plaintext highlighter-rouge">__switch</code> 是初始化时运行 <code class="language-plaintext highlighter-rouge">run_first_task</code> 函数。 <code class="language-plaintext highlighter-rouge">__switch</code> 将 <code class="language-plaintext highlighter-rouge">unused</code> 中的垃圾数据保存在了程序栈后切换到了第一个 task （此后就是内核栈和用户栈之间的切换了）， 通过 <code class="language-plaintext highlighter-rouge">ra</code> 指向的 <code class="language-plaintext highlighter-rouge">__restore</code> 进行上下文恢复， 对于 task 而并不需要再次更新 <code class="language-plaintext highlighter-rouge">sp</code>， 该值已经在 <code class="language-plaintext highlighter-rouge">__switch</code> 中被恢复成该任务对应的内核指针了。</p>
    </li>
    <li>
      <p>另一个就是进入 trap 之后， <code class="language-plaintext highlighter-rouge">__alltrap</code> 最后进入 <code class="language-plaintext highlighter-rouge">trap_handler</code> 函数， 该函数最后会在返回参数的 <code class="language-plaintext highlighter-rouge">a0</code> 中保存之前存入的 <code class="language-plaintext highlighter-rouge">TrapContext</code>， 而在此之前有这么两句指令说明了 <code class="language-plaintext highlighter-rouge">sp</code> 就是这个 <code class="language-plaintext highlighter-rouge">TrapContext</code>。 因而无需再进行重复保存。</p>

      <div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="c1"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span><span class="w">
 </span><span class="n">mv</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w">
 </span><span class="n">call</span><span class="w"> </span><span class="n">trap_handler</span><span class="w">
</span></code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<h2 id="3-timesharing-os">3. Timesharing OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/time-task-multiprog-os-detail.png" alt="Timesharing OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Timesharing OS Details, rCore</u></font>
</div>

<h2 id="4-课后练习">4. 课后练习</h2>

<p>这章的编程题还是有必要提前做一下的， 汲取了上一章的教训这次先看了 lab 部分， 发现 lab 有个要求是记录当前的正在运行的 task 的运行总时长， 这部分时间既包括内核态与用户态两部分的运行时间， 正好编程题包括了。 这部分可以选择性的完成几个基础练习， 难的部分再好好研究一下。</p>

<h2 id="41-编程题">4.1 编程题</h2>

<ol>
  <li>
    <p><em><strong>扩展内核， 能够显示操作系统切换任务的过程。</strong></em></p>

    <p>只用在 <code class="language-plaintext highlighter-rouge">os/src/task/mod.rs</code> 的 <code class="language-plaintext highlighter-rouge">run_next_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 加入打印就行， 另外在这里我对任务切换的流程进行了优化， 仅在当前 <code class="language-plaintext highlighter-rouge">current != next</code> 时才进行 <code class="language-plaintext highlighter-rouge">Task Context</code> 交换以及打印相关的信息， 这样能减少内核开销。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/mod.rs</span>
 <span class="k">fn</span> <span class="nf">run_next_task</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_next_task</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">self</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
         <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
         <span class="o">...</span>
         <span class="c1">// ch3-pro1</span>
         <span class="k">if</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">next</span> <span class="p">{</span>
             <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] task switch from {} to {}"</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
             <span class="k">unsafe</span> <span class="p">{</span>
                 <span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">);</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除此之外 <code class="language-plaintext highlighter-rouge">struct TaskManagerInner</code> 中我添加了 <code class="language-plaintext highlighter-rouge">alive_task_num</code> 用以记录仍在 <code class="language-plaintext highlighter-rouge">Ready</code> 以及 <code class="language-plaintext highlighter-rouge">Running</code> 的 task 的数量， 仅在 <code class="language-plaintext highlighter-rouge">alive_task_num &gt; 1</code> 的时候才在 <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中添加打印以保持输出面板整洁以及系统开销最小。</p>

    <blockquote>
      <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/4f1dd08bae3e884a06e2a8141bf0fa4d6909310a">commit#4f1dd08</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/208d86306ee7bba5149fbd38acfb62f6d08e9d84">commit#208d863</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计每个应用执行后的完成时间： 用户态完成时间和内核态完成时间。</strong></em></p>

    <p>lab 相关的重点， <code class="language-plaintext highlighter-rouge">sys_task_info</code> 大部分信息其实都需要 task module 的支持。 另外， 每个 task 都是独立的， 因而需要在 <code class="language-plaintext highlighter-rouge">struct TaskControlBlock</code> 中增加记录 task 运行时间的变量。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
 <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
     <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>之后比较关键的是如何记录这个时间， 这个我在之前 chapter2 实现了类似的函数， 基本思路就是利用 riscv 的 mtime 寄存器， 需要有个特定的变量存储 mtime 寄存器的值并在每次进入该 task 时计算与现在的 mtime 的插值获取时间信息的变更。</p>
    <blockquote>
      <p>lab 中要求时间单位为 ms， 可以使用 <code class="language-plaintext highlighter-rouge">timer.rs</code> 的 <code class="language-plaintext highlighter-rouge">get_time_ms</code> 函数。</p>
    </blockquote>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskManagerInner</span> <span class="p">{</span>
     <span class="cd">/// task list</span>
     <span class="n">tasks</span><span class="p">:</span> <span class="p">[</span><span class="n">TaskControlBlock</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">],</span>
     <span class="cd">/// id of current `Running` task</span>
     <span class="n">current_task</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// the number of tasks that have not exit</span>
     <span class="n">alive_task_num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// record time point</span>
     <span class="n">checkpoint</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <dl>
      <dt>内核态时间</dt>
      <dd>在 <code class="language-plaintext highlighter-rouge">run_first_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中更新信息， 另外需要在 task 退出时打印耗时。</dd>
      <dt>用户态时间</dt>
      <dd>用户态和内核态的分界处就是 trap， 因而在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的起始位置和末尾位置可分别作为 user time 的开始以及 user time 的结束。</dd>
    </dl>

    <blockquote>
      <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5904c2fcb253a5bfa694ab94e0c7e3006f510238">commit#5904c2f</a> 以及课后参考答案部分。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>编写浮点应用程序A， 并扩展内核， 支持面向浮点应用的正常切换与抢占。</strong></em></p>
  </li>
  <li>
    <p><em><strong>编写应用程序或扩展内核， 能够统计任务切换的大致开销。</strong></em></p>

    <p>这里的参考答案是有问题的， TODO</p>
  </li>
</ol>

<h3 id="42-实验练习">4.2 实验练习</h3>

<h3 id="421-获取任务信息">4.2.1 获取任务信息</h3>

<p>做完编程题的第二个就跑来做 lab 了， 事情比我想得要复杂一些。 这里需要声明一下 <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html">rCore-Tutorial-Guide 2023</a> 实验指导书对应的 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2023S">test repo</a> 和当前的 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a> 是有差异的， 如果你和我一样是按照 tutorial 一步步搭起来的 OS 请注意以下这些细节。</p>

<p>Guide 2023S 中提供的接口函数是如下形式， 在具体实现的时候由于 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 中存在一个数组结构， 需要添加 <code class="language-plaintext highlighter-rouge">#[derive(Clone, Copy)]</code>， 如果添加了 <code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 修饰， 后续在 user 目录下的 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 需要保持声明的一致性， 否则 os 部分的 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 将无法正确赋值。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>
<span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span>

<span class="k">struct</span> <span class="n">TaskInfo</span> <span class="p">{</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我最开始设想在 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 外在包裹一个 <code class="language-plaintext highlighter-rouge">TaskInfoWrapper</code>， 并将其声明为如下 case1 形式， 但问题也随之而来， 程序运行会出现 <em><strong>PageFault</strong></em> 错误。 而 case2 这样试图将 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 作为可变量用 <code class="language-plaintext highlighter-rouge">UPSafeCell</code> 保护， 之后再通过 <code class="language-plaintext highlighter-rouge">lazy_static!</code> 宏声明一个 <code class="language-plaintext highlighter-rouge">[TaskInfoWrapper;MAX_APP_NUM]</code> 全局数组变量则会遇到 Copy Trait 未实现的问题。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// case1</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="n">TaskInfo</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// case2</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因而我想现阶段我没办法找到一种合适的办法构造一个全局数组变量去存储每个 task info， 那不如利用现有的资源， 每个 task 都维护了一个 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 变量， 此前的编程题作业在这里面添加了 <code class="language-plaintext highlighter-rouge">kernel_time</code> 以及 <code class="language-plaintext highlighter-rouge">user_time</code>， 不如再增加一个 <code class="language-plaintext highlighter-rouge">syscall_times</code> 数组变量（与所给测例一致）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>剩下的事情就比较简单了， 给 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 提供一个可以获取当前 task 的 <code class="language-plaintext highlighter-rouge">TaskCOntrolBlock</code> 的函数， 以及一个可以在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的 syscall 之前调用的增加 <code class="language-plaintext highlighter-rouge">syscall_times</code> 值的函数就能基本满足题干的要求， 我是这么实现的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_current_task_block</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_task_syscall_times</span><span class="p">(</span><span class="n">syscall_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.syscall_times</span><span class="p">[</span><span class="n">syscall_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/syscall/process.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task_block</span> <span class="o">=</span> <span class="nf">get_current_task_block</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
            <span class="n">status</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.task_status</span><span class="p">,</span>
            <span class="n">syscall_times</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.syscall_times</span><span class="p">,</span>
            <span class="n">time</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.kernel_time</span> <span class="o">+</span> <span class="n">task_block</span><span class="py">.user_time</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d5f55551e5e3428ca7c17026329c2d84fe9bde4f">commit#d5f5555</a>, 但该 commit 中我还对之前的 <code class="language-plaintext highlighter-rouge">sys_write</code> 的 checker 函数进行了更新。</p>
</blockquote>

<p>需要注意 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 需要单独运行测试， 否则 <code class="language-plaintext highlighter-rouge">get_time</code> 函数获取的几个时间点的差值会受到其他程序影响而产生很大偏差。 另外测例中的 <code class="language-plaintext highlighter-rouge">println!</code> 是调用了 flush 函数的， 因而在 rCore 2023S 提供的测试环境中确实会有两次 write 系统调用， 但是按照 tutorial 搭的 OS 现阶段仅有一次 write 系统调用， 若这个测试没通过可以自行修改一下。
{.error}</p>

<h3 id="422-问答题">4.2.2 问答题</h3>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第三章：多道程序与分时多任务， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Start from scratch: Neovim for Rust</title><link href="https://hangx-ma.github.io/2023/06/23/neovim-config.html" rel="alternate" type="text/html" title="Start from scratch: Neovim for Rust" /><published>2023-06-23T00:00:00+08:00</published><updated>2023-06-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/23/neovim-config</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/23/neovim-config.html"><![CDATA[<blockquote>
  <p>配置文件可以在 <a href="https://github.com/HangX-Ma/dotfiles/tree/main/nvim">nvim-config</a> repo 下查看， 配完后感觉没有汇编支持不适合 OS 底层开发， 到时候再看看吧， 先用回 vscode。</p>
</blockquote>

<h2 id="0-安装-neovim">0. 安装 Neovim</h2>

<p>使用 <a href="https://github.com/neovim/neovim/releases/tag/stable">Nvim release build</a> 的方式， 省心省力。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/neovim/neovim/releases/download/stable/nvim-linux64.tar.gz
<span class="nb">tar</span> <span class="nt">-xvf</span> nvim-linux64.tar.gz
vim ~/.bashrc
<span class="c"># .bashrc</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/nvim-linux64/bin:<span class="nv">$PATH</span>
<span class="c"># back to cli</span>
<span class="nb">source</span> ~/.bashrc
</code></pre></div></div>

<h2 id="1-vim-选项配置">1. vim 选项配置</h2>

<blockquote>
  <p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门 - 阮一峰</a><br />
<a href="https://www.xwxwgo.com/post/2022/09/21/spell_check_in_nvim/">Neovim拼写检查</a></p>
</blockquote>

<h2 id="2-快捷键配置">2. 快捷键配置</h2>

<p><a href="https://juejin.cn/book/7051157342770954277/section/7051536642238054430">Neovim 配置实战：从0到1打造自己的IDE</a></p>

<h2 id="3-安装-packer-插件管理器">3. 安装 Packer 插件管理器</h2>

<p>参照 Packer 的 repo 的配置内容快速安装 <a href="https://github.com/wbthomason/packer.nvim">packer.nvim</a>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--depth</span> 1 https://github.com/wbthomason/packer.nvim<span class="se">\</span>
 ~/.local/share/nvim/site/pack/packer/start/packer.nvim
</code></pre></div></div>

<p><a href="https://github.com/wbthomason/packer.nvim#bootstrapping">Bootstrapping</a> 这一章节提供了一种便利的方式配置插件， 在导入配置后能自动安装已配置完的插件， 在 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins/plugins.lua</code> 中拷贝这部分代码作为插件配置的基础。 我们创建 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins</code> 文件夹用以管理各个安装的插件。 若需要对插件进行自定义配置， 我们需要创建相关的 lua 文件， 例如 <code class="language-plaintext highlighter-rouge">onedark.lua</code> 之后在 <code class="language-plaintext highlighter-rouge">init.lua</code> 文件中 <code class="language-plaintext highlighter-rouge">require(plugins.onedark)</code> 即可应用相关的配置。</p>

<h2 id="4-插件安装">4. 插件安装</h2>

<h3 id="41-安装-onedark---dark-主题">4.1 安装 OneDark - Dark 主题</h3>

<p>主要参考 <a href="https://github.com/navarasu/onedark.nvim">onedark.nvim</a>， 加入插件后自定义配置即可。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- lua/plugins/plugins.lua</span>
<span class="n">use</span> <span class="s1">'navarasu/onedark.nvim'</span>
</code></pre></div></div>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- plugins/onedark.lua</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="n">setup</span> <span class="p">{</span>
    <span class="c1">-- Main options --</span>
    <span class="n">style</span> <span class="o">=</span> <span class="s1">'dark'</span><span class="p">,</span>
    <span class="n">transparent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">-- Show/hide background</span>
<span class="p">}</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="nb">load</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="42-status-line">4.2 Status Line</h3>

<p>主要参考 <a href="https://github.com/nvim-lualine/lualine.nvim">lualine.nvim</a>， 拷贝 <a href="https://github.com/nvim-lualine/lualine.nvim#default-configuration">default configuration</a> 到 <code class="language-plaintext highlighter-rouge">lua/plugins/lualine.lua</code>， 其余步骤与上述一致。 后续若没有特殊情况就不重复说明相关步骤。</p>

<blockquote>
  <p>值得注意的是， 添加相关的插件后需要在 nvim 中运行 <code class="language-plaintext highlighter-rouge">PackerSync</code> 以安装相关插件， 否则 nvim 会报错。</p>
</blockquote>

<h3 id="43-navigation">4.3 Navigation</h3>

<dl>
  <dt>File Explorer: <a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree.nvim</a></dt>
  <dd>提供了便捷的文件管理树的功能， 所有的文件操作可以通过键盘实现</dd>
  <dt>Tmux Navigator: <a href="https://github.com/christoomey/vim-tmux-navigator">vim-tmux-navigator.nvim</a></dt>
  <dd>tmux (terminal multiplexer) 是一个终端复用器， 主要可以用于分屏和保持会话。 保持会话的意思是， 即使关闭终端窗口， 或者 SSH 由于各种原因连接中断， 在服务器端 tmux 中的会话和对应的进程仍然不会终止。 tmux 能够创建多个会话 （session）， 每个会话能够创建多个窗口 （window）， 每个窗口又可以分为多个窗格 （pane）。</dd>
  <dt>Buffer Line: <a href="https://github.com/akinsho/bufferline.nvim">bufferline.nvim</a></dt>
  <dd>这个插件提供了类似 vscode 的标签页的功能</dd>
  <dt>Outline: <a href="https://github.com/simrat39/symbols-outline.nvim">symbols-outline.nvim</a></dt>
  <dd>类似 vscode 中的 Outline， 基于 LSP 实现的函数与符号树， 方便查看代码实现的整体结构。</dd>
</dl>

<blockquote>
  <p><a href="https://blog.51cto.com/u_11090813/5575032">从零开始配置 vim(13)——标签页插件 - jesssic</a>
<a href="https://blog.51cto.com/u_11090813/5759499">从零开始配置vim(26)——LSP UI 美化 - jesssic</a></p>
</blockquote>

<h3 id="44-highlight">4.4 Highlight</h3>

<dl>
  <dt>Code Highlighting: <a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter.nvim</a></dt>
  <dd>nvim-treesitter 插件提供基于 <a href="https://github.com/tree-sitter/tree-sitter">tree-sitter</a> 的多个基础功能， 它可以让你在 nvim 中高效的实现 <strong>代码高亮， 增量选择</strong> 等功能。</dd>
  <dt>Syntax Highlighting: <a href="https://github.com/p00f/nvim-ts-rainbow">nvim-ts-rainbow</a></dt>
  <dd>该插件依赖于 nvim-treesitter， 允许多种配置策略为不同的文件类型提供高亮支持。</dd>
</dl>

<h3 id="45-terminal">4.5 Terminal</h3>

<dl>
  <dt>Terminal: <a href="https://github.com/akinsho/toggleterm.nvim">toggleterm.nvim</a></dt>
  <dd>虽然用 nvim 默认的指令可以在编辑文档时打开 Terminal， 但是 toggleterm.nvim 提供了更为便捷以及功能更强大的 Terminal 管理方案。</dd>
</dl>

<blockquote>
  <p><a href="https://www.youtube.com/watch?v=5OD-7h7gzxU">Neovim - Toggleterm | Open terminal programs in Neovim - Youtube</a>
<a href="https://blog.51cto.com/u_11090813/5647999">从零开始配置vim(19)——终端配置 - jesssic</a></p>
</blockquote>

<h3 id="46-search">4.6 Search</h3>

<dl>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/popup.nvim">popup.nvim</a></dt>
  <dd>plenary.nvim 的必要组件， 能够提供与 vim <code class="language-plaintext highlighter-rouge">popup_*</code> 兼容的 API 接口。</dd>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/plenary.nvim">plenary.nvim</a></dt>
  <dd>telescope.nvim 的必要组件， 能够提供异步编程， 目录扫描等基础功能。</dd>
  <dt>Fuzzy Finder: <a href="https://github.com/nvim-telescope/telescope.nvim">telescope.nvim</a></dt>
  <dd>telescope.nvim 能在 neovim 中提供文件名模糊搜索和文本内容搜索的功能， 以及更多复杂的功能。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/609527018">Vim/Neovim 全文检索插件 – telescope.nvim - 知乎</a></p>
</blockquote>

<h3 id="47-comment">4.7 Comment</h3>

<dl>
  <dt>Smart Comment: <a href="https://github.com/numToStr/Comment.nvim">Comment.nvim</a></dt>
  <dd>能够方便的对代码进行注释， 这个插件的配置更灵活也更强大。</dd>
</dl>

<h3 id="48-自动补全与内容查看">4.8 自动补全与内容查看</h3>

<h4 id="481-lsp-mason">4.8.1 LSP， Mason</h4>

<dl>
  <dt>Language Server Protocol: <a href="https://github.com/neovim/nvim-lspconfig">nvim-lspconfig</a></dt>
  <dd>Language Server Protocol (LSP) 是微软为开发工具提出的一个协议， 它将编程工具解耦成了Language Server 与 Language Client 两部分。 Client 专注于页面样式实现， Server 负责提供语言支持， 包括常见的自动补全， 跳转到定义， 查找引用， 悬停文档提示等功能。</dd>
  <dt>Portable Package Manager: <a href="https://github.com/williamboman/mason.nvim">mason.nvim</a></dt>
  <dd>mason.nvim 是下一代 nvim-lsp-installer， 能够方便地安装和管理 LSP servers， DAP servers， linters， 以及 formatters.</dd>
  <dt>Packer: <a href="https://github.com/williamboman/mason-lspconfig.nvim">mason-lspconfig.nvim</a></dt>
  <dd>mason-lspconfig.nvim 为 mason.nvim 以及 nvim-lspconfig 建立了桥梁， 方便两个插件的协同工作和配置。</dd>
  <dt>UI: <a href="https://github.com/j-hui/fidget.nvim">fidget.nvim</a></dt>
  <dd>nvim-lsp progress 的独立 UI插件， 将这部分信息显示在窗口右下角为程序员更专注编程提供便利。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/444836713">Neovim 内置 LSP 配置 (一)：基础配置 - 知乎</a></p>
</blockquote>

<h4 id="482-补全与自动提示">4.8.2 补全与自动提示</h4>

<dl>
  <dt>AutoPair: <a href="https://github.com/windwp/nvim-autopairs">nvim-autopairs</a></dt>
  <dd>自动补全括号的插件， 具体作用之后用了补充。</dd>
  <dt>Completion: <a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a></dt>
  <dd>自动补全的引擎， 支持 LSP 以及自定义灵活配置， 我们需要安装如下插件 <code class="language-plaintext highlighter-rouge">neovim/nvim-lspconfig</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-nvim-lsp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-buffer</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-path</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-cmdline</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/nvim-cmp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-vsnip</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/vim-vsnip</code>, <code class="language-plaintext highlighter-rouge">saadparwaiz1/cmp_luasnip</code></dd>
  <dt>Friendly Snippets: <a href="https://github.com/rafamadriz/friendly-snippets">friendly-snippets</a></dt>
  <dd>更够为不同语言提供 Snippets 支持。</dd>
</dl>

<h3 id="49-debug">4.9 Debug</h3>

<dl>
  <dt>Debugger: <a href="https://github.com/puremourning/vimspector">vimspector</a></dt>
  <dd>多语言的带图形界面的调试工具， 看起来挺复杂。</dd>
  <dt>Debug Adapter Protocol: <a href="https://github.com/mfussenegger/nvim-dap">nvim-dap</a></dt>
  <dd>Nvim-dap 是基于 Neovim 的 Debug Adapter Protocol 客户端实现的， 能够进行基本的断点、 步进等操作， 并监视应用的状态。</dd>
</dl>

<h3 id="410-rust-语言支持">4.10 Rust 语言支持</h3>

<dl>
  <dt>Code: <a href="https://rust-analyzer.github.io/">rust-analyzer</a></dt>
  <dd>rust-analyzer 基于 LSP 实现， 它为许多代码编辑器 (包括 VS Code、 Emacs 和 Vim) 提供了补全和跳转定义等特性。</dd>
</dl>

<blockquote>
  <p>nvim 打开后使用 <code class="language-plaintext highlighter-rouge">:Mason</code> 选择 rust-analyzer 按 i 可以便捷安装。</p>
</blockquote>

<dl>
  <dt>Tool: <a href="https://github.com/simrat39/rust-tools.nvim">rust-tools.nvim</a></dt>
  <dd>为 rust 编程提供便利的实用工具。</dd>
</dl>

<h3 id="411-clipboard">4.11 Clipboard</h3>

<dl>
  <dt>Clipboard: <a href="https://github.com/EtiamNullam/deferred-clipboard.nvim/tree/master">deferred-clipboard.nvim</a></dt>
  <dd>打通操作系统与 nvim 之间的桥梁， 二者能共用剪贴板的缓存。</dd>
</dl>

<h3 id="412-git">4.12 Git</h3>

<dl>
  <dt>LazyGit: <a href="https://github.com/kdheepak/lazygit.nvim">lazygit.nvim</a></dt>
  <dd>Git 相关组件， 实现 commit, push 等操作的可视化。</dd>
  <dt>Git Signs: <a href="https://github.com/lewis6991/gitsigns.nvim">gitsigns.nvim</a></dt>
  <dd>提供了和 Git 相关的功能， 例如查看 git diff， last commit， status bar 等， 类似 vscode 中的 GitLen。</dd>
</dl>

<h3 id="413-speed-up">4.13 Speed Up</h3>

<dl>
  <dt>FileType: <a href="https://github.com/nathom/filetype.nvim">filetype.nvim</a></dt>
  <dd>filetype.nvim 是为了替代 nvim 启动时引用的 <code class="language-plaintext highlighter-rouge">filetype.vim</code> 文件， 该文件的目的是创建一系列自动命令， 根据文件名设置 filetype 变量， 但该文件的载入耗费了大量的时间， filetype.nvim 能优化这一载入过程， 对启动过程进行加速。</dd>
  <dt>Lua Loader: <a href="https://github.com/lewis6991/impatient.nvim">impatient.nvim</a></dt>
  <dd>该插件在 neovim 0.9 后就不需要了， 只用开启 <code class="language-plaintext highlighter-rouge">vim.loader.enable()</code> 即可对 lua 模块以及文件的载入进行加速。</dd>
</dl>

<h3 id="414-greeter">4.14 Greeter</h3>

<dl>
  <dt>Greeter: <a href="https://github.com/startup-nvim/startup.nvim">startup.nvim</a></dt>
  <dd>自定义 nvim 启动界面， 能够自己更换喜欢的主题！</dd>
</dl>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/617522665">从零开始：使用Neovim搭建Rust开发IDE - 知乎</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/467428462">我的现代化 NeoVim 配置介绍/教程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="neovim" /><summary type="html"><![CDATA[鉴于NvChard 这类整包的灵活性不高， 以及 vscode 经常抽风的现实情况， 从零开始搭建用于 Rust 编程环境的 Neovim]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 2</title><link href="https://hangx-ma.github.io/2023/06/23/rcore-note-ch2.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 2" /><published>2023-06-23T00:00:00+08:00</published><updated>2023-06-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/23/rcore-note-ch2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/23/rcore-note-ch2.html"><![CDATA[<div align="center">
    <img src="/norobots/images/2023-06-23-rcore-note-ch2/batchos-details.png" alt="Batch OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Batch OS Details, rCore</u></font>
</div>

<p>第二章需要实现实现一个 <code class="language-plaintext highlighter-rouge">邓氏鱼</code> 操作系统， 它能够感知多个应用程序的存在， 并一个接一个地运行这些应用程序， 当一个应用程序执行完毕后， 会启动下一个应用程序， 直到所有的应用程序都执行完毕。</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第二章相关内容的实现可查看 Github Tag: <a href="https://github.com/HangX-Ma/rcore-sp23/tree/ch2-lab">[ch2-lab]</a> <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch2-pro">[ch2-pro]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-实现应用程序---代码解析与提要">1. 实现应用程序 - 代码解析与提要</h2>

<ol>
  <li>
    <p>根据 <a href="https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#%E4%BB%8E%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8-rust-%E5%87%BD%E6%95%B0">Rust 程序设计语言</a> 中的描述， 创建一个允许其他语言调用 Rust 函数需要添加 <code class="language-plaintext highlighter-rouge">extern</code> 标识。 另外 <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> 能保证 Rust 函数名不会被编译器处理变得难以阅读与定位， 使其保留原有的名称方便被其他语言指定与链接。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">#[no_mangle]</span>
 <span class="nd">#[link_section</span> <span class="nd">=</span> <span class="s">".text.entry"</span><span class="nd">]</span>
 <span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">_start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
     <span class="nf">clear_bss</span><span class="p">();</span>
     <span class="nf">exit</span><span class="p">(</span><span class="nf">main</span><span class="p">());</span>
     <span class="nd">panic!</span><span class="p">(</span><span class="s">"unreachable after sys_exit!"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><a href="https://marcin.juszkiewicz.com.pl/download/tables/syscalls.html">Linux kernel system calls for all architectures</a> 中可以查阅 RISCV-64 规约的系统函数调用的接口与调用的 ID 号。</p>
  </li>
  <li>
    <p><a href="https://wangchujiang.com/rust-cn-document-for-docker/edition-guide/rust-2018/macros/macro-changes.html">Rust 版本指南</a> 中提及了 macro 的变化， 在 Rust 2015 版本， 当我们要导入外部 crate 的宏， 必须要使用 <code class="language-plaintext highlighter-rouge">#[macro_use]</code> 属性， 最直接的例子是在 <code class="language-plaintext highlighter-rouge">user/src/lang_items.rs</code> 中的 <code class="language-plaintext highlighter-rouge">println</code> 宏的使用， 我们可以通过在 <code class="language-plaintext highlighter-rouge">user/src/lib.rs</code> 在通过 <code class="language-plaintext highlighter-rouge">mod console;</code> 导入 console crate 前使用 <code class="language-plaintext highlighter-rouge">#[macro_use]</code> 就能在 user 被管理的各个 crate 中使用 console 提供的宏了（前提是宏需要用 <code class="language-plaintext highlighter-rouge">#[macro_export]</code> 修饰）。</p>
  </li>
</ol>

<h2 id="2-实现批处理操作系统">2. 实现批处理操作系统</h2>

<h3 id="21-build-构建脚本">2.1 build 构建脚本</h3>

<p><a href="https://course.rs/cargo/reference/build-script/intro.html">Rust语言圣经(Rust Course) - 9.3.10</a> 描述了 rust 中的构建脚本的作用， 一言以蔽之， 构建脚本会在项目被构建之前 Cargo 会编译构建脚本生成可执行文件并执行相应的任务， 其多用于 C 依赖库构建， 或指定依赖库， 以及进行平台的配置等预处理过程。 在 rCore 的项目中， os 项目工程的根目录下的 <code class="language-plaintext highlighter-rouge">build.rs</code> 主要完成的是链接功能性的二进制工具， 静态链接这些测试文件以在后续运行时动态调用。</p>

<p>值得一提的是， Rust 的构建脚本是通过 <code class="language-plaintext highlighter-rouge">println!</code> 宏与 Cargo 进行通信的， 通信内容是以 <code class="language-plaintext highlighter-rouge">cargo:</code> 开头的一系列字符串。 在我们撰写 chapter 2 的 <code class="language-plaintext highlighter-rouge">build.rs</code> 时， 使用 <code class="language-plaintext highlighter-rouge">wrtieln!</code> 宏写入信息需要注意使用 <code class="language-plaintext highlighter-rouge">r#"..."#</code> 取消转义， 以免导致不必要的麻烦。</p>

<blockquote>
  <p><a href="https://course.rs/basic/compound-type/string-slice.html">Rust语言圣经(Rust Course) - 2.4.1</a></p>
</blockquote>

<h3 id="22-批处理模块">2.2 批处理模块</h3>

<p>讲到这个章节的时候对 Rust 的 Crate, Module, Package, <code class="language-plaintext highlighter-rouge">use</code> 这些细节产生了疑问， 之前初学 Rust 走马观花过了一遍书没有实际案例分析， 对相关概念了解不深， <strong>Rust Course</strong> 以及 <strong>Rust学习笔记</strong> 分别用理论以及具体案例讲解和分析了相关内容， 非常的清晰。 在 rCore 的构建中， 对功能模块进行分级归类我觉得很重要， 不能一股脑的使用新的模块导入方式， 既然 Rust 1.3.0 以后提供了新的选择， 就不妨做好取舍。</p>

<blockquote>
  <p><a href="https://course.rs/basic/crate-module/intro.html">Rust语言圣经(Rust Course) - 2.12 包和模块</a><br />
<a href="https://skyao.io/learning-rust/docs/build/module/rust-module-system-explanation.html">对Rust的模块系统的清晰解释 - Rust 学习笔记</a></p>
</blockquote>

<h2 id="3-实现特权级的切换">3 实现特权级的切换</h2>

<h3 id="31-关于-userstack-与-kernelstack">3.1 关于 UserStack 与 KernelStack</h3>

<p>批处理操作系统被设计为运行在内核态特权级（RISC-V 的 S 模式）而应用程序被设计为运行在用户态特权级（RISC-V 的 U 模式）， 在 AEE(Application Execution Environment) 中受到操作系统监管， 执行过程中需要切换特权级。 Context 即上下文需要在特权级切换前后保持不变， 内核态和用户态的上下文信息需要保存在不通的栈中以保证数据的隔离。 rCore 保存上下文信息的栈是这样设计的， <code class="language-plaintext highlighter-rouge">get_sp</code> 返回数组结尾地址， 即栈底位置（栈由上向下生长， 栈底的地址比栈顶高， 除非像当前这样栈为空栈底和栈顶处于同一个地址）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(align(</span><span class="mi">4096</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">USER_STACK_SIZE</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">USER_STACK_SIZE</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>未初始化的全局变量和局部静态变量默认值都是 0， 一般来说会将这部分信息存放在 .bss 段并预留未定义的全局变量符号。 这里声明了一个全局静态变量并强制 4096 对齐。 通过 <code class="language-plaintext highlighter-rouge">readelf -t os/target/riscv64gc-unknown-none-elf/release/os</code> 读取编译出的 ELF 文件， <code class="language-plaintext highlighter-rouge">.rodata</code> 段被 4096 对齐了， 更改栈的大小也能确认 <code class="language-plaintext highlighter-rouge">KernelStack</code> 以及 <code class="language-plaintext highlighter-rouge">UserStack</code> 被放在了 <code class="language-plaintext highlighter-rouge">.rodata</code> 中。 初始化为 0 的全局变量和未初始化的全局变量的性质应当一致， 但这里出现了例外。 Rust 中的 static 变量实际声明了一段固定的内存空间且其中的内容不可变， 猜测 Rust 编译器倾向于将只读部分的预留内存保存在 <code class="language-plaintext highlighter-rouge">.rodata</code> 段。</p>

<blockquote>
  <p><a href="https://doc.rust-lang.org/reference/items/static-items.html">The Rust Reference - 6.10 Static items</a><br />
<em>Non-mut static items that contain a type that is not interior mutable may be placed in read-only memory.</em></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>There are 20 section headers, starting at offset 0x187ca0:

Section Headers:
  <span class="o">[</span>Nr] Name
       Type              Address          Offset            Link
       Size              EntSize          Info              Align
       Flags
  <span class="o">[</span> 0]
       NULL             0000000000000000  0000000000000000  0
       0000000000000000 0000000000000000  0                 0
       <span class="o">[</span>0000000000000000]:
  <span class="o">[</span> 1] .text
       PROGBITS         0000000080200000  0000000000001000  0
       00000000000033ce 0000000000000000  0                 4
       <span class="o">[</span>0000000000000006]: ALLOC, EXEC
  <span class="o">[</span> 2] .rodata
       PROGBITS         0000000080204000  0000000000005000  0
       00000000000062d0 0000000000000000  0                 4096
       <span class="o">[</span>0000000000000012]: ALLOC, MERGE
  <span class="o">[</span> 3] .data
       PROGBITS         000000008020b000  000000000000c000  0
       0000000000007430 0000000000000000  0                 8
       <span class="o">[</span>0000000000000003]: WRITE, ALLOC
  <span class="o">[</span> 4] .bss
       NOBITS           0000000080213000  0000000000013430  0
       00000000000100c0 0000000000000000  0                 8
       <span class="o">[</span>0000000000000003]: WRITE, ALLOC
</code></pre></div></div>

<p>最简单的办法就是将 <code class="language-plaintext highlighter-rouge">USER_STACK</code> 以及 <code class="language-plaintext highlighter-rouge">KERNEL_STACK</code> 这两个变量声明为 <code class="language-plaintext highlighter-rouge">static mut</code> 类型， 就能将这两块内存初始化为 <code class="language-plaintext highlighter-rouge">.bss</code> 段。</p>

<blockquote>
  <p><a href="https://course.rs/advance/global-variable.html">Rust语言圣经(Rust Course) - 4.7 全局变量</a></p>
</blockquote>

<h2 id="32-non-stable-rust-abi">3.2 Non Stable Rust ABI</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">KERNEL_STACK</span><span class="p">:</span> <span class="n">KernelStack</span> <span class="o">=</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">],</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">mut</span> <span class="n">USER_STACK</span><span class="p">:</span> <span class="n">UserStack</span> <span class="o">=</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">USER_STACK_SIZE</span><span class="p">],</span>
<span class="p">};</span>

<span class="k">impl</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">KERNEL_STACK_SIZE</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cx_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="nf">.get_sp</span><span class="p">()</span> <span class="o">-</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TrapContext</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">cx_ptr</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">cx_ptr</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在此处 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1186485130">issue - whfuyn</a> 提出了两个问题， <code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__alltraps</code> 段在最后调用了 <code class="language-plaintext highlighter-rouge">trap_handler</code> 以处理 <code class="language-plaintext highlighter-rouge">trap</code> 的内容， 但 Rust ABI 是 unstable 的， 我在这篇文章 <a href="https://viruta.org/rust-stable-abi.html">“Rust does not have a stable ABI” - Federico’s Blog</a> 中找到了相应的解释， 虽然对 ABI 的作用还是理解不是很深刻， 但也理解了为什么 <code class="language-plaintext highlighter-rouge">src/context.rs</code> 中的 <code class="language-plaintext highlighter-rouge">TrapContext</code> 会写成下面这种形式。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TrapContext</span> <span class="p">{</span>
    <span class="cd">/// general regs[0..31]</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">32</span><span class="p">],</span>
    <span class="cd">/// CSR sstatus      </span>
    <span class="k">pub</span> <span class="n">sstatus</span><span class="p">:</span> <span class="n">Sstatus</span><span class="p">,</span>
    <span class="cd">/// CSR sepc</span>
    <span class="k">pub</span> <span class="n">sepc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 的声明使得字段的顺序、 大小以及对齐方式与 C 中完全一致。 <code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 结构体使得结构体的对齐量为 <strong>最大对齐量的字段</strong>， 字段的尺寸和偏移量由以下算法决定：</p>

<ol>
  <li>
    <p>把当前偏移量设为从 0 字节开始。</p>
  </li>
  <li>
    <p>对于结构体中的每个字段， 按其声明的先后顺序， 首先确定其尺寸和对齐量； 如果当前偏移量不是对其齐量的整倍数， 则向当前偏移量添加填充字节， 直至其对齐量的倍数1； 至此， 当前字段的偏移量就是当前偏移量； 下一步再根据当前字段的尺寸增加当前偏移量。</p>
  </li>
  <li>
    <p>最后， 整个结构体的尺寸就是当前偏移量向上取整到结构体对齐量的最小整数倍数。</p>
  </li>
</ol>

<blockquote>
  <p><a href="https://nomicon.purewhite.io/other-reprs.html">Rust 秘典（死灵书）- 2.3 可选的数据布局</a><br />
<a href="https://rustwiki.org/zh-CN/reference/type-layout.html">Rust 参考手册 中文版 - 10.3 类型布局</a></p>
</blockquote>

<h3 id="33-static-mut-与-unsafecell">3.3 static mut 与 UnSafeCell</h3>

<p>同样是 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1186485130">issue - whfuyn</a> 提出的问题， 可以看到原来的 <code class="language-plaintext highlighter-rouge">KernelStack</code> 结构体实现了 <code class="language-plaintext highlighter-rouge">fn get_sp</code> 以及 <code class="language-plaintext highlighter-rouge">pub fn push_context</code> 两个函数， 但是这两个函数都使用 <code class="language-plaintext highlighter-rouge">&amp;self</code> 共享不可变引用。 毫无疑问 <code class="language-plaintext highlighter-rouge">self.data</code> 访问了 <code class="language-plaintext highlighter-rouge">KernelStack</code> 的内部量， 并且在 <code class="language-plaintext highlighter-rouge">push_context</code> 中我们将指针的地址强制转换为了一个 <strong>可变裸指针</strong>， 裸指针的解引用是不安全的， 没有借用和声明周期的检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">KERNEL_STACK_SIZE</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cx_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="nf">.get_sp</span><span class="p">()</span> <span class="o">-</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TrapContext</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">cx_ptr</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">cx_ptr</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>The Rust Reference</strong> 对内部可变性的定义是这样的：</p>

<dl>
  <dt>interior mutability</dt>
  <dd>A type has interior mutability if its internal state can be changed through a shared reference to it.</dd>
</dl>

<p>显然这违反了共享引用（类似 <code class="language-plaintext highlighter-rouge">&amp;self</code>）所指向的值不变的要求。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 是唯一允许的方式达到内部可变性， <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> 的内部实现也是通过 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 达到的。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 使用了 <code class="language-plaintext highlighter-rouge">#[lang = "unsafe_cell"]</code> 宏以让编译器对其进行特殊处理， 使其不具备声明周期的 <strong>协/逆变</strong> 特性。 因而我们要实现内部可变性必须通过 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 以避免未定义行为， 我们无法处理生命周期的问题。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 能够实现从不可变引用到 <strong>可变裸指针</strong> 的安全转换， 我们尽可能多的将安全检查问题交给编译器。</p>

<p>原来的 <code class="language-plaintext highlighter-rouge">batch.rs</code> 使用 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 后的版本可查看 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/8fbb8e0f506d23ae958414bf085a2580b29e4472">commit#8fbb8e0</a>。</p>

<blockquote>
  <p><a href="https://github.com/rust-lang-nursery/lazy-static.rs/issues/117">(soundness regression) static mut could be avoided. #117 - rust-lang-nursery/lazy-static.rs</a><br />
<a href="https://github.com/rust-lang/rust/issues/53639">Consider deprecation of UB-happy static mut #53639 - rust-lang/rust</a><br />
<a href="https://zhuanlan.zhihu.com/p/598708941">关于 Rust 的 UnsafeCell、Cell 与 RefCell - 知乎</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/miri.html">Rust语言圣经(Rust Course) - 13.6.3 Miri</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/stacked-borrow.html">Rust语言圣经(Rust Course) - 13.6.4 栈借用</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/testing-stacked-borrow.html">Rust语言圣经(Rust Course) - 13.6.5 测试栈借用</a><br />
<a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/core/cell/struct.UnsafeCell.html">Struct core::cell::UnsafeCell</a><br />
<a href="https://doc.rust-lang.org/stable/reference/interior-mutability.html">The Rust Reference - 10.4. Interior mutability</a></p>
</blockquote>

<h3 id="34-关于-trap">3.4 关于 trap</h3>

<p>在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 中， 对于 <code class="language-plaintext highlighter-rouge">Exception::UserEnvCall</code> 异常， 有一个更新 <code class="language-plaintext highlighter-rouge">sepc</code> 寄存器信息的指令为 <code class="language-plaintext highlighter-rouge">cx.sepc += 4</code>， 根据 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1573703987">issue</a> 中的一条回答是这样解释的：</p>

<blockquote>
  <p>中断和异常的触发方式不同， 因此硬件设置的“默认执行的下一条指令的地址”也不同。 异常是由于一条指令的执行触发的， 此时硬件默认会将 <code class="language-plaintext highlighter-rouge">sepc</code> 仍然设置为这条指令的地址， 等内核处理完之后再执行一次， 期待这次指令能够正常执行； 而中断是在一条指令执行完毕之后， CPU 检测到了中断， 此时硬件会将 <code class="language-plaintext highlighter-rouge">sepc</code> 设置为下一条指令的地址， 因为没有任何理由再执行一次刚刚执行完的指令。</p>
</blockquote>

<h2 id="4-课后练习">4 课后练习</h2>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li><em><strong>实现一个裸机应用程序 A， 能打印调用栈。</strong></em>
    <div align="center">
     <img src="/norobots/images/2023-06-23-rcore-note-ch2/StackFrame.png" alt="Stack Frame, rCore" width="600" />
     <br />
     <font size="2" color="#999"><u>Stack Frame, rCore</u></font>
 </div>

    <p>根据 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html">第一章 - 为内核支持函数调用</a> 描述的 RISC-V 的栈帧结构， 对第一章的编程题进行更改实现即可， 主要改动还是 <code class="language-plaintext highlighter-rouge">asm</code> 中的内容。 具体可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/blob/main/os/src/stack_btrace.rs">stack_btrace.rs</a>。</p>
  </li>
  <li>
    <p><em><strong>扩展内核， 实现新系统调用 <code class="language-plaintext highlighter-rouge">get_taskinfo</code>， 能显示当前 task 的 id 和 task name； 实现一个裸机应用程序 B， 能访问 <code class="language-plaintext highlighter-rouge">get_taskinfo</code> 系统调用。</strong></em></p>

    <p>这部分真的折磨， 实在是想不到裸机情况下怎么获取 bin 文件的 prefix 名称， 考虑过添加 bin 文件 header 的方式但想想还是奇怪。 主要思路是考虑在 <code class="language-plaintext highlighter-rouge">APP_MANAGER</code> 中就把这部分信息填好， 能力有限不搞了。</p>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计多个应用的执行过程中系统调用编号和访问此系统调用的次数。</strong></em></p>

    <p>这部分第一个想法就是用哈希表， 找了挺久发现一个 <a href="https://crates.io/crates/hashbrown">hashbrown</a> 库是能用在 no_std 环境的。 我实现了 <code class="language-plaintext highlighter-rouge">os/src/syscall/stats.rs</code> 提供了两个函数分别是 <code class="language-plaintext highlighter-rouge">stats_update</code>（放在 trap_handler 的 <code class="language-plaintext highlighter-rouge">UserEnvCall</code> 异常） 以及 <code class="language-plaintext highlighter-rouge">stats_clear_and_print</code>（放在 <code class="language-plaintext highlighter-rouge">run_next_app</code> 之前）。 但是遇到一个问题， 但是当前的 OS 实现下是不能使用 heap 存储 static 变量的信息的， 需要之后再进行测试。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> error: no global memory allocator found but one is required<span class="p">;</span>
 <span class="nb">link </span>to std or add <span class="sb">`</span><span class="c">#[global_allocator]` to a static item that implements the GlobalAlloc trait</span>
</code></pre></div>    </div>

    <blockquote>
      <p><a href="https://juejin.cn/s/rust%20no%20std%20hash_map">rust no std hash_map - 稀土掘金</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计每个应用执行后的完成时间。</strong></em></p>

    <p>原来想用 <a href="https://crates.io/crates/embedded-time">embedded-time</a> 这个库替代标准库中的 time crate， 但是那个 Clock Trait 需要知悉硬件的信息才能实现就放弃了这个想法。 记得在第一章作业的 comment 有人提了一嘴有 time 相关的寄存器， 而且在 qemu 中这个 time 相关的时钟频率是 10 KHz。 所幸 riscv 库提供了这部分寄存器的读写， 只要在 <code class="language-plaintext highlighter-rouge">run_next_app</code> 函数的开始记录程序开始的时刻， 另外就是在异常退出或者 exit 函数调用中的 <code class="language-plaintext highlighter-rouge">run_next_app</code> 函数前获取时间间隔即可。</p>

    <blockquote>
      <p>需要注意 u64 整数溢出以及可能出现的时刻点信息未获取为空的情况， 可以考虑使用 <code class="language-plaintext highlighter-rouge">Option</code>。 具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/ce558ec5c6a6cf1610e8e74e7a5c57fe1b4db6bb">comment#ce558ec</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 统计执行异常的程序的异常情况（主要是各种特权级涉及的异常）， 能够打印异常程序的出错的地址和指令等信息。</strong></em></p>

    <p>编程题的设计好奇怪啊， 各种穿插， 直接仿照参考部分加上一些异常情况的处理， 具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d7f16c747fdd5b5e38bb97a87486f8a80bac9a27">commit#d7f16c7</a>。</p>
  </li>
</ol>

<h3 id="42-实验练习">4.2 实验练习</h3>

<h4 id="421-sys_write-安全检查">4.2.1 sys_write 安全检查</h4>

<p>相关实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch2-lab">ch2-lab</a>， 主要想法就是检查当前传入的 <code class="language-plaintext highlighter-rouge">buf</code> 地址的合法性。</p>

<dl>
  <dt>应用空间合法性</dt>
  <dd>app 经过 <code class="language-plaintext highlighter-rouge">load_app</code> 函数已经加载到了指定的内存空间中， 因而我们需要检查传入的 <code class="language-plaintext highlighter-rouge">buf</code> 指针所处位置是否在 <strong>[APP_BASE_ADDRESS, APP_BASE_ADDRESS + APP_SIZE_LIMIT]</strong> 之间， 即检查应用空间的合法性。</dd>
  <dt>用户栈空间合法性</dt>
  <dd>需要注意的是， 栈是从上往下生长的， 因而获取栈指针之后， 我们需要检查 <code class="language-plaintext highlighter-rouge">buf</code> 可能在用户栈的范围是 <strong>[USER_STACK_PTR_ADDR - USER_STACK_SIZE, USER_STACK_PTR_ADDR]</strong>。</dd>
</dl>

<h4 id="422-问答题">4.2.2 问答题</h4>

<ol>
  <li>
    <p><em>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请自行测试这些内容 (运行 Rust 三个 bad 测例 ) ，描述程序出错行为，注明你使用的 sbi 及其版本。</em></p>

    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">bad_address.rs</code>， <code class="language-plaintext highlighter-rouge">bad_instruction.rs</code>， <code class="language-plaintext highlighter-rouge">bad_register.rs</code> 运行的结果如下：</p>

      <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SBI及其版本信息： RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0</span>
<span class="o">[</span>kernel] Loading app_5
<span class="o">[</span>kernel] PageFault <span class="k">in </span>application, kernel killed it.
<span class="o">[</span>kernel] Loading app_6
<span class="o">[</span>kernel] IllegalInstruction <span class="k">in </span>application, kernel killed it.
<span class="o">[</span>kernel] Loading app_7
<span class="o">[</span>kernel] IllegalInstruction <span class="k">in </span>application, kernel killed it.
</code></pre></div>      </div>

      <ul>
        <li><code class="language-plaintext highlighter-rouge">bad_address.rs</code> 出现 <code class="language-plaintext highlighter-rouge">PageFault</code> 是因为非法访问了 0 地址空间并尝试对其进行值写入， 而程序的起始地址是 <code class="language-plaintext highlighter-rouge">0x80400000</code>。</li>
        <li><code class="language-plaintext highlighter-rouge">bad_instruction.rs</code> 以及 <code class="language-plaintext highlighter-rouge">bad_register.rs</code> 分别因为在 U Mode 调用了 <code class="language-plaintext highlighter-rouge">sret</code> S 特权级指令以及访问了 <code class="language-plaintext highlighter-rouge">sstatus</code> S 特权级寄存器而出错。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>请结合用例理解 <a href="https://github.com/rcore-os/rCore-Tutorial-v3/blob/ch2/os/src/trap/trap.S">trap.S</a> 中两个函数 <code class="language-plaintext highlighter-rouge">__alltraps</code> 和 <code class="language-plaintext highlighter-rouge">__restore</code> 的作用，并回答如下几个问题:</em></p>

    <ul>
      <li><em>L40： 刚进入 <code class="language-plaintext highlighter-rouge">__restore</code> 时， <code class="language-plaintext highlighter-rouge">a0</code> 代表了什么值。请指出 <code class="language-plaintext highlighter-rouge">__restore</code> 的两种使用情景。</em>
        <blockquote>
          <p>这个问题我在 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1611036350">chapter2 issues</a> 中有进行回答， 应当为 kernel 的 <code class="language-plaintext highlighter-rouge">sp</code>。</p>

          <ul>
            <li><code class="language-plaintext highlighter-rouge">__restore</code> 可以初始化内核栈以及用户栈指针地址， 进行用户态程序的加载， S Mode =&gt; U Mode；</li>
            <li>除此之外， 可以进行 trap 后的上下文恢复回到用户态。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L46-L51： 这几行汇编代码特殊处理了哪些寄存器？ 这些寄存器的的值对于进入用户态有何意义？ 请分别解释。</em>
        <blockquote>

          <pre><code class="language-asm">ld t0, 32*8(sp)   # 从内核栈中读取 sstatus 值
ld t1, 33*8(sp)   # 从内核栈中读取 spec 值
ld t2, 2*8(sp)    # 从内核栈中读取 sscratch 值
# 以下分别将读取的值写入对应的 CSR 特殊寄存器中
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
</code></pre>

          <ul>
            <li><code class="language-plaintext highlighter-rouge">sstatus</code> 表示程序状态， 其中的 SPP 指明了上一个状态时 U Mode， 可以帮助我们恢复到用户态。</li>
            <li><code class="language-plaintext highlighter-rouge">sepc</code> 其实就是 S Mode 下的 <code class="language-plaintext highlighter-rouge">pc</code>， 可以指定用户态的程序的入口位置。</li>
            <li><code class="language-plaintext highlighter-rouge">sscratch</code> 可以用来交换内核态与用户态的 <code class="language-plaintext highlighter-rouge">sp</code> 寄存器的值。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L53-L59： 为何跳过了 <code class="language-plaintext highlighter-rouge">x2</code> 和 <code class="language-plaintext highlighter-rouge">x4</code>？</em>
        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">sp(x2)</code> 是栈指针， 我们需要使用栈指针来定位缓存在内核栈和用户栈中的寄存器的位置； <code class="language-plaintext highlighter-rouge">tp(x4)</code> 是线程指针寄存器， 对于 uni-processor 而言用不到。</p>
        </blockquote>
      </li>
      <li><em>L63：该指令之后， <code class="language-plaintext highlighter-rouge">sp</code> 和 <code class="language-plaintext highlighter-rouge">sscratch</code> 中的值分别有什么意义？</em>
        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">sp</code> 中存储的是用户栈栈顶的 <code class="language-plaintext highlighter-rouge">sp</code>， <code class="language-plaintext highlighter-rouge">sscratch</code> 中存储的是内核栈栈顶的 <code class="language-plaintext highlighter-rouge">sp</code>。</p>
        </blockquote>
      </li>
      <li><em><code class="language-plaintext highlighter-rouge">__restore</code> 中发生状态切换在哪一条指令？ 为何该指令执行之后会进入用户态？</em>
        <blockquote>
          <p>状态切换发生在 <code class="language-plaintext highlighter-rouge">sret</code> 指令。<code class="language-plaintext highlighter-rouge">csrw sstatus, t0</code> 中将特权级设置为 U， <code class="language-plaintext highlighter-rouge">sstatus</code> 的 <code class="language-plaintext highlighter-rouge">SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息， 可以从多个方面控制 S 特权级的 CPU 行为和执行状态。 在 <code class="language-plaintext highlighter-rouge">sret</code> 执行后硬件会做这两件事：</p>

          <ul>
            <li>CPU 会将当前的特权级按照 <code class="language-plaintext highlighter-rouge">sstatus</code> 的 <code class="language-plaintext highlighter-rouge">SPP</code> 字段设置为 U；</li>
            <li>CPU 会跳转到 <code class="language-plaintext highlighter-rouge">sepc</code> 寄存器指向的那条指令， 然后继续执行。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L13：该指令之后， <code class="language-plaintext highlighter-rouge">sp</code> 和 <code class="language-plaintext highlighter-rouge">sscratch</code> 中的值分别有什么意义？</em>
        <blockquote>
          <p>与 L63 行为正好相反。</p>
        </blockquote>
      </li>
      <li><em>从 U 态进入 S 态是哪一条指令发生的？</em>
        <blockquote>
          <p>进入 Trap 之前会有 syscall， 而 syscall 的第一句就是 <code class="language-plaintext highlighter-rouge">ecall</code>， 调用完就切换状态了。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><em>对于任何中断， <code class="language-plaintext highlighter-rouge">__alltraps</code> 中都需要保存所有寄存器吗？ 你有没有想到一些加速 <code class="language-plaintext highlighter-rouge">__alltraps</code> 的方法？ 简单描述你的想法。</em></p>

    <blockquote>
      <p>可以仅保存内核态中断服务程序所必须的状态， 包括CPU寄存器、 内核堆栈、 硬件中断等参数。 <a href="https://www.cnblogs.com/mysky007/p/12306407.html">[参考]</a></p>
    </blockquote>
  </li>
</ol>

<h2 id="5-调试记录">5 调试记录</h2>

<h3 id="51-no_std-引入的错误">5.1 <em>no_std</em> 引入的错误</h3>

<p>使用了 <code class="language-plaintext highlighter-rouge">#![no_std]</code> 之后 rust-analyzer 会注释一个 “can’t find crate for <code class="language-plaintext highlighter-rouge">test</code>” 错误， 看着突兀的红色警告很是不爽。 rCore-Tutorial-v3 的 <code class="language-plaintext highlighter-rouge">.vscode/setting.json</code> 通过更改 rust-analyzer 的配置来尝试解决问题， 但是我在尝试 Google 搜索的所有结果后都没有解决问题。 但在 rust 社区我找到了一条帖子 <a href="https://users.rust-lang.org/t/error-e0463-cant-find-crate-for-test/73098">[error[E0463]: can’t find crate for <code class="language-plaintext highlighter-rouge">test</code>]</a>， 确实能消除这类报错并且不会对编译以及输出产生影响。 而我们所要做的更改也非常简单， 只需要在根文件 <code class="language-plaintext highlighter-rouge">main.rs</code> 中加入以下代码即可。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![reexport_test_harness_main</span> <span class="nd">=</span> <span class="s">"test_main"</span><span class="nd">]</span>
<span class="nd">#![feature(custom_test_frameworks)]</span>
<span class="nd">#![test_runner(test_runner)]</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_runner</span><span class="p">(</span><span class="n">_test</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="52-在-no_std-环境下增加-test-用例">5.2 在 no_std 环境下增加 test 用例</h3>

<p>挖的坑还是要填的， 知其然知其所以然， 写 chapter2 的编程题的时候就在想可能得用到测试用例测试函数， 不然堆在主干代码中非常难管理。 所幸有人已经在如何实现 <strong>自定义框架测试</strong> 这块进行了研究了， 照着知乎这篇文章按流程分析， 我找到了 <a href="https://github.com/rust-osdev/bootimage">rust-osdev/bootimage</a> 这个库， 它几乎能满足 qemu 创建 test 的所有需求但是目前仅支持 x86 架构， 这意味当前 rCore 使用 test 测试的构想落空了。</p>
<blockquote>
  <p>不枉我耗了一个晚上去找资料， 只能用朴素的办法了。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="nd">#![reexport_test_harness_main</span> <span class="nd">=</span> <span class="s">"test_main"</span><span class="nd">]</span> <span class="c1">// 创建新的 test 的入口函数</span>
<span class="nd">#![feature(custom_test_frameworks)]</span> <span class="c1">// 自定义 test 框架的属性声明</span>
<span class="nd">#![test_runner(test_runner)]</span> <span class="c1">// test 执行函数为 test_runner</span>
<span class="nd">#[no_mangle]</span> <span class="c1">// avoid compiler confusion</span>
<span class="k">fn</span> <span class="nf">rust_main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="nf">test_main</span><span class="p">();</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span> <span class="c1">// 保证该函数仅在 test 情形下生成</span>
<span class="k">fn</span> <span class="nf">test_runner</span><span class="p">(</span><span class="n">tests</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()])</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Running {} tests"</span><span class="p">,</span> <span class="n">tests</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">for</span> <span class="n">test</span> <span class="k">in</span> <span class="n">tests</span> <span class="p">{</span>
        <span class="nf">test</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://os.phil-opp.com/testing/">Writing an OS in Rust - Testing, Philipp Oppermann’s blog</a><br />
<a href="https://zhuanlan.zhihu.com/p/90758552">使用Rust编写操作系统（四）：内核测试 - 知乎</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第二章：批处理系统， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 1</title><link href="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 1" /><published>2023-06-19T00:00:00+08:00</published><updated>2023-06-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/19/rcore-note-ch1</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html"><![CDATA[<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第一章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rcore-sp23/tree/ch1">[ch1]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-为内核支持函数调用">1. 为内核支持函数调用</h2>

<h3 id="11-导读问答">1.1 导读问答</h3>

<ul>
  <li>
    <p><em>如何使得函数返回时能够跳转到调用该函数的下一条指令，即使该函数在代码中的多个位置被调用？</em></p>

    <blockquote>
      <p>RISC-V 中 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器 （即 <code class="language-plaintext highlighter-rouge">x1</code> 寄存器） 是用来保存函数的返回地址的， 函数调用时会使用相关的跳转指令 <code class="language-plaintext highlighter-rouge">jal</code> 或者 <code class="language-plaintext highlighter-rouge">jalr</code>， 这两条指令都会在函数调用前将 <code class="language-plaintext highlighter-rouge">pc+4</code> 即下一条指令的地址存入 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器， 一般情况下 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器会选为 <code class="language-plaintext highlighter-rouge">ra</code>。 在函数需要返回时， 只需要通过 <code class="language-plaintext highlighter-rouge">ret</code> 汇编伪指令， 即可使主程序继续在 <code class="language-plaintext highlighter-rouge">ra</code> 保存的物理地址继续执行， 这里 <code class="language-plaintext highlighter-rouge">ret</code> 伪指令会被解析为 <code class="language-plaintext highlighter-rouge">jalr x0, 0(ra)</code>。 但在使用 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器时需要注意函数调用上下文， 保证控制流转移前后特定的寄存器值保持不变。</p>
    </blockquote>
  </li>
  <li>
    <p><em>对于一个函数而言，保证它调用某个子函数之前，以及该子函数返回到它之后（某些）通用寄存器的值保持不变有何意义？</em></p>

    <blockquote>
      <p>这些特定的寄存器分为 <em><strong>Caller-Saved</strong></em> 和 <em><strong>Callee-Saved</strong></em> 两类， 对于编译器而言， 每个函数的编译是独立的， 子函数的寄存器是未知的， 这些寄存器的值的改变可能会影响整个函数的运行。 例如 <code class="language-plaintext highlighter-rouge">ra</code> 在嵌套函数调用中， 若没有保存通用寄存器的值， 可能会因子函数覆盖了 <code class="language-plaintext highlighter-rouge">ra</code> 的值而使得控制流出现混乱。 因而保证这些特定的通用寄存器的值保持不变可以保证 <strong>多层嵌套调用</strong> 的正确， 以及实现对寄存器的复用 （寄存器资源非常珍贵）。</p>
    </blockquote>
  </li>
  <li>
    <p><em>调用者函数和被调用者函数如何合作保证调用子函数前后寄存器内容保持不变？调用者保存和被调用者保存寄存器的保存与恢复各自由谁负责？它们暂时被保存在什么位置？它们于何时被保存和恢复（如函数的开场白/退场白）？</em></p>

    <blockquote>
      <p>需要依据 <strong>Calling Convention</strong> 对各自需要保存的寄存器进行保存， 正如 <strong>Caller-Saved</strong> 和 <strong>Callee-Saved</strong> 二者的字面含义， 调用者保存寄存器就由调用函数保存， 被调用者寄存器则由被调用函数保存， 这些寄存器都被保存在 <strong>栈帧</strong> 上。 一般在被调用函数开始时会保存这些寄存器， 而在被调用函数结束时会恢复寄存器， 这对于 <strong>Caller</strong> 和 <strong>Callee</strong> 而言是一致的。</p>
    </blockquote>
  </li>
  <li>
    <p><em>在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分的？</em></p>

    <blockquote>
      <p>主要还是根据 <strong>调用规范</strong>（Calling Convention）</p>

      <ul>
        <li>a0~a7（<code class="language-plaintext highlighter-rouge">x10~x17</code>）， 用来传递输入参数， 其中的 a0 和 a1 还用来保存返回值。 <strong>调用者保存</strong>。</li>
        <li>t0~t6(<code class="language-plaintext highlighter-rouge">x5~x7</code>, <code class="language-plaintext highlighter-rouge">x28~x31</code>)， 作为临时寄存器使用，在被调函数中可以随意使用无需保存。</li>
        <li>s0~s11(<code class="language-plaintext highlighter-rouge">x8~x9</code>, <code class="language-plaintext highlighter-rouge">x18~x27</code>)， 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 <strong>被调用者保存</strong>。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>sp</em> 和 <em>ra</em> 是调用者还是被调用者保存寄存器，为什么这样约定？</p>

    <blockquote>
      <ul>
        <li>ra(<code class="language-plaintext highlighter-rouge">x1</code>) 是被调用者保存的。 被调用者函数可能也会调用函数， 在调用之前就需要修改 <code class="language-plaintext highlighter-rouge">ra</code> 使得这次调用能正确返回。 因此，每个函数都需要在开头保存 <code class="language-plaintext highlighter-rouge">ra</code> 到自己的栈帧中，并在结尾使用 <code class="language-plaintext highlighter-rouge">ret</code> 返回之前将其恢复。</li>
        <li>sp(<code class="language-plaintext highlighter-rouge">x2</code>) 是被调用者保存的。sp 是栈指针 (Stack Pointer) 寄存器， 它指向下一个将要被存储的栈顶位置。 sp 寄存器和 fp 寄存器构成了当前栈帧的空间范围， 同样的被调用函数也会调用其他函数， 这会更新栈帧， 所以 sp 以及 fp 都约定为被调用者保存寄存器。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>如何使用寄存器传递函数调用的参数和返回值？如果寄存器数量不够用了，如何传递函数调用的参数？</em></p>

    <blockquote>
      <p>a0~a7 可用以传递函数参数， 而 a0， a1 则用以保存函数返回值。 若寄存器数量不足， 可以通过栈进行参数传递， 在参数压栈结束后， 可以在 a0 或者 a1 中保存当前 sp 的值 （栈顶位置）， 通过偏移获取栈中保存的参数。</p>
    </blockquote>
  </li>
</ul>

<h3 id="12-程序解释与问题记录">1.2 程序解释与问题记录</h3>

<p>在该章节的评论区讨论最多的是 <code class="language-plaintext highlighter-rouge">extern "C"</code> 以及 <code class="language-plaintext highlighter-rouge">*mut u8</code> 裸指针转换的问题， 下面的代码是更改完善后的。 linker script 中的全局变量定义后， 在 C 语言中可以通过 <code class="language-plaintext highlighter-rouge">extern int x</code> 这种形式导入， 这在 rust 中也是可以通过类似的方式实现的， 可以参考 <a href="https://github.com/rustsbi/rustsbi-qemu/blob/main/rustsbi-qemu/src/main.rs#L70">rustsbi</a> 中的方式。 另外， 根据 <em>Rust 程序设计语言</em> 中的 <em>19.1不安全的 Rust: 解引用裸指针</em> 中的 <a href="https://kaisery.github.io/trpl-zh-cn/ch19-01-unsafe-rust.html#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88">描述</a> <code class="language-plaintext highlighter-rouge">(ptr as *mut u8)</code> 实际是将 <code class="language-plaintext highlighter-rouge">ptr</code> 所指向的 64 位地址转为 <code class="language-plaintext highlighter-rouge">u8</code> 类型的可变指针， <code class="language-plaintext highlighter-rouge">ptr.write_volatile(0)</code> 方法将 0 写入指针类型 <code class="language-plaintext highlighter-rouge">ptr</code> 存储的地址所指向的 1 字节内存区域。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">clear_bss</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">sbss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">ebss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">sbss</span> <span class="k">as</span> <span class="nb">usize</span><span class="o">..</span><span class="n">ebss</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">ptr</span><span class="p">|{</span>
                <span class="c1">// use volatile to avoid compiler optimization</span>
                <span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span><span class="nf">.write_volatile</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="error">但是这种 <code class="language-plaintext highlighter-rouge">static mut var: u64</code> 的实现办法后来在调用 <code class="language-plaintext highlighter-rouge">info!</code> 这类 log 打印的时候出现了问题， 提示找不到 <code class="language-plaintext highlighter-rouge">ebss</code> 所在位置， 或者有几个全局变量的值无法正确读取， 但 <code class="language-plaintext highlighter-rouge">恢复成 fn ebss()</code> 就可以了。</p>

<p>另外关于栈中在 linker script 中被置于 <code class="language-plaintext highlighter-rouge">.bss</code> 段也有讨论， 在 <em>程序员的修养——链接、装载与库</em> 中就有提及</p>

<div style="font-weight: bold; font-style: italic;">
<p>
“链接器为目标文件分配地址和空间” 这句话中的 “地址和空间” 其实有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。
</p>
</div>

<p>对于 <code class="language-plaintext highlighter-rouge">.bss</code> 这样的段来说， 分配空间的意义只局限于虚拟地址空间， 因为它在文件中并没有内容。 对于栈的初始化而言， 将其置于 <code class="language-plaintext highlighter-rouge">.bss</code> 段可避免其占用实际的 ELF 文件的空间， 但在后续加载内核内核后， 该部分栈会被分配到 VMA 中占据一定的虚拟内存空间。</p>

<h2 id="2-rustsbi">2. RustSBI</h2>

<p>SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用 Rust 语言实现的 SBI。 RustSBI 的功能和 u-boot(SPL) 很类似但相较而言简单很多， 只需要在 boot 阶段为上层应用完成初始化工作后转移控制权给内核。 但是， RustSBI 又直接构成了内核和硬件沟通的桥梁， 为操作系统提供一系列二进制接口，以便其获取和操作硬件信息， RustSBI 能在内核运行时响应内核的请求为内核提供服务。</p>

<p>Western Digital 在 2019 年 12 月的一份 <a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf"><em>An Introduction to RISC-V Boot Flow</em></a> 报告中有这么一幅流程图阐述了 RISC-V 的 boot 流程。</p>

<div align="center">
    <img src="/norobots/images/2023-06-19-rcore-note-ch1/riscv-upstream-boot-flow.png" alt="RISC-V Upstream Boot Flow, Western Digital" width="800" />
    <br />
    <font size="2" color="#999"><u>RISC-V Upstream Boot Flow, Western Digital</u></font>
</div>

<p>这里引用 <a href="https://github.com/denglj">dengji</a> 在附录 C 评论中对 boot 流程以及对 RISV-V SBI 的解释：</p>

<ul>
  <li><strong>Loader</strong> 要干的事情，就是内存初始化， 以及加载 Runtime 和 BootLoader 程序。 而Loader自己也是一段程序，常见的Loader就包括 BIOS/UEFI， 后者是前者的继任者。</li>
  <li><strong>Runtime</strong> 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，为 OS 提供服务，当我们要在同一套硬件系统中运行不同的操作系统， 或者做硬件级别的虚拟化时， 就离不开Runtime 服务的支持。 SBI 就是 RISC-V 架构的 Runtime 规范。</li>
  <li><strong>BootLoader</strong> 要干的事情包括文件系统引导、 网卡引导、 操作系统启动配置项设置、 操作系统加载等等。常见的 BootLoader 包括 GRUB，U-Boot，LinuxBoot 等。</li>
  <li>而 <strong>BIOS/UEFI</strong> 的大多数实现， 都是 Loader、 Runtime、 BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。 如果把 BIOS 当做一个泛化的术语使用， 而不是指某个具体实现的话， 那么可以认为 SBI 是 BIOS 的组成部分之一。</li>
</ul>

<blockquote>
  <p><a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">An Introduction to RISC-V Boot Flow</a><br />
<a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/appendix-c/index.html">附录 C：深入机器模式：RustSBI</a></p>
</blockquote>

<h2 id="3-print-与-println-宏">3. print 与 println 宏</h2>

<p>借机复习一下 macro， 被 <a href="https://dtolnay.github.io/rust-quiz/1">rust-quiz</a> 痛打的经历历历在目。 宏主要分为 <code class="language-plaintext highlighter-rouge">macro_rules!</code> 这样的声明宏以及 <code class="language-plaintext highlighter-rouge">procedural</code> 过程宏。 在一个文件中调用宏之前必须定义它， 或者将其引入作用域之中。 实现 <code class="language-plaintext highlighter-rouge">print!</code> 宏以及 <code class="language-plaintext highlighter-rouge">println!</code> 宏需要 <code class="language-plaintext highlighter-rouge">#[macro_export]</code> 注解表明引入改宏到作用域之中。 以 <code class="language-plaintext highlighter-rouge">print!</code> 宏为例， 由内向外展开分析， 需要记住 <a href="https://veykril.github.io/tlborm/decl-macros/macros-methodical.html#metavariables">2.1 A Methodical Introduction</a> 中 Repetition 原则， <code class="language-plaintext highlighter-rouge">$ (...) sep rep</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">print</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$fmt</span><span class="p">:</span> <span class="n">literal</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">:</span> <span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="nn">console</span><span class="p">::</span><span class="nf">print</span><span class="p">(</span><span class="nd">format_args!</span><span class="p">(</span><span class="nv">$fmt</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">println</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$fmt</span><span class="p">:</span> <span class="n">literal</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">:</span> <span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="nn">console</span><span class="p">::</span><span class="nf">print</span><span class="p">(</span><span class="nd">format_args!</span><span class="p">(</span><span class="nd">concat!</span><span class="p">(</span><span class="nv">$fmt</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">, $($arg: tt)+</code> 该部分会匹配由 <code class="language-plaintext highlighter-rouge">,</code> 分隔的一段重复序列， <code class="language-plaintext highlighter-rouge">+</code> 表示改重复部分至少出现一次， 重复的内容是 token tree， 它将被捕获存放在元变量 <code class="language-plaintext highlighter-rouge">arg</code> 中。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$($fmt: literal $(...)?)</code> 该部分有 <code class="language-plaintext highlighter-rouge">literal</code> fragment-specifier， 根据 <a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">The Rust Reference - 8.2.1. Literal expression</a> 中的描述， <em>literal expression</em> 是主要在编译阶段分析的常量表达式， 由单个 token 构成， 一般而言 <strong>CHAR， STRING， RAW STRING， BYTE， BYTE STRING， RAW BYTE STRING， INTEGER， FLOAT， BOOL</strong> 均为 literal 类型。 根据 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference - 3.1 Macros By Example</a> 中的描述， 在 MacroMatch <code class="language-plaintext highlighter-rouge">() =&gt; {}</code> 中应当由两组匹配模式， 一组是 <code class="language-plaintext highlighter-rouge">$fmt: literal</code> 对应 <code class="language-plaintext highlighter-rouge">$ ( IDENTIFIER_OR_KEYWORD except crate | RAW_IDENTIFIER | _ ) : MacroFragSpec</code>， 另一组就是 <code class="language-plaintext highlighter-rouge">$(, $($arg: tt)+)?</code>， 对应 <code class="language-plaintext highlighter-rouge">$ ( MacroMatch+ ) MacroRepSep? MacroRepOp</code>。</p>
  </li>
  <li>
    <p>Matcher 的右侧就是 MacroTranscriber， 可以看到我们使用了外部函数 <code class="language-plaintext highlighter-rouge">print</code>， 并用 <code class="language-plaintext highlighter-rouge">format_args!</code> 宏将 <code class="language-plaintext highlighter-rouge">$fmt $(, $($arg)+)?</code> 组装成完整的字符串， 这类似 C/C++ 中的 <code class="language-plaintext highlighter-rouge">sprintf</code>。 另外在 <code class="language-plaintext highlighter-rouge">println!</code> 中使用的 <code class="language-plaintext highlighter-rouge">concat!</code> 宏将多个字符串连接在一起。</p>
  </li>
</ul>

<blockquote>
  <p><a href="https://rustwiki.org/zh-CN/std/macro.format_args.html">rustwiki - Macro std::format_args</a><br />
<a href="https://doc.rust-lang.org/std/macro.concat.html">rust-lang doc - Macro std::concat</a><br />
<a href="https://doc.rust-lang.org/reference/index.html">The Rust Reference</a><br />
<a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a><br />
<a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">Rust 程序设计语言 - 19.5 宏</a></p>
</blockquote>

<h2 id="4-课后练习">4. 课后练习</h2>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li>
    <p><em>实现一个linux应用程序A，显示当前目录下的文件名。（用C或Rust编程）</em></p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">process</span><span class="p">::</span><span class="n">Command</span><span class="p">};</span>
 <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"ls"</span><span class="p">)</span><span class="nf">.arg</span><span class="p">(</span><span class="s">"-a"</span><span class="p">)</span><span class="nf">.output</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"failed to execute the process"</span><span class="p">);</span>
     <span class="k">let</span> <span class="n">file_list</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">output</span><span class="py">.stdout</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">file_list</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>实现一个linux应用程序B，能打印出调用栈链信息。（用C或Rust编程）</em></p>

    <div align="center">
     <img src="/norobots/images/2023-06-19-rcore-note-ch1/StackFrame.png" alt="Stack Frame, x86" width="400" />
     <br />
     <font size="2" color="#999"><u>Stack Frame, x86</u></font>
 </div>

    <p>根据文档描述， 栈帧存储着函数之间的调用信息， 当前栈帧的头部是 <em>sp(x1)</em> 指向的位置， 尾部是 <em>fp(s0)</em> 指向的位置。 其中 <code class="language-plaintext highlighter-rouge">fp</code> 寄存器中保存了父栈帧的结束地址， x86 架构的结构与 RISC-V 有所不同， <code class="language-plaintext highlighter-rouge">rbp</code> 存储的内容就是父栈帧的 <code class="language-plaintext highlighter-rouge">rbp</code> 地址。 另外， 在调试过程中发现有 <code class="language-plaintext highlighter-rouge">stack overflow</code> 的错误， 参考给出解释需要用到 <code class="language-plaintext highlighter-rouge">libunwind</code> 库解决标准库不存储栈帧指针的问题， 遂仅进行有限个栈帧回溯。 注意需要开启 <code class="language-plaintext highlighter-rouge">force-frame-pointers</code> 编译选项。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">arch</span><span class="p">::</span><span class="n">asm</span><span class="p">;</span>

 <span class="k">fn</span> <span class="nf">print_stack_trace_chain</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">let</span> <span class="n">fp</span><span class="p">:</span> <span class="nb">usize</span><span class="p">;</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"== STACK TRACE BEGIN"</span><span class="p">);</span>
     <span class="k">unsafe</span> <span class="p">{</span>
         <span class="nd">asm!</span> <span class="p">(</span>
             <span class="s">"mov {fp}, rbp"</span><span class="p">,</span>
             <span class="n">fp</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">fp</span><span class="p">,</span>
         <span class="p">);</span>
     <span class="p">}</span>

     <span class="k">let</span> <span class="k">mut</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
     <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
         <span class="nd">println!</span><span class="p">(</span><span class="s">" == {:#p}"</span><span class="p">,</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">);</span>
         <span class="n">fp</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
             <span class="p">(</span><span class="n">fp</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.offset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span>
         <span class="p">};</span>
     <span class="p">}</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"== STACK TRACE END"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>实现一个基于rcore/ucore tutorial的应用程序C，用sleep系统调用睡眠5秒（in rcore/ucore tutorial v3: Branch ch1）</em></p>

    <p>折腾半天读不到 MIE， SIP 寄存器的值， 暂时搁置了。</p>

    <blockquote>
      <p><a href="https://siriusdemon.github.io/Rare/v3-CSR.html">Rare: Rust A Riscv Emulator</a><br />
<a href="https://dingfen.github.io/risc-v/2020/08/05/riscv-privileged.html">RISC-V 特权架构</a></p>
    </blockquote>
  </li>
</ol>

<h3 id="42-问答题">4.2 问答题</h3>

<ol>
  <li>
    <p><em>应用程序在执行过程中， 会占用哪些计算机资源？</em></p>

    <blockquote>
      <p>CPU/GPU 计算资源， 内存/外存资源， 缓存资源等。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请用相关工具软件分析并给出应用程序A的代码段/数据段/堆/栈的地址空间范围。</em></p>

    <blockquote>
      <p>使用 <code class="language-plaintext highlighter-rouge">readelf -S pro1</code> 查看 section headers 信息， 我的程序的代码段地址空间为 [0x7080, 0x4ef04]， 数据段地址空间范围是 [0x65000, 0x65038] 这里有做地址对齐。 另外， 堆/栈的信息是动态分配的， 根据参考中的说明， 需要在后台查看 <code class="language-plaintext highlighter-rouge">/proc/[pid]/maps</code>。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请简要说明应用程序与操作系统的异同之处。</em></p>

    <blockquote>
      <p>应用程序和操作系统其实都可以被称作一种系统程序， 不同的是二者对于硬件的支配能力。 操作系统和硬件直接相关， 能够独立地运行在硬件设备上并对硬件以及外设进行控制， 它为上层的应用程序提供了服务与接口， 从这点可以看出， 应用程序对硬件的管理是间接的， 它需要向操作系统请求各种服务与功能， 这也是操作系统的隔离性与安全性要求。 另外， 应用程序一般默认被认定为恶意的， 反之操作系统是值得信任的。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请基于 QEMU 模拟 RISC—V 的执行过程和 QEMU 源代码， 说明 RISC-V 硬件加电后的几条指令在哪里？ 完成了哪些功能？</em></p>

    <blockquote>
      <p>对 QEMU 的执行流程不是太了解， 但按照前述的 boot flow， 第一阶段肯定是模拟 ROM 中的指令进行初始化， 在 <code class="language-plaintext highlighter-rouge">qemu7.0.0/hw/riscv/boot.c</code> 中可以找到 <code class="language-plaintext highlighter-rouge">riscv_setup_rom_reset_vec</code>， 相当于 ROM 的初始化设置， 具体的配置内容如 <code class="language-plaintext highlighter-rouge">reset_vec</code> 所示。</p>
    </blockquote>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/* reset vector */</span>
  <span class="kt">uint32_t</span> <span class="n">reset_vec</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mh">0x00000297</span><span class="p">,</span>                  <span class="cm">/* 1:  auipc  t0, %pcrel_hi(fw_dyn) */</span>
      <span class="mh">0x02828613</span><span class="p">,</span>                  <span class="cm">/*     addi   a2, t0, %pcrel_lo(1b) */</span>
      <span class="mh">0xf1402573</span><span class="p">,</span>                  <span class="cm">/*     csrr   a0, mhartid  */</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="mh">0x00028067</span><span class="p">,</span>                  <span class="cm">/*     jr     t0 */</span>
      <span class="n">start_addr</span><span class="p">,</span>                  <span class="cm">/* start: .dword */</span>
      <span class="n">start_addr_hi32</span><span class="p">,</span>
      <span class="n">fdt_load_addr</span><span class="p">,</span>               <span class="cm">/* fdt_laddr: .dword */</span>
      <span class="n">fdt_load_addr_hi32</span><span class="p">,</span>
                                   <span class="cm">/* fw_dyn: */</span>
  <span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">riscv_is_32bit</span><span class="p">(</span><span class="n">harts</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0202a583</span><span class="p">;</span>   <span class="cm">/*     lw     a1, 32(t0) */</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0182a283</span><span class="p">;</span>   <span class="cm">/*     lw     t0, 24(t0) */</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0202b583</span><span class="p">;</span>   <span class="cm">/*     ld     a1, 32(t0) */</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0182b283</span><span class="p">;</span>   <span class="cm">/*     ld     t0, 24(t0) */</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p>AUIPC (add upper immediate to pc)， 其作用是计算 PC 的相对地址并将结果存储在 rd 中。 根据 <a href="https://sourceware.org/binutils/docs/as/RISC_002dV_002dModifiers.html">9.38.3 RISC-V Assembler Modifiers</a> 中的描述， <code class="language-plaintext highlighter-rouge">%pcrel_hi</code> 以及 <code class="language-plaintext highlighter-rouge">%pcrel_lo</code> 的定义为：</p>

      <dl>
        <dt>%pcrel_hi(symbol)</dt>
        <dd>The high 20 bits of relative address between pc and symbol.</dd>
        <dt>%pcrel_lo(label)</dt>
        <dd>The low 12 bits of relative address between pc and symbol.</dd>
      </dl>

      <p>另外需要注意的是 <code class="language-plaintext highlighter-rouge">1b</code> 实际上是 RISC-V 汇编 Label 的一种写法， 拆开来是 <strong>1</strong> <strong>backward</strong>， 表示在 <strong>1</strong> 这个标签值之后的标签。 同样道理可能会出现 <code class="language-plaintext highlighter-rouge">1f</code>， 意思就正好相反表示在 <strong>1</strong> 这个标签之前。 也就是前两句实际是处理 Code Independent 设计的获取 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 的地址。</p>

      <dl>
        <dt>mhartid</dt>
        <dd>Hart ID Register (mhartid), 运行当前代码的硬件线程 （hart） 的 ID。</dd>
      </dl>

      <p>因而在获取 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 的地址后， 会将当前代码硬件线程的 ID 存储到 <code class="language-plaintext highlighter-rouge">a0</code> 寄存器中。 另外在跳转到 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 地址后， 由于我们的系统是 RISCV64， 因而 <code class="language-plaintext highlighter-rouge">ld a1, 32(t0)</code> 会将 <code class="language-plaintext highlighter-rouge">fdt_load_addr</code> 即 Flatten Device Tree 的地址写入 <code class="language-plaintext highlighter-rouge">a1</code> 之后更新 <code class="language-plaintext highlighter-rouge">t0</code> 为 <code class="language-plaintext highlighter-rouge">start_addr</code> 后适用 <code class="language-plaintext highlighter-rouge">jr t0</code> 指令跳转到 <code class="language-plaintext highlighter-rouge">start</code> 也就是程序的入口地址处。</p>
    </blockquote>

    <p><a href="https://stackoverflow.com/questions/73945372/question-aboutpcrel-hi-and-pcrel-lo-for-qemu-virt-machine">[Question about%pcrel_hi and %pcrel_lo for qemu virt machine] - StackOverflow</a><br />
 <a href="https://stackoverflow.com/questions/65879012/what-do-pcrel-hi-and-pcrel-lo-actually-do">[What do %pcrel_hi and %pcrel_lo actually do?] - StackOverflow</a></p>
  </li>
  <li>
    <p><em>RISC-V 中的 SBI 的含义和功能是啥？</em></p>

    <blockquote>
      <p>SBI 是 Supervisor Binary Interface 缩写， SBI允许在所有 RISC-V 实现上， 通过定义平台（或虚拟化管理程序）特定功能的抽象， 使监管者模式 （S-mode 或 VS-mode） 的软件具备可移植性。 SBI 的设计遵循 RISC-V 的一般原则， 即核心部分小而精简， 同时具备一组可选的模块化扩展功能。 这套特权态软件和运行机器的二进制接口把机器行为抽象了， 特权态软件通过这套二进制标准向底层机器请求服务。这个特权态软件包括 host 上的内核， 也包括跑在 guest 上的内核。</p>
    </blockquote>
  </li>
  <li>
    <p><em>为了让应用程序能在计算机上执行， 操作系统与编译器之间需要达成哪些协议？</em></p>

    <blockquote>
      <p>操作系统为程序提供了库文件， 编译器依赖这些程序文件以生成适用操作系统与平台的特定文件格式， 在 Linux 中这种文件格式是 ELF， 在 Windows 中是 COFF 等。 这类程序文件需要为操作系统提供符号表、 段等各种必要的信息， 使得程序能够在特定的内存空间正常运行。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请简要说明从 QEMU 模拟的 RISC-V 计算机加电开始运行到执行应用程序的第一条指令这个阶段的执行过程。</em></p>

    <blockquote>
      <p>RustSBI 会在内核加载前完成一系列的初始化操作， 例如串口， Flash 等设备， 之后会将控制权递交给 Kernel （这里没有 u-boot， RustSBI 直接加载了内核）。 同样的， 内核会对网口、内存、文件系统等进行初始化并在最后跳转到应用程序的第一条指令处。</p>
    </blockquote>
  </li>
  <li>
    <p><em>为何应用程序员编写应用时不需要建立栈空间和指定地址空间？</em></p>

    <blockquote>
      <p>操作系统抽象了内存管理， 一般而言 MMU 管理了应用程序的地址空间， 完成了虚拟地址到实际物理地址的映射。 栈空间和堆空间同样依赖虚拟地址映射， 而这部分底层工作已经交由操作系统分配以及管理了。</p>
    </blockquote>
  </li>
  <li>
    <p><em>现代的很多编译器生成的代码， 默认情况下不再严格保存/恢复栈帧指针。 在这个情况下， 我们只要编译器提供足够的信息， 也可以完成对调用栈的恢复。… 根据给出这些信息，调试器可以如何复原出最顶层的几个调用栈信息？假设调试器可以理解编译器生成的汇编代码。</em></p>

    <div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">disassemble</span><span class="w"> </span><span class="n">flap</span><span class="w">
 </span><span class="n">Dump</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">flap</span><span class="o">:</span><span class="w">
 </span><span class="mh">0x0000000000010730</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+0</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">-16</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">唯一入口</span><span class="w">
 </span><span class="mh">0x0000000000010732</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+2</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">sd</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010742</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+18</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ld</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="mh">0x0000000000010744</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+20</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">16</span><span class="w">
 </span><span class="mh">0x0000000000010746</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+22</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ret</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="n">唯一出口</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010750</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+32</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">j</span><span class="w">       </span><span class="mh">0x10742</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">disassemble</span><span class="w"> </span><span class="n">flip</span><span class="w">
 </span><span class="n">Dump</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">flip</span><span class="o">:</span><span class="w">
 </span><span class="mh">0x0000000000010752</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+0</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">-16</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">唯一入口</span><span class="w">
 </span><span class="mh">0x0000000000010754</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+2</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">sd</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010764</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+18</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ld</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="mh">0x0000000000010766</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+20</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">16</span><span class="w">
 </span><span class="mh">0x0000000000010768</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+22</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ret</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="n">唯一出口</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010772</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+32</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">j</span><span class="w">       </span><span class="mh">0x10764</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">
 </span><span class="n">End</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">dump.</span><span class="w">

 </span><span class="c1"># state</span><span class="w">
 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">pc</span><span class="w">
 </span><span class="o">$</span><span class="m">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="w"> </span><span class="mh">0x10752</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">sp</span><span class="w">
 </span><span class="o">$</span><span class="m">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0x40007f1310</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">ra</span><span class="w">
 </span><span class="o">$</span><span class="m">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="w"> </span><span class="mh">0x10742</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="m">6</span><span class="n">a</span><span class="w"> </span><span class="o">$</span><span class="n">sp</span><span class="w">
 </span><span class="mh">0x40007f1310</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10750</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+32</span><span class="o">&gt;</span><span class="w">
 </span><span class="mh">0x40007f1320</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10772</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+32</span><span class="o">&gt;</span><span class="w">
 </span><span class="mh">0x40007f1330</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10764</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div>    </div>

    <blockquote>
      <p>根据上述信息， 当前的 <code class="language-plaintext highlighter-rouge">pc</code> 在 <code class="language-plaintext highlighter-rouge">flip</code> 函数的入口位置， 此时的 <code class="language-plaintext highlighter-rouge">sp</code> 在 <code class="language-plaintext highlighter-rouge">0x4007f1310</code> 处， 而 <code class="language-plaintext highlighter-rouge">ra</code> 在 <code class="language-plaintext highlighter-rouge">0x10742</code> 处， 说明 <code class="language-plaintext highlighter-rouge">flip</code> 函数调用后会返回到 <code class="language-plaintext highlighter-rouge">flap</code> 函数中， 此时对应的指令为 <code class="language-plaintext highlighter-rouge">ld ra,8(sp)</code>， 那么读取到的 <code class="language-plaintext highlighter-rouge">ra</code> 为 <code class="language-plaintext highlighter-rouge">0x10750</code>， 返回的位置仍在 <code class="language-plaintext highlighter-rouge">flap</code> 中， 并根据指令其仍会 跳转到 <code class="language-plaintext highlighter-rouge">0x10742</code> 处并继续从栈中取出地址 <code class="language-plaintext highlighter-rouge">0x10772</code> 跳转到 <code class="language-plaintext highlighter-rouge">flip</code> 中的 <code class="language-plaintext highlighter-rouge">j 0x10764</code>。</p>
    </blockquote>

    <p><a href="https://www.openeuler.org/zh/blog/zhangxinhao/risc-v/2020-11-28-RISC-V.html">RISC-V特权级架构与系统启动</a></p>
  </li>
</ol>

<h2 id="5-实验练习">5. 实验练习</h2>

<p><a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/chapter1/index.html">rCore-Tutorial-Guide-2023S</a> 中没有 ch1 相关练习的， 作者已经实现了依赖 <code class="language-plaintext highlighter-rouge">std::log</code> 的打印输出， 既然这样不如直接在我们之前按照文档构建的 LibOS 上进行更改， 另外顺带把 Makefile 文件功能也补补全。</p>

<dl>
  <dt>Log Info</dt>
  <dd>照着 docs.rs 网址中的 <a href="https://docs.rs/log/0.4.19/log/index.html">Crate log</a> 的说明就可以了。 <a href="https://github.com/HangX-Ma/rcore-sp23/blob/main/ch1/os/src/logging.rs" class="button button--outline-primary button--pill">logging.rs</a></dd>
  <dt>Kernel Info</dt>
  <dd>打印信息也比较简单， 仿照前面的 <code class="language-plaintext highlighter-rouge">clear_bss</code> 函数的写法获取全局变量的地址即可。 <a href="https://github.com/HangX-Ma/rcore-sp23/blob/main/ch1/os/src/main.rs" class="button button--outline-primary button--pill">main.rs</a></dd>
</dl>

<blockquote>
  <p>Spring 2023 版的实验指导书精简了很多内容， 但提供了 ch3 到 ch6, 以及 ch8 这几个章节的 test 代码届时可以直接使用。</p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第一章：应用程序与基本执行环境， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Async Programming in Rust: Futures, Async/Await</title><link href="https://hangx-ma.github.io/2023/06/16/rust-async.html" rel="alternate" type="text/html" title="Async Programming in Rust: Futures, Async/Await" /><published>2023-06-16T00:00:00+08:00</published><updated>2023-06-16T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/16/rust-async</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/16/rust-async.html"><![CDATA[<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=lJ3NC-R3gSI">Rust’s Journey to Async/Await - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-2019/">[Slide]</a></li>
  <li><a href="https://www.youtube.com/watch?v=NNwK5ZPAJCk">The Talk You’ve Been Await-ing for - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-async-await/">[Slide]</a></li>
  <li><a href="https://course.rs/advance/async/intro.html">Rust语言圣经(Rust Course) - 异步编程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[Rust 异步编程中涉及到 Futures， Async/Await 等设计， 这种 Event Driven Programming 以及 Non-Blocking 的设计与构想非常重要。]]></summary></entry><entry><title type="html">Async Programming in Rust： Channel</title><link href="https://hangx-ma.github.io/2023/06/11/rust-channel.html" rel="alternate" type="text/html" title="Async Programming in Rust： Channel" /><published>2023-06-11T00:00:00+08:00</published><updated>2023-06-11T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/11/rust-channel</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/11/rust-channel.html"><![CDATA[<blockquote>
  <ul>
    <li>CS110L Spring 2020 仓库： <a href="https://github.com/HangX-Ma/cs110l-sp20">https://github.com/HangX-Ma/cs110l-sp20</a></li>
    <li>CS110L Spring 2020 课程网站： <a href="https://reberhardt.com/cs110l/spring-2020/">https://reberhardt.com/cs110l/spring-2020/</a></li>
  </ul>
</blockquote>

<p>CS110L Spring20 课程的 Lecture 12 提及了 Rust 多线程间的数据共享的问题。 一般来说， 线程之间会通过一块共享内存传递数据， 并使用 <code class="language-plaintext highlighter-rouge">Arc</code> 以及 <code class="language-plaintext highlighter-rouge">Mutex</code> 避免数据竞争 (Race Condition)。</p>

<p>但是 <strong>使用锁的办法是开销极大的</strong>。 假设内核调度时线程 A 遇到了上锁的数据， 虽然处理这一小段数据可能只需要几纳秒的时间， 但是剩余的时间片因为锁的原因而被浪费了， 而此时该线程又被内核放在了调度队列的末尾， 这意味着线程 A 真正运行时需要经历多轮调度等待很长时间。 那么最好的办法就是使用一种不上锁的数据结构。</p>

<h2 id="1-channel-模型的提出">1. Channel 模型的提出</h2>

<div align="center" style="font-weight: bold; font-style: italic;">

Do not communicate by sharing memory; instead, share memory by communicating
<p align="right">-- Effective Golang</p>
</div>

<p>早在 1978 年就已经提出了 Channel 的理论模型， 多个线程之间的通信以消息的方式传递， 由于没有使用共享内存， 因而不会产生数据竞争。 但消息传递并不意味着高效， 由于我们没有使用共享内存， 这需要我们将需要传递的数据拷贝进 <code class="language-plaintext highlighter-rouge">Message</code> 中， 这会造成极大的资源浪费和严重的效率问题。</p>

<p>在 Rust 中可以通过浅拷贝达到数据共享的目的， 我们需要在 <code class="language-plaintext highlighter-rouge">Message</code> 中传递指针。 用以描述指针的数据结构所占的资源是极小的， 这种 <strong>Partial Shared Memory</strong> 的安全性也能得到保证。 由于 Rust 语言的特性， 指针的所有权会在传递时转移至 Channel 中， 编译器会保证我们在传递指针后无法再在除 Channel 外的任何地方使用这个指针。</p>

<p>完美的 Channel 模型应当是 <em><strong>MPMC (multi-producer, multi-consumer)</strong></em> 类型， 简单的 <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt; + CondVar</code> 组合能够实现 MPMC 但正如前述所言， 使用锁会降低效率。 比如在 Go 语言中实现了基于锁的安全的 MPMC Channel， 虽然使用了 <strong>futex (fast userspace mutex)</strong> 但由于锁的存在而效率低下。 因而， 标准的 Rust 库中实现的是 <em><strong>MPSC (multi-producer, single-consumer)</strong></em>， 这种实现方式有如下优缺点：</p>

<ul>
  <li>优点
    <ul>
      <li>适用于归约数据汇总的场合， 多个线程需要将结果统一发送给一个单独的线程。</li>
      <li>可以退化为 <em><strong>SPSC(single-producer, single-consumer)</strong></em> 进行线程与线程之间独立的通信。</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>当我们想分发数据的时候即一对多时， 情况就比较难办且复杂了。</li>
      <li>Rust 标准库中的 Channel 比较古老， 一些术语和标准没有统一， 不仅难用而且很有可能会被替代。</li>
    </ul>
  </li>
</ul>

<p><a href="https://docs.rs/crossbeam/0.7.3/crossbeam/">crossbeam</a> 是 Rust 官方指定的 Channel 的实现库， 实现了 MPMC 的特性， 改进了很多 API， 甚至比当前的标准库的实现还要快上不少。</p>

<h2 id="2-crossbeam-channel">2. crossbeam Channel</h2>

<p>这里使用 CS110L 课程的 farm v3.0 这个例子对 Channel 的使用进行解释说明。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="n">crossbeam_channel</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="n">num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">thread</span><span class="p">,</span> <span class="n">time</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">factor_number</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// unbounded 表示使用的内存是无上限的</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">crossbeam</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="nf">unbounded</span><span class="p">();</span>
    
    <span class="k">let</span> <span class="k">mut</span> <span class="n">threads</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="nn">num_cpus</span><span class="p">::</span><span class="n">get</span> <span class="p">{</span>
        <span class="c1">// 创建一个 receiver 的拷贝， 避免下一个线程因所有权转移而无法使用 receiver</span>
        <span class="k">let</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">threads</span><span class="nf">.push</span><span class="p">(</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">next_num</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">factor_number</span><span class="p">(</span><span class="n">next_num</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">stdin</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">stdin</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"Tried writing to channel, but there are no receivers!"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果没有调用 drop， 那么通道关闭的两个条件： 发送者全部 drop 或接收者被 drop 就无法满足。</span>
    <span class="c1">// 那么对于子线程而言， 如果它想从 while 循环中跳出必须要让 recv() 返回一个 Err()， 只有提早</span>
    <span class="c1">// 通过 drop 函数关闭了 sender 才能让 Channel 关闭， 让子线程完成处理。</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">thread</span> <span class="k">in</span> <span class="n">threads</span> <span class="p">{</span>
        <span class="n">thread</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Panic occurred in thread"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-参考">3. 参考</h2>

<ul>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-12.pdf">CS110L, Spring 2020: Channels</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-11.pdf">CS110L, Spring 2020: Synchronization</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/lecture-notes/lecture-11/">CS110L, Spring 2020: Synchronization in Rust</a></li>
  <li><a href="https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93">Rust Course: Channel</a></li>
</ul>

<p class="error">Thanks for Roberto Huertas providing the background image, you can find some from his blog: <a href="https://robertohuertas.com/2019/12/08/wallpapers-for-the-rust-of-us/">Wallpapers for the Rust of us</a></p>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[学习 CS110L Spring20 课程 Lecture 12： Channel， 总结相关原理及用法。]]></summary></entry><entry><title type="html">MDIO (Management Data Input/Output)</title><link href="https://hangx-ma.github.io/2023/06/06/net-mdio.html" rel="alternate" type="text/html" title="MDIO (Management Data Input/Output)" /><published>2023-06-06T00:00:00+08:00</published><updated>2023-06-06T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/06/net-mdio</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/06/net-mdio.html"><![CDATA[<h2 id="1-mdio-简介">1. MDIO 简介</h2>

<p><a href="#ref-mdio-wiki">wiki</a> 中这样定于 <em><strong>MDIO（Management Data Input/Output）</strong></em>： <em>MDIO 是 IEEE 802.3 标准定义一种两线以太网串行总线用于 <strong>MII（Media Independent Interface）</strong>， 有时关于 MDIO 我们还会说到 <strong>SMI（Serial Management Interface）</strong> 或者 <strong>MIIM（Media Independent Interface Management）</strong></em>。SMI/MDIO 协议用来管理 <em><strong>MAC（Media Access Controller）</strong></em> 与 <em><strong>PHY（Physical）</strong></em> 两个网络层之间的数据传输。 控制 MDIO 总线的设备称为 <em><strong>STA（Station Management Entity）</strong></em> 而被 MDIO 总线管理的设备称为 <em><strong>MMD（MDIO Manageable Device）</strong></em>。</p>

<blockquote>
  <p>MDIO 上层是 MII 其有两个接口： 数据接口连接以太网 MAC 层， 用以发送和接收以太网帧数据； 另外一个 PHY 管理接口了， 也就是我们所说的 MDIO 接口。</p>
</blockquote>

<p>MMD 一般是指 PHY 设备这类 MDIO 从设备， MDIO 接口会连接控制单元控制 PHY 设备以及获取其状态 （读写寄存器）。 每个 PHY 设备能在执行操作之前监视， 在执行操作时则可通过寄存器监视其状态。 这些寄存器提供了状态和控制信息， 包括 <em>link status, speed ability and selection, power down for low power consumption, duplex mode (full or half), auto-negotiation, fault signalling, loopback</em>。 MDIO 协议的作用就是配置 PHY 层所需要的接收/发送的参量。</p>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/mdio-interface-layout.png" alt="MDIO interface layout" width="600" />
    <br />
    <font size="2" color="#999"><u>MDIO interface layout</u></font>
</div>

<p>前述所说， MDIO 是一种双线协议， 其接口由两种信号构成：</p>

<ul>
  <li><strong>MDIO Data Clock（MDC）：</strong> 由 MAC 设备驱动的连接到 PHY 设备的时钟信号。</li>
  <li><strong>MDIO Data：</strong> 双向的数据传输， 所有的设备都依据 MDC 同步 （synchronous） 传输。</li>
</ul>

<p>虽然 MDIO 的是一种最高仅有 2.5 MHz 的低速总线 （最新的 DP83640 已经能支持 25 MHz）， 最开始是由 IEEE 802.3 的 Clause 22 定义， 后为了满足对 10G 以太网的设备需求在 IEEE 802.3ae 定义了 Clause 45。 对于 MDIO 总线而言其仅有一个主设备， 但能有多达 32 个 PHY 从设备。</p>

<blockquote>
  <p>MDIO 主从设备的控制器有不同的协议适用要求：</p>

  <ul>
    <li>MDIO master controller: Clause 22 和 Clause 45 均可</li>
    <li>MDIO slave controller: Clause 22</li>
    <li>MDIO slave controller: Clause 45</li>
  </ul>
</blockquote>

<h2 id="2-clause-22">2. Clause 22</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause22-frame-format.png" alt="Clause 22 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 22 format format</u></font>
</div>

<p>Clause 22 的帧格式只允许 5 bit 物理层地址和寄存器地址， 这限制了 STA 可以连接的 MMD 的数量。 此外，Clause 22 MDIO 只支持限压 5V 的设备且不支持多设备的 PHY。</p>

<h2 id="3-clause-45">3. Clause 45</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause45-frame-format.png" alt="Clause 45 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 45 format format</u></font>
</div>

<p>Clause 45 更改了寄存器的读写模式， 不同于 Clause 22 将寄存器读写数据以及地址都放在一个独立帧， Clause 45 分成了两帧进行传输， 第一帧为地址帧确定 MMD 和 寄存器， 第二帧为数据帧进行数据的读写。 这种设计不仅向后兼容 Clause 22， 并且将地址从 5 bit 扩展到了 16 bit， 使得寄存器的访问数量从 32 个增加到了 65535 个。 另外 Clause 45 支持 32 个端口， 每个端口都能支持 32 个 MMD 设备。</p>

<h2 id="4-mdio-与-phy-与-nic">4. MDIO 与 PHY 与 NIC</h2>

<p>网卡 （NIC） 工作在 OSI 的最后两层， 物理层和数据链路层</p>

<ul>
  <li><strong>物理层</strong> 定义了数据传送与接收所需要的电与光信号、 线路状态、 时钟基准、 数据编码和电路等， 并向数据链路层设备提供标准接口。</li>
  <li><strong>数据链路层</strong> 则提供寻址机制、 数据帧的构建、 数据差错检查、 传送控制、 向网络层提供标准的数据接口等功能。 以太网卡中数据链路层的芯片称之为 MAC 控制器。</li>
</ul>

<p>物理层的芯片称之为 PHY。 IEEE-802.3 标准定义了以太网 PHY。 包括 <em><strong>MII（Media Independent Interface）</strong></em> 子层， <em><strong>PCS（Physical Coding Sublayer）</strong></em>， <em><strong>PMA（Physical Medium Attachment）</strong></em> 子层， <em><strong>PMD（Physical Medium Dependent）</strong></em> 子层， <em><strong>MDI（Medium Dependent Interface）</strong></em> 子层， 符合 IEEE-802.3k 中用于 10BaseT 和 100BaseTX 的规范。</p>

<p>PHY 和 MAC 之间通过 IEEE 定义的标准的 <em><strong>MII（Media Independent Interface）</strong></em> 连接 MAC 和 PHY。 MII 传递了网络的所有数据和数据的控制。 以太网接口实质是 MAC 通过 MII 总线控制 PHY 的过程。 按照前述内容可知， IEEE 定义了 MDIO 总线服务于 MII 用以与 PHY 的通信。</p>

<h2 id="5-参考">5. 参考</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Management_Data_Input/Output">Management Data Input/Output - wikipedia</a> <a id="ref-mdio-wiki"></a></li>
  <li><a href="https://www.latticesemi.com/-/media/LatticeSemi/Documents/ReferenceDesigns/JM/MDIOMasterandSlaveControllersDocumentation.ashx?document_id=50604">MDIO Master and Slave Controllers - LATTICE-semiconductor</a></li>
  <li><a href="https://prodigytechno.com/mdio-management-data-input-output/">MDIO ( Management Data Input/Output )</a></li>
  <li><a href="https://www.totalphase.com/support/articles/200349206-mdio-background/">MDIO Background</a></li>
  <li><a href="https://grouper.ieee.org/groups/802/3/ae/public/jul00/law_1_0700.pdf">IEEE P802.3ae 10Gb/s Ethernet MDC/MDIO Proposal</a></li>
  <li><a href="https://www.cnblogs.com/jason-lu/articles/3195473.html">网口扫盲三:以太网芯片MAC和PHY的关系</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Network" /><category term="Linux" /><summary type="html"><![CDATA[介绍 MDIO 以及与其相关的 clause 22， clause 45 协议。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 6: putting it all together</title><link href="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 6: putting it all together" /><published>2023-05-31T00:00:00+08:00</published><updated>2023-05-31T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/31/cs144-lab6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html"><![CDATA[<p>记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab6 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check6.pdf">Lab Checkpoint 6: putting it all together</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简介">1. 内容简介</h2>

<p>Lab6 是一个选择性的实验， 在前 6 个实验中我们已经完成了网络的框架， Checkpoint 0 (a reliable byte stream), Checkpoints 1–3 (the Transmission Control Protocol), Checkpoint 4 (an IP/Ethernet network interface) 以及 Checkpoint 5 (an IP router)， 该实验的目的是使用前述的网络栈实现真实的网络通信， 这需要我们有个 partner， 一人分饰两角也是可以的。</p>

<h2 id="2-the-network">2. The Network</h2>

<p>在该实验中需要一对可行的网络栈组合成一个真实的网络通信环境， 两方都需要构建 host 和 router， 网络拓扑如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-05-31-cs144-lab6/the-network.png" alt="The Network" width="600" />
    <br />
    <font size="2" color="#999"><u>The Network</u></font>
</div>

<ol>
  <li>对于个人而言， 需要使用同一套代码在不同的终端中启用 server 以及 client。</li>
  <li>为了使用 relay， 我们需要选择任意的一个 1024 到 64000 之间的偶数以区分不同的 group。 我们可以选择 “4088”。</li>
  <li>
    <p>server 端在 build 文件夹下输入 <code class="language-plaintext highlighter-rouge">./apps/endtoend server cs144.keithw.org 4088</code>， 若顺利的话 server 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend server cs144.keithw.org 4088
 DEBUG: Network interface has Ethernet address 02:00:00:91:a1:8f and IP address 172.16.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:bf:ba:0e and IP address 10.0.0.172
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> 10.0.0.192 on interface 1
 DEBUG: Network interface has Ethernet address 9a:c0:ea:b5:88:82 and IP address 172.16.0.100
 DEBUG: Listening <span class="k">for </span>incoming connection...
</code></pre></div>    </div>
  </li>
  <li>
    <p>client 端在 build 文件夹下输入 <code class="language-bash highlight highlighter-rouge">./apps/endtoend client cs144.keithw.org 4089</code>， 若顺利的话 client 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend client cs144.keithw.org 4089
 DEBUG: Network interface has Ethernet address 02:00:00:e0:84:14 and IP address 192.168.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:e8:1a:da and IP address 10.0.0.192
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> 10.0.0.172 on interface 1
 DEBUG: Network interface has Ethernet address 7e:fa:65:55:c7:4e and IP address 192.168.0.50
 DEBUG: Connecting from 192.168.0.50:7907...
 DEBUG: Connecting to 172.16.0.100:1234...
 Successfully connected to 172.16.0.100:1234.
</code></pre></div>    </div>

    <p>并且 server 端会额外打印一条信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> New connection from 192.168.0.50:7907.
</code></pre></div>    </div>
  </li>
  <li>
    <p>若以上信息都能正确打印， 则意味着 TCP 握手成功， 若有问题则需要在之前的命令后加上 <code class="language-plaintext highlighter-rouge">debug</code> 进入 debug 模式进行调试。</p>

    <ul>
      <li>我们可以在 server 或者 client 任意一端输入数据， 就能在相应的另一端看到数据。
        <blockquote>
          <p>经过测试发现需要在 Terminal 输入需要发送的数据后按下 Ctrl-D 才能发送数据并在 remote 端看到。</p>
        </blockquote>
      </li>
      <li>可以使用 Ctrl-D 关闭链接。 server 或 client 关闭链接后会终止那一端的 ByteStream 的输出， 但仍会持续接收数据直到另一端也关闭了 ByteStream 的输出， 我们需要验证这点。
        <blockquote>
          <p>首先需要确保 Terminal 中已经没有数据了， 此时我们按下 Ctrl-D 才会断开 TCP 的链接。</p>
        </blockquote>
        <ul>
          <li>
            <p><em><strong>server</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  DEBUG: Outbound stream to 192.168.0.50:36742 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Inbound stream from 192.168.0.50:36742 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:36742 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p><em><strong>client</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  <span class="c">######## Nothing ########</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>当 server 和 client 都关闭 ByteStream 输出后并且一端又持续存在数秒后， 两边的程序应该会正常退出。</li>
    </ul>
  </li>
</ol>

<h2 id="3-文件传输">3. 文件传输</h2>

<h3 id="31-操作流程">3.1 操作流程</h3>

<p>当基本的通信功能实现之后就可以通过网络进行文件的传输。</p>

<ul>
  <li>
    <p>将 1M 大小的随机数写入文件 <code class="language-plaintext highlighter-rouge">/tmp/big.txt</code>。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>1 <span class="nv">of</span><span class="o">=</span>/tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 server 端在接受连接后立刻发送文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ./apps/endtoend server cs144.keithw.org 4088 &lt; /tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 client 端关闭输出数据流并下载文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;/dev/null ./apps/endtoend client cs144.keithw.org 4089 <span class="o">&gt;</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>比较两个文件确保二者一致</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">sha256sum</span> /tmp/big.txt
  <span class="nb">sha256sum</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
</ul>

<p>如果 SHA-256 哈希值都能匹配上， 那我们就可以确定文件被正确传输了。</p>

<h3 id="32-输出打印">3.2 输出打印</h3>

<ul>
  <li>
    <p><em><strong>server</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Inbound stream from 192.168.0.50:27200 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:27200 finished <span class="o">(</span>63000 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 192.168.0.50:27200 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>client</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: TCP connection finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown... <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>SHA-256</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big.txt
  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big-received.txt
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 5: building an IP router</title><link href="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 5: building an IP router" /><published>2023-05-30T00:00:00+08:00</published><updated>2023-05-30T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/30/cs144-lab5</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html"><![CDATA[<p>记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab5 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check5.pdf">Lab Checkpoint 5: building an IP router</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/check5-structure.png" alt="IP router structure" width="500" />
    <br />
    <font size="2" color="#999"><u>IP router structure</u></font>
</div>

<p>Lab5 要求实现一个简易的路由器， 通常路由器会有多个网络接口， 能够从任意一个接口接收网络数据报。 路由器的作用就是将 datagrams 依据 <strong>路由表</strong> 进行转发， 路由表定义了路由转发的一些规则：</p>

<ul>
  <li>确定转发的接口</li>
  <li>确定下一跳的 IP 地址</li>
</ul>

<p>在 Lab5 中需要实现一个新的 <code class="language-plaintext highlighter-rouge">Router</code> 类， 该类能够 <em>跟踪路由表信息</em> 并且 <em>将接收到的每个 datagram 通过正确的输出端 <strong>NetworkInterface</strong> 正确转发到下一跳 （hop）</em>。 在项目指导书中明确解释了 <em><strong>route</strong></em> 的相关含义， 后续需要通过 IP 的最长前缀匹配来实现路由的功能， 这也是实验中最为棘手的部分。</p>

<h2 id="2-ip-router-实现">2. IP Router 实现</h2>

<ol>
  <li>
    <p><strong>add_route：</strong> 调用该方法将路由信息添加到路由表中， 我们需要自己添加存储相关信息的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">add_route</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">,</span> 
                 <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">interface_num</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>根据 <code class="language-plaintext highlighter-rouge">add_route</code> 所给的参数以及 <a href="https://en.wikipedia.org/wiki/Routing_table">wiki</a> 中对 routing table 内容的描述， 我们需要自己创建如下的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Routing table data structure</span>
 <span class="k">using</span> <span class="n">route_t</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">;</span>
     <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">interface_id</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">route_t</span><span class="o">&gt;</span> <span class="n">routing_table_</span> <span class="p">{};</span>
</code></pre></div>    </div>

    <blockquote>
      <p><a href="https://en.wikipedia.org/wiki/Routing_table">wikipedia - Routing table</a></p>
    </blockquote>
  </li>
  <li>
    <p><strong>route：</strong> 该方法需要对输入的 datagrams 进行路由， 将其通过正确的网络接口转发到下一跳， 这需要实现 <strong>“最长前缀匹配 （longest-prefix match）”</strong> 以找到最合适的路由方案， 该方法有如下细节需要实现：</p>

    <ul>
      <li>路由器需要搜索路由表找到匹配 datagrams 中的目的地址的那个路由。 这意味着目的地址的 <em>prefix_length</em> 需要与 <em>route_prefix</em> 的 <em>prefix_length</em> 完全一致。</li>
      <li>在匹配的路由方案中路由器选择 <em>prefix_length</em> 值最大的那个， 选中的就是满足 “最长前缀匹配” 的路由。</li>
      <li>如果没有匹配的路由信息， 则丢弃该项 datagram。</li>
      <li>每一跳的路由器都需要减少 datagrams 的 ttl。 如果 ttl 已经归零或者在本次减除后触及零的下界， 路由器同样需要丢弃该项 datagram。</li>
      <li>最终， 路由器需要将修改过的 datagram 通过合适的网络接口 （<code class="language-plaintext highlighter-rouge">interface(interface num).send datagram()</code>） 发送到下一跳。</li>
    </ul>

    <p>整个过程中， 路由器仅需要和 datagram 以及链接层的网络接口抽象进行交互， 完全不需要考虑 TCP， ARP 以及以太网帧， 较好实现了分层隔离， 降低了路由器的处理负担。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">route</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="3-网络拓扑">3. 网络拓扑</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/simulated-router-and-interfaces.png" alt="Simulated router and interfaces topology" width="600" />
    <br />
    <font size="2" color="#999"><u>Simulated router and interfaces topology</u></font>
</div>

<h2 id="4-坑点记录">4. 坑点记录</h2>

<p>测试的时候有这样一条记录（就是第一个测试都没过啦）， 当时觉得很奇怪怎么会有 <code class="language-plaintext highlighter-rouge">bad IPv4 datagram</code> 的打印， 查看后是 <code class="language-plaintext highlighter-rouge">InternetDatagram</code> 的 <code class="language-plaintext highlighter-rouge">parse</code> 返回了错误。 于是我给 <code class="language-plaintext highlighter-rouge">set_error</code> 的部分都加上了打印才发现是 <strong>checksum</strong> 未匹配。 我还以为是 <em><strong>NetworkInterface</strong></em> 部分的接收部分没有写好， 调试了半天就想着要不要用 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 在 <code class="language-plaintext highlighter-rouge">recv_frame</code> 中重新把 checksum 计算一下， 这时候突然发现这个函数的接口都是 <code class="language-plaintext highlighter-rouge">const</code> 类型， 并且结合 <em><strong>NetworkInterface</strong></em> 在 <em>link layer</em> 与 <em>application</em> 之间的情况， 以及错误是出现在以太网帧传输到 router 再转发出去的， 唯一有嫌疑的应当还是刚刚写的 <em><strong>Router</strong></em> 类。</p>

<p>在读 <code class="language-plaintext highlighter-rouge">router.cc</code> 代码考虑把 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 加在哪里的时候我突然看到 ttl 的值被我更改了。 这不就是问题根源嘛， 我们更新了 <em><strong>InternetDatagram</strong></em> 的内容， 那么 checksum 也需要重新计算。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Testing traffic between two ordinary hosts <span class="o">(</span>applesauce to cherrypie<span class="o">)</span>...

Host applesauce trying to send datagram <span class="o">(</span>with next hop <span class="o">=</span> 10.0.0.1<span class="o">)</span>: 
    IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 
    <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/10.0.0.1

Transferring frame from router.eth0 to applesauce: 
    <span class="nv">dst</span><span class="o">=</span>16:4e:eb:3a:a2:3d, <span class="nv">src</span><span class="o">=</span>02:00:00:dd:27:73, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:dd:27:73/10.0.0.1, <span class="nv">target</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:dd:27:73, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: IPv4: IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, 
    <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from router.eth2 to cherrypie: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nb">type</span><span class="o">=</span>ARP, 
    payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/192.168.0.2

Transferring frame from cherrypie to router.eth2: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nv">src</span><span class="o">=</span>ea:80:f1:26:53:c8, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>ea:80:f1:26:53:c8/192.168.0.2, <span class="nv">target</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1

Transferring frame from router.eth2 to cherrypie: 
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="nv">dst</span><span class="o">=</span>ea:80:f1:26:53:c8, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: bad IPv4 datagram
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="o">[</span>NetworkInterface ERROR]: <span class="s1">'recv_frame'</span> IPV4 parse error



Error: Host cherrypie did NOT receive an expected Internet datagram: 
        IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2
</code></pre></div></div>

<h2 id="5-测试结果">5. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check5
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/3 Test  <span class="c">#1: compile with bug-checkers ........   Passed   44.90 sec</span>
    Start 35: net_interface
2/3 Test <span class="c">#35: net_interface ....................   Passed    0.20 sec</span>
    Start 36: router
3/3 Test <span class="c">#36: router ...........................   Passed    0.17 sec</span>

100% tests passed, 0 tests failed out of 3

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  45.41 sec
Built target check5
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)</title><link href="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)" /><published>2023-05-27T00:00:00+08:00</published><updated>2023-05-27T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/27/cs144-lab4</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html"><![CDATA[<p>记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 <em><strong>TCPReceiver</strong></em> 和 <em><strong>TCPSender</strong></em> 结合起来）。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab4 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check4.pdf">Lab Checkpoint 4: down the stack (the network interface)</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-27-cs144-lab4/check4-structure.png" alt="network interface structure" width="300" />
    <br />
    <font size="2" color="#999"><u>network interface structure</u></font>
</div>

<p>Lab4 要求实现网络接口部分， 打通网络数据报 （Internet datagrams） 和链路层的以太网帧（link-layer Ethernet frames） 之间的桥梁。 之前的实验实现了 TCP segments 在使用 TCP 协议的设备之间的传输， 而 TCP 报文是如何传递的？ TCP报文有三种方式可被传送至远程服务器：</p>

<ul>
  <li>
    <p><em><strong>TCP-in-UDP-in-IP：</strong></em> TCP 报文会被置于用户的数据报的 payload 中， 在用户空间下这是最简单的实现方式： Linux 提供接口 （如 <em><strong>UDPSocket</strong></em>）， 而用户侧仅需要提供 payload， 目标地址， Linux 内核会负责将 UDP 报部， IP 报头， 以太网报头组装起来， 将这个网络包发向下一个 hop。 <strong>Linux 内核会保证每个 socket 会有独立的本地与远端地址以及端口号， 并且保证这些数据在应用层的相互隔离</strong>。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP：</strong></em> 一般情况下， TCP 报文会直接放在 Internet datagrams 中， 这通常被成为 “TCP/IP”。 Linux 会提供一个 TUN 设备接口， 需要应用层提供整个 Internet datagram， 而 Linux 内核则会处理剩下的部分。 但此时应用层需要自己构建整个 IP 报头以及 payload 部分。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP-in-Ethernet：</strong></em> 以上的方法依赖Linux内核来实现的协议栈操作， 每次用户向 TUN 设备写入 IP datagrams 时， Linux 都需要构建正确的带有 IP datagrams 的以太网帧作为 payload。 这意味着 Linux 需要知悉下一个 hop 的以太网目的地址， 给出其 IP 地址。 否则 Linux 会以广播的形式请求这些信息。</p>

    <p>这些功能是由 <em><strong>Network Interface</strong></em> 实现的， 该组件能将 IP 数据报转义成以太网帧等等， 之后会传入 TAP 设备 （类似 TUN 设备但更底层）， 实现对 link-layer 的数据帧的传输。</p>
  </li>
</ul>

<p>网络接口的大部分工作是， <strong>为每个下一跳 IP 地址查找(和缓存)以太网地址</strong>。而这种协议被称为 <strong>地址解析协议 ARP （Address Resolution Protocol）</strong>。</p>

<blockquote>
  <p><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">Address Resolution Protocol - wiki</a></p>
</blockquote>

<h2 id="2-network-interface-实现">2. Network Interface 实现</h2>

<h3 id="21-默认接口">2.1 默认接口</h3>

<p>在 Lab4 的 <em><strong>Network Interface</strong></em> 中我们需要实现以下几个部分， 维护一个 IP 地址到 Ethernet 地址的映射表。 这个映射类似缓存， 能提高网络栈的传输效率。</p>

<ol>
  <li><strong>send datagram：</strong> 该方法被 TCPConnection 或者 router 所调用， 这个接口就是将待发送的 Internet(IP) datagrams 转义为以太网帧并最终发送出去。
    <ul>
      <li>如果以太网目的地址是已知的就直接发送， 创建以太网帧 （<code class="language-plaintext highlighter-rouge">type = EthernetHeader::TYPE IPv4</code>）， 将 payload 设置为串行的数据报文， 并设置源地址和目标地址。</li>
      <li>如果以太网目的地址未知， 广播下一跳的以太网地址的 ARP 请求， 并将 IP 报文放入队列中待 ARP 回复收到后能将其发送出去。
        <blockquote>
          <p>需要间隔 5 秒再发送相同的 ARP 请求， 并且只有在收到目的以太网地址后再将数据报放入队列中。 若没有收到目的以太网地址， 我们需要将 dgrams 以及其对应的 Address 都暂存在列表中， 以供之后收到 ARP reply 后再进行发送， 否则这部分数据就会丢失了。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">send_datagram</span><span class="p">(</span><span class="k">const</span> <span class="n">InternetDatagram</span> <span class="o">&amp;</span><span class="n">dgram</span><span class="p">,</span> <span class="k">const</span> <span class="n">Address</span> <span class="o">&amp;</span><span class="n">next_hop</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>recv frame：</strong> 该方法接收来自网络的以太网帧， 但需要忽略任何目的地址非网络接口部分的帧 （广播地址或者存储在 <code class="language-plaintext highlighter-rouge">_ethernet_address</code> 中的接口自身的以太网地址）。
    <ul>
      <li>若为 IPv4 帧就将其以 <em><strong>InternetDatagramF</strong></em> 进行解析， 若成功的就将结果的 <em><strong>InternetDatagramF</strong></em> 返回给调用者。</li>
      <li>若为 ARP 帧就将其以 <em><strong>ARPMessage</strong></em>  进行解析， 若成功则缓存发送方 IP 地址与以太网帧的映射 30 秒。 若这个 ARP 请求是询问我们的 IP 地址， 就回复正确的 ARP 答复。
        <blockquote>
          <p>根据 FAQs 中的答疑， 我们需要自行创建一个用以存储映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">InternetDatagram</span><span class="o">&gt;</span> <span class="n">recv_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">EthernetFrame</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>maybe send：</strong> 该方法在必要时发送 <em><strong>EthernetFrame</strong></em>。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">maybe_send</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>tick：</strong> 记录时间， 以使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p class="warning"><em><strong>FAQs and special cases</strong></em> 中的信息都很有帮助， 可以当作一种提供解题思路的 Hints。</p>

<h3 id="22-额外说明">2.2 额外说明</h3>

<h4 id="ethernet-frames">Ethernet Frames</h4>

<p><em><strong>EthernetFrame</strong></em> 是我们需要传输给 TAP 设备的数据， 根据已有信息， 我们只需要将组装好的 <em><strong>EthernetFrame</strong></em> 用 <code class="language-plaintext highlighter-rouge">queue</code> 数据结构封装即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// outbound Ethernet frames which will be sent by the Network Interface</span>
<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">outbound_frames_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="arp-table">ARP Table</h4>

<p>从以上接口的描述可以看出， 我们需要建立一个存储 ARP 映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>， IP-To-Ethernet。 根据 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">wiki</a> 关于 ARP 原理章节的阐述， 这个表中的 ARP 数据需要有一个变量存储 <em><strong>EthernetFrame</strong></em> 表示映射目标， 以及 <em><strong>ttl (time-to-live)</strong></em> 表示该条 ARP 信息的生命周期 （默认是 30s）。 另外，在 FAQs 中有这么一句：</p>

<p class="info"><strong>Q:</strong> <em>How do I convert an IP address that comes in the form of an Address object, into a raw 32-bit integer that I can write into the ARP message?</em>
<br />
<strong>A:</strong> Use the <code class="language-plaintext highlighter-rouge">Address::ipv4 numeric()</code> method.</p>

<p>这说明 ARP 的映射应当是 <code class="language-plaintext highlighter-rouge">uint32_t</code> 类型到 <code class="language-plaintext highlighter-rouge">arp_t</code> 类型， 我们可以用一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储映射信息。 除此之外我们还注意到， 同一个 ARP 的 ARP 请求的间隔需要 5s， 那么除了映射信息外， 我们还需要一个 <code class="language-plaintext highlighter-rouge">list</code> 结构用以存储绑定 <em><strong>InternetDatagram</strong></em> 和 <em><strong>Address</strong></em> 的等待列表 <code class="language-plaintext highlighter-rouge">arp_datagrams_waiting_list_</code>。 另外， 为了记录 ARP 请求的声明周期， 我们还需要一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储 <em><strong>numeric IP</strong></em> 与该条 ARP 请求的声明周期的映射 <code class="language-plaintext highlighter-rouge">arp_requests_lifetime_</code>。</p>

<blockquote>
  <p>这里使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构是头文件中已经包含了相关的库文件， 另外这部分信息具有时效的不确定性， 我们并不清楚 ARP 请求究竟哪一个会在下一刻返回， 所以在这部分信息我们需要逐个遍历， 将已经获取目标以太网地址的数据包组装后放入发送队列中， 并从 <code class="language-plaintext highlighter-rouge">list</code> 中移除。 故而使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构能够利用链表插入/移除数据的快速性的优势， 而不用考虑查询带来的负面影响。</p>
</blockquote>

<p>这样关于 ARP Table 的数据结构就可以按如下格式创建。 需要注意的是 TTL 的时间单位是 ‘毫秒’， 而我们设定的边界值都是以 ‘秒’ 为单位。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ARP will be stored for 30s at most, which can reduce the length of ARP table,</span>
<span class="c1">// increasing the enquiry speed. What's more, </span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_REQUEST_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">arp</span> <span class="p">{</span>
    <span class="n">EthernetAddress</span> <span class="n">eth_addr</span><span class="p">;</span> <span class="c1">// mac address</span>
    <span class="kt">size_t</span> <span class="n">ttl</span><span class="p">;</span> <span class="c1">// time to live</span>
<span class="p">}</span> <span class="n">arp_t</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="cm">/* ipv4 numeric */</span><span class="p">,</span> <span class="n">arp_t</span><span class="o">&gt;</span> <span class="n">arp_table_</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">,</span> <span class="n">InternetDatagram</span><span class="o">&gt;&gt;</span> <span class="n">arp_requests_waiting_list_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="内存泄漏">内存泄漏</h4>

<p>在遍历 ARP Table 的时候我用了迭代器， 但是调用了 <code class="language-plaintext highlighter-rouge">erase</code> 函数之后又用了 <code class="language-plaintext highlighter-rouge">iter++</code> 去获取下一个 ARP 项， 这产生了矛盾， 当前的迭代器的内存空间已经被释放了。 因而使用 <code class="language-plaintext highlighter-rouge">erase</code> 函数需要注意使用 <code class="language-plaintext highlighter-rouge">iter = xxx.erase(iter);</code> 来更新迭代器的内容。</p>

<h2 id="3-测试结果">3. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check4
<span class="o">[</span>1/1] <span class="nb">cd</span> /home/cs144/minnow/build <span class="o">&amp;&amp;</span> /usr/bin/ctest <span class="nt">--output-on-failure</span> <span class="nt">--stop-on-failure</span> <span class="nt">--timeout</span> 12 <span class="nt">-R</span> <span class="s1">'^net_interface'</span>
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/2 Test  <span class="c">#1: compile with bug-checkers ........   Passed   20.14 sec</span>
    Start 35: net_interface
2/2 Test <span class="c">#35: net_interface ....................   Passed    0.15 sec</span>

100% tests passed, 0 tests failed out of 2

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  20.29 sec
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 TCPReceiver 和 TCPSender 结合起来）。]]></summary></entry></feed>