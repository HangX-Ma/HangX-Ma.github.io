<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-07-17T23:47:59+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">miniFOC Driver Development</title><link href="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html" rel="alternate" type="text/html" title="miniFOC Driver Development" /><published>2023-07-17T00:00:00+08:00</published><updated>2023-07-17T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/17/miniFOC-dev</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html"><![CDATA[<p>研 0 的时候不知好歹自己做了一块驱动板， 但是没有任何经验也不知道怎么开发， 结果上电就烧。 直到最近看到了 B 站 Up <a href="https://space.bilibili.com/382415040">热心市民翔先生</a> 发的 FOC 开发的系列视频感觉这个项目是有救了。 这也算是圆了自己 STM32 开发的愿望， 之前只学习做过一些 demo， 导师甚至把 MCU 称之为玩具（相对他高大上的嵌入式 Linux 而言确实如此）。 但无论如何， 学习的过程中总是会有收获的， 我不认为他们口中简单的东西在没有接触之前都是简单的， 至少我需要这个开发经历。</p>

<blockquote>
  <p>目前板子设计借鉴了 <a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">小男孩gugugu</a> Up 的这部分内容（视频标题太长啦！）， 不想自己从头找元件然后再一个个建模搭了， 太费时间了这样就本末倒置了。</p>
</blockquote>

<ul>
  <li><strong>MCU:</strong> STM32F103C8T6</li>
  <li><strong>Programmer:</strong> CMake + OpenOCD + STLink-v2</li>
  <li><strong>PCB Design:</strong> Altium Designer 23</li>
  <li><strong>Editor:</strong> VSCode</li>
</ul>

<p>项目地址 <a href="https://github.com/HangX-Ma/miniFOC">HangX-Ma/miniFOC</a>， 项目将持续更新， 这次挺有信心的！</p>

<h2 id="1-sc60228-磁编码器">1. SC60228 磁编码器</h2>

<p>SC60228 是一款非接触式高精度磁编码器芯片， 芯片中心内置了霍尔感应点矩阵， 可用以测量无刷电机的转子角度。 通过 PWM 或 SPI 的方式输出 12 bit 绝对式位置信息， 检测速率可达 20K rpm， 不难得知该款芯片能检测一周最多 4096 个位置。 相较读取 PWM 输出计算角度而言， 使用 SPI 协议读取数据的精度会更高， 代码编写也比较方便且具备通用性。</p>

<blockquote>
  <p>用这款芯片也是历史遗留问题了， 当时做了这个板子不忍心浪费， 网上有 Simple FOC 提供的 <a href="https://github.com/simplefoc/Arduino-FOC-drivers/tree/master/src/encoders/sc60228">SC60228 SimpleFOC driver</a> 可参考代码部分， 虽然看起来事情不多， 但理解数据手册进行配置和代码编写也对学习很有帮助。</p>
</blockquote>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/encoder-spi-time-diagram.png" alt="Encoder SPI time diagram, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI time diagram, HangX-Ma</u></font>
</div>

<p>这款芯片只需要配置 SPI 口在主机接收数据即可， 不涉及双向数据传输。 可以看到上图数据手册提供的读取绝对式角度数据的时序表， 根据 SPI 协议 SCLK 空闲时低电平， 另外根据数据手册， 在 SCLK 上升沿之后需要保持 \(t_{DO}\) 时间以使得 MISO 数据有效， 那么只能在下降沿进行数据采样。 不难确定 SPI 协议的 <strong>CPOL(Clock Polarity)</strong> 为 <strong>Low</strong>， <strong>CPHA(Clock Phase)</strong> 为 <strong>Second Edge</strong>。</p>

<p>另外， 手册指出 <strong>\(t_{CLK}\)（SCLK 周期）</strong> 最小需要 100ns， 这里我查了一下 STM32CubeMX 配置中的 Baud Rate 的含义， 如果没理解错就相当于 SPI 中的 SCLK。 对于预设 72MHz 时钟频率的板子， 8 分频 9.0 MBits/s ≈ 111 ns， 另外 <strong>\(t_{DO}\)（SCLK 的上升沿到 MISO 数据有效之间的时间）</strong>_ 其值最大能达到 50 ns， 那么当前算是极限的速率配置了。 为了保险起见我选择设置 16 分频约 222 ns 周期， 防止数据出现丢失以及未定义的情况。</p>

<blockquote>
  <p>后续测试若有问题则可将分频倍数调得更高一些， 400 ns 应该也是能接受的， 手册说明最大转速可测 20K rpm， 小电机能有 5K rpm 也不得了了。</p>
</blockquote>

<p>另外 16-bits 的数据中， 除了 MSB 开始的 <code class="language-plaintext highlighter-rouge">[D11..D0]</code> 角度数据， 后续有用的还有 <code class="language-plaintext highlighter-rouge">ERR</code>， 能够识别磁铁安装位置是否合适， 在装机的时候非常有用。 <code class="language-plaintext highlighter-rouge">PARC</code> 用以进行奇偶校验， 该位需要和前 15 位数据保持奇数特性。 片选信号的性质就不多提了， 低选， 高非选， 且需要保持电平特定的时间。</p>

<blockquote>
  <p><a href="https://www.cnblogs.com/blogernice/articles/12531133.html">详解SPI中的极性CPOL和相位CPHA - blogernice 博客园</a><br />
<a href="https://zhuanlan.zhihu.com/p/26509678">秒懂 奇偶校验码 - 车卡门 知乎</a><br />
<a href="https://blog.csdn.net/ftswsfb/article/details/104321901">奇偶校验原理及C实现 - ftswsfb CSND</a><br />
<a href="https://blog.csdn.net/weixin_43593122/article/details/119253544">硬件探索——STM32F4通过SPI总线读取GMR（磁编码器） - 123-wqy CSDN</a></p>
</blockquote>

<h2 id="x-stm32-ll-库配置踩坑">X. STM32 LL 库配置踩坑</h2>

<p>在网上搜了一番发现 STM32 用 LL 库开发的效率和配置寄存器差不多， HAL 库的封装太多层了， 虽然移植性比较好但效率显著低于 LL 库。 但是， LL 库资源少而且有坑， 不过对于爱折腾的人以及从 51 那套开始习惯读寄存器的人而言， 倒也不是太大的问题。</p>

<h3 id="x1-tim1-配置-pwm-输出">X.1 TIM1 配置 PWM 输出</h3>

<p>LL 库通过 STM32CubeMX 生成的 TIM1 基础配置存在一定的问题。 见 <code class="language-plaintext highlighter-rouge">Core/Src/tim.c</code> 中对 <code class="language-plaintext highlighter-rouge">Prescaler</code> 以及 <code class="language-plaintext highlighter-rouge">Autoreload</code> 的配置， 会把 <code class="language-plaintext highlighter-rouge">36 - 1</code> 配置成 <code class="language-plaintext highlighter-rouge">36 - LL_TIM_IC_FILTER_FDIV1_N2</code> 怀疑这个与 CubeMX 不支持配置中运算有关系。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Core/Src/tim.c</span>
<span class="kt">void</span> <span class="nf">MX_TIM1_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Prescaler</span> <span class="o">=</span> <span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Autoreload</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 要使能 TIM1 的输出， <code class="language-plaintext highlighter-rouge">LL_TIM_CC_EnableChannel</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableCounter</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableAllOutputs</code> 这几条函数必须逐个使用， 具体含义可以参考 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj4k_zr4ZWAAxUKAt4KHS_0D60QFnoECBwQAQ&amp;url=https%3A%2F%2Fwww.st.com%2Fresource%2Fen%2Fuser_manual%2Fum1850-description-of-stm32f1-hal-and-lowlayer-drivers-stmicroelectronics.pdf&amp;usg=AOvVaw1DzMCa42sT0JPpOP1EH-0j&amp;opi=89978449">ST - Description of STM32F1 HAL and low-layer drivers</a></p>

<blockquote>
  <p><a href="https://www.cnblogs.com/yhpbook/p/yhp_stm32_tim.html">关于STM32CubeMX使用LL库设置PWM输出</a></p>
</blockquote>

<h3 id="x2-spi1">X.2 SPI1</h3>

<p>需要增加 <code class="language-plaintext highlighter-rouge">LL_SPI_Enable</code> 函数使能相关的 SPIx 设备。</p>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 驱动板开发的记录， 涉及 STM32 配置， 所用器件， 以及相关通信协议。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 7</title><link href="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 7" /><published>2023-07-13T00:00:00+08:00</published><updated>2023-07-13T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/13/rcore-note-ch7</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html"><![CDATA[<p>该章节尝试建立基于文件的统一I/O抽象， 将标准输入/标准输出的访问改造为基于文件描述符， 然后同样基于文件描述符实现一种父子进程之间的通信机制 —— <strong>管道</strong>， 从而实现灵活的进程间通信， 并基于文件抽象和管道支持不同的独立进程之间的动态组合来实现复杂功能。</p>

<dl>
  <dt>管道</dt>
  <dd>一种数据交换的机制， 管道可被视为一种特殊的内存文件， 在进程被打开的 <em><strong>fd_table</strong></em> 中被管理。 管道通过复用文件读写的系统函数调用可以方便地进行数据交换。</dd>
  <dt>信号</dt>
  <dd>进程间通信的一种异步通知机制， 可以看成是一个应用发出某种信号， 希望另外一个应用能及时响应。</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/ipc-os-detail-2.png" alt="IPC OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>IPC OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第七章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch7">[ch7]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件抽象">1. 文件抽象</h2>

<p><strong>文件</strong> 抽象统一了对 I/O 设备的管理， <strong>Everything is a file</strong> 的思想继承于 Multics OS 的 <strong>通用性</strong> 文件设计。 操作系统不关心文件的具体内容， 而只关心如何对文件按字节流进行读写。 rCore 对此进行了举例， 例如 <strong>键盘设备</strong> 对操作系统而言就是一个只读文件（读取键盘的输入数据）， <strong>屏幕设备</strong> 是只写文件（输出图片文字等信息） 等等。 在该章节基于文件的抽象， rCore 对标准输入和标准输出进行了重构， 为其实现了 <code class="language-plaintext highlighter-rouge">File Trait</code>， 使得进程能按照文件的接口与 I/O 外设交互。</p>

<p>一般来说， 文件的会涉及到， <code class="language-plaintext highlighter-rouge">open</code>， <code class="language-plaintext highlighter-rouge">close</code>， <code class="language-plaintext highlighter-rouge">read</code>， <code class="language-plaintext highlighter-rouge">write</code> 这些基本操作。</p>

<p>另外， 进程被创建的时候内核会默认打开三个缺省的文件， 这个设计对于后续的 I/O 重定向而言非常重要。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fd: 0</code> 标准输入</li>
  <li><code class="language-plaintext highlighter-rouge">fd: 1</code> 标准输出</li>
  <li><code class="language-plaintext highlighter-rouge">fd: 2</code> 标准错误输出</li>
</ul>

<p>需要注意的是， 子进程需要继承其父进程的所有的文件描述符与父进程共享所有文件， 基于这个设计， <code class="language-plaintext highlighter-rouge">pipe</code> 管道机制能够让父子进程共用一套标准输入和输出接口， 这样就构成了进程之间通信的基本桥梁。</p>

<h2 id="2-管道">2. 管道</h2>

<p>管道的设计就是基于以上文件抽象实现的几种机制， 其本质可被描述为一个 <strong>环形的缓冲队列</strong>， 具备 <strong>读端</strong> 和 <strong>写端</strong>， 读写两端通过不同的文件描述符进行访问。 通过文件抽象， 我们能对读写进行权限控制， 控制数据的流向。 另外， 只有读写两端都关闭后管道的资源才能被回收， 这要求除了实现 <code class="language-plaintext highlighter-rouge">sys_pipe</code> 系统调用， 还需要实现 <code class="language-plaintext highlighter-rouge">sys_close</code> 对文件的关闭进行控制。</p>

<p>rCore 对管道的设计分为端口设计与缓存设计。</p>

<ul>
  <li><strong>端口设计</strong> <code class="language-plaintext highlighter-rouge">struct Pipe</code>， 通过实现 <code class="language-plaintext highlighter-rouge">File Trait</code> 使得这两个端口能够通过文件描述符进行访问。</li>
  <li><strong>缓存设计</strong> <code class="language-plaintext highlighter-rouge">struct PipeRingBuffer</code>， 实际就是维护了一个环形的缓存队列。 值得注意的是 <code class="language-plaintext highlighter-rouge">struct Pipe</code> 用 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;</code> 维护对 <code class="language-plaintext highlighter-rouge">PipeRingBuffer</code> 的强引用计数， 这能保证在读写两端都被关闭后 <code class="language-plaintext highlighter-rouge">PipeRingBuffer</code> 中的资源能够被自动回收， 而 <code class="language-plaintext highlighter-rouge">PipeRingBuffer::write_end</code> 维护了一个弱引用计数， 这是为了后续检查写端是否全部被关闭的依据。</li>
</ul>

<blockquote>
  <p>只有写端都被关闭后才能保证没有数据被遗漏， 此时读端的关闭才是安全的。 另外， 写端实际是对读端存在依赖的， 若仅有一个写端， pipe 的缓冲区一定会耗尽， 而只存在一个读端却没什么问题， 大不了每次读返回都是 0。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/fs/pipe.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pipe</span> <span class="p">{</span>
    <span class="n">readable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">writable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">PipeRingBuffer</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PipeRingBuffer</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">RING_BUFFER_SIZE</span><span class="p">],</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">RingBufferStatus</span><span class="p">,</span>
    <span class="n">write_end</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">Pipe</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">enum</span> <span class="n">RingBufferStatus</span> <span class="p">{</span>
    <span class="n">FULL</span><span class="p">,</span>
    <span class="n">EMPTY</span><span class="p">,</span>
    <span class="n">NORMAL</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-标准-io-重定向">3. 标准 I/O 重定向</h2>

<p>重定向的想法在于对 <code class="language-plaintext highlighter-rouge">fd</code> 文件描述符进行替换。 由前述内容可知， 新建进程默认打开三个缺省的文件描述符分别描述标准输入(0)， 标准输出(1)， 标准错误输出(2)， 文件描述符分配有一条重要的性质： <em><strong>必定分配可用描述符中编号最小的一个</strong></em>， 而 <code class="language-plaintext highlighter-rouge">sys_dup</code> 做的工作就是将当前的文件拷贝到一个新的文件描述符。 所以， 例如我们先通过 <code class="language-plaintext highlighter-rouge">sys_close</code> 关闭标准输入， 那么再调用 <code class="language-plaintext highlighter-rouge">sys_dup(current_fd)</code> 就能让 <code class="language-plaintext highlighter-rouge">fd=1</code> 的位置的内容被替换为当前的目标文件。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/fs.rs</span>

<span class="cd">/// 功能：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中。</span>
<span class="cd">/// 参数：fd 表示进程中一个已经打开的文件的文件描述符。</span>
<span class="cd">/// 返回值：如果出现了错误则返回 -1，否则能够访问已打开文件的新文件描述符。</span>
<span class="cd">/// 可能的错误原因是：传入的 fd 并不对应一个合法的已打开文件。</span>
<span class="cd">/// syscall ID：24</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_dup</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.acquire_inner_lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="o">&gt;=</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">new_fd</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.alloc_fd</span><span class="p">();</span>
    <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">new_fd</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()));</span>
    <span class="n">new_fd</span> <span class="k">as</span> <span class="nb">isize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了能让用户端使用重定向， rCore 对 <code class="language-plaintext highlighter-rouge">user_shell</code> 进行了改进使其支持用户参数输入。 另外 <code class="language-plaintext highlighter-rouge">sys_exec</code> 需要取出这些传入的命令行参数， 放入 <code class="language-plaintext highlighter-rouge">args_vec: Vec&lt;String&gt;</code> 中作为参数传入 <code class="language-plaintext highlighter-rouge">TaskControlBlock::exec</code> 中， 这些参数会被压入用户栈中。 压栈的主体代码如下代码所示， 为了更清晰的表示压栈的过程， 我绘制了压栈的过程图， 假设压入了两个命令行参数 <code class="language-plaintext highlighter-rouge">aa</code> 和 <code class="language-plaintext highlighter-rouge">bb</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">impl</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">exec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">elf_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// push arguments on user stack</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">argv_base</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">argv</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">args</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">arg</span><span class="p">|</span> <span class="p">{</span>
                <span class="nf">translated_refmut</span><span class="p">(</span>
                    <span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span>
                    <span class="p">(</span><span class="n">argv_base</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">usize</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">args</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.as_bytes</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// make the user_sp aligned to 8B for k210 platform</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">user_sp</span> <span class="o">%</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="o">...</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="nf">.len</span><span class="p">();</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv_base</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack1.png" alt="Push stack process 1, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 1, HangX-Ma</u></font>
</div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack2.png" alt="Push stack process 2, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 2, HangX-Ma</u></font>
</div>

<p>压栈完成后 rCore 将 <code class="language-plaintext highlighter-rouge">TrapContext</code>中的 <code class="language-plaintext highlighter-rouge">a0</code> 和 <code class="language-plaintext highlighter-rouge">a1</code> 两个寄存器的值分别设置为输入参数的数量以及前述的 <code class="language-plaintext highlighter-rouge">argv_base</code>。 这样， 在应用第一次进入用户态的时候， 放在 Trap 上下文 <code class="language-plaintext highlighter-rouge">a0</code> 和 <code class="language-plaintext highlighter-rouge">a1</code> 两个寄存器中的内容可以被用户库中的入口函数以参数的形式接收。 rCore 在 <code class="language-plaintext highlighter-rouge">_start</code> 入口函数对这些起始地址做了转化， 将其转化为编写应用的时候看到的 <code class="language-plaintext highlighter-rouge">&amp;[&amp;str]</code> 的形式。</p>

<h2 id="4-信号">4. 信号</h2>

<p>信号机制补足了单向事件通知的机制， 这是一种类似于硬件中断的软件级异步通知机制， 使得进程在接收到特定事件的时候能够暂停当前的工作并及时响应事件， 并在响应事件之后可以恢复当前工作继续执行。 如果进程没有接收到任何事件， 它可以执行自己的任务。 这里的暂停与恢复的工作， 都由操作系统来完成， 应用程序只需设置好响应某事件的事件处理例程就够了。</p>

<p>信号的 <strong>接收方</strong> 是一个进程。 当某进程或操作系统发出信号时，会指定信号响应的对象， 即某个进程的 <code class="language-plaintext highlighter-rouge">pid</code>， 并由该进程预设的信号处理例程来进行具体的信号响应。 接收到信号有多种处理方式， 最常见的三种如下：</p>

<ul>
  <li>
    <p><strong>忽略</strong>：就像信号没有发生过一样。</p>
  </li>
  <li>
    <p><strong>捕获</strong>：进程会调用相应的处理函数进行处理。</p>
  </li>
  <li>
    <p><strong>终止</strong>：终止进程。</p>
  </li>
</ul>

<p>而信号的 <strong>发送方</strong> 有两个：</p>

<ul>
  <li><strong>异步信号</strong>： 进程在正常执行， 此时可能内核或者其他进程给它发送了一个信号， 这些就属于异步信号。</li>
  <li><strong>同步信号</strong>： 由进程自身的执行触发， 在处理 Trap 的时候内核会将相应的信号直接附加到进程控制块中， 这种属于同步信号。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/signal.png" alt="Signal process, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Signal process, rCore</u></font>
</div>

<p>内核会在 Trap 处理完成即将返回用户态之前检查要返回到的进程是否还有信号待处理。 如果需要处理的话，取决于进程是否提供该种信号的处理函数， 若没有提供该函数内核会接管进行默认处理， 整体流程如上图所示。</p>

<h3 id="41-信号相关的数据结构">4.1 信号相关的数据结构</h3>

<p>进程间发送的信号是某种事件， UNIX 采用了整数来对信号进行编号， 这些整数编号都定义了对应的信号的宏名， 宏名都是以 SIG 开头， 比如 SIGABRT, SIGKILL, SIGSTOP, SIGCONT。 rCore 定义了一个 <code class="language-plaintext highlighter-rouge">SignalFlags</code> 类型用以描述这些信号量的集合， 这个数据结构会大量应用到信号处理相关的功能上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">bitflags!</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalFlags</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">SIGDEF</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Default signal handling</span>
        <span class="k">const</span> <span class="n">SIGHUP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">SIGINT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="o">...</span>
        <span class="k">const</span> <span class="n">SIGSYS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外为了处理收到的信号， rCore 定义了 <code class="language-plaintext highlighter-rouge">SignalAction</code> 结构， 其中 <code class="language-plaintext highlighter-rouge">handler</code> 记录了信号处理的回调函数的入口地址， <code class="language-plaintext highlighter-rouge">mask</code> 则表示在处理该函数时需要屏蔽的其他信号的掩码， 这样内核就不会对这些信号进行处理而是直接回到用户态继续执行回调函数， 但这些被屏蔽的信号会被记录在 TCB 中延后处理。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Action for a signal</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">16</span><span class="nd">))]</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalAction</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">handler</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-信号的产生">4.2 信号的产生</h3>

<p>如前所述， 信号产生有异步信号和同步信号， rCore 将其分作三类， 前两类是异步信号， 最后一类是同步信号。</p>

<ol>
  <li>进程通过 <code class="language-plaintext highlighter-rouge">kill</code> 系统调用给自己或者其他进程发送信号。</li>
  <li>内核检测到某些事件给某个进程发送信号， 但这个事件与接收信号的进程的执行无关。</li>
  <li>进程执行的时候触发了某些条件， 于是在 Trap 到内核处理的时候， 内核给该进程发送相应的信号。 典型的就是 <code class="language-plaintext highlighter-rouge">SIGSEGV</code> 段错误和 <code class="language-plaintext highlighter-rouge">SIGILL</code> 非法指令。</li>
</ol>

<h4 id="kill-系统调用">kill 系统调用</h4>

<p>实现 <code class="language-plaintext highlighter-rouge">kill</code> 系统调用发送信号， 需要现在 TCB 中加入 <code class="language-plaintext highlighter-rouge">SignalFlags</code> 用以记录当前进程收到了哪些信号还未处理。 该系统调用的实现不算复杂， 我们需要给 <code class="language-plaintext highlighter-rouge">manager.rs</code> 中增添 <code class="language-plaintext highlighter-rouge">PID2TCB</code> 全局变量， 这个全局变量是一个 <strong>BtreeMap</strong> 数据结构， 在每次 <code class="language-plaintext highlighter-rouge">add_task</code> 的时候建立当前进程 pid 与当前进程的 TCB 的映射。 这样在实现 <code class="language-plaintext highlighter-rouge">sys_kill</code> 的时候能通过 <code class="language-plaintext highlighter-rouge">pid2task</code> 获取到对应的 TCB。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_kill</span><span class="p">(</span><span class="n">pid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">pid2task</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// insert the signal if legal</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task_ref</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.contains</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.insert</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是， 如果 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 中已经记录了未处理的信号， 在这个信号被处理之前不能加入同一个信号的待处理量。</p>

<h4 id="内核信号生成">内核信号生成</h4>

<p>就是将之前说的 <code class="language-plaintext highlighter-rouge">SIGSEGV</code> 以及 <code class="language-plaintext highlighter-rouge">SIGILL</code>， 在捕获到相应的 trap 之后， 内核主动对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 进行修改补充。</p>

<h3 id="43-信号的处理">4.3 信号的处理</h3>

<p>与信号处理相关的系统调用则有三个：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sys_sigaction</code>：设置信号处理例程</li>
  <li><code class="language-plaintext highlighter-rouge">sys_procmask</code>： 设置进程的信号屏蔽掩码</li>
  <li><code class="language-plaintext highlighter-rouge">sys_sigreturn</code>： 清除栈帧，从信号处理例程返回</li>
</ul>

<p>需要在 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中增加 <code class="language-plaintext highlighter-rouge">signal_mask</code> 以及 <code class="language-plaintext highlighter-rouge">signal_actions</code> 这两个变量用以屏蔽其他信号量以及记录如何对前述 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 记录的信号进行响应。 因而可以看到， <code class="language-plaintext highlighter-rouge">SignalActions</code> 实际上是个信号数量匹配的数组， 数组类型是 <code class="language-plaintext highlighter-rouge">SignalAction</code> 这样就能将信号量与待处理函数进行一一对应。 需要说明的是 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signal_mask</code> 声明了在该进程内会屏蔽的信号， 而 <code class="language-plaintext highlighter-rouge">SignalAction::mask</code> 是该回调函数会屏蔽的信号， 二者需要做 <strong>或</strong> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signal_mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signal_actions</span><span class="p">:</span> <span class="n">SignalActions</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// os/src/task/action.rs</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalActions</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">SignalAction</span><span class="p">;</span> <span class="n">MAX_SIG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>进程可以通过 <code class="language-plaintext highlighter-rouge">sys_sigaction</code> 系统调用捕获某种信号， 暂停进程当前的执行， 调用进程为该种信号提供的函数对信号进行处理， 处理完成之后再恢复进程原先的执行。 可以看到 <code class="language-plaintext highlighter-rouge">prev_action</code> 中存储着之前的处理例程（回调函数）， 需要将这部分内容存放在 <code class="language-plaintext highlighter-rouge">old_action</code> 中， 而将 <code class="language-plaintext highlighter-rouge">action</code> 中的内容替换进 table 中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigaction</span><span class="p">(</span>
      <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
      <span class="n">action</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">SignalAction</span><span class="p">,</span>
      <span class="n">old_action</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">SignalAction</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="o">...</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nf">check_sigaction_error</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">old_action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">let</span> <span class="n">prev_action</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
          <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">old_action</span><span class="p">)</span> <span class="o">=</span> <span class="n">prev_action</span><span class="p">;</span>
          <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="nf">translated_ref</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
          <span class="mi">0</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sys_procmask</code> 就没啥好说的， 把传入进来的 flags 设置好就行。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sys_sigreturn</code> 的实现在逻辑上也不复杂， 更新 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::handling_sig</code> 并恢复保存在 <code class="language-plaintext highlighter-rouge">trap_ctx_backup</code> 中的上下文， 需要注意的是返回的时候是 <code class="language-plaintext highlighter-rouge">trap_ctx.x[10]</code>， 这是为了避免上下文返回时原来的 <code class="language-plaintext highlighter-rouge">a0</code> 返回值被覆盖而出现返回值变更的问题。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/syscall/process.rs</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigreturn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
          <span class="n">inner</span><span class="py">.handling_sig</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="c1">// restore the trap context</span>
          <span class="k">let</span> <span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.get_trap_cx</span><span class="p">();</span>
          <span class="o">*</span><span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.trap_ctx_backup</span><span class="nf">.unwrap</span><span class="p">();</span>
          <span class="n">trap_ctx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="k">as</span> <span class="nb">isize</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>关于 <code class="language-plaintext highlighter-rouge">handle_signals</code> 包括的一系列内容详见 rCore 的指导书， 并没有太多疑问。</p>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="进程通信邮箱">进程通信：邮箱</h4>

<p>没有测例也不知道写的对不对， 基本上就是魔改一下 Pipe 的环形缓冲队列就整完了。</p>

<blockquote>
  <p>具体可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/e9b19e5f19851f12bcae83531a050d60230abd08">commit#e9b19e5</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第七章：进程间通信与 I/O 重定向， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 6</title><link href="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 6" /><published>2023-07-10T00:00:00+08:00</published><updated>2023-07-10T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/10/rcore-note-ch6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html"><![CDATA[<blockquote>
  <p>文件系统这块的内容还是相当复杂的， 当时学 xv6 就是一知半解把 lab 草草做完了事儿了， 结果这几个月调设备的时候遇到用 SPI Nand Flash 的设备， 文件系统挂载不上等问题。 自己对 Block Device， VFS， 以及 inode 这些概念的理解都不是很到位， 调试非常痛苦到最后陷入了死胡同， 借着学习 rCore 的机会争取把这块搞懂， 毕竟从头搭一个 OS 要对细节有更好的把握。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">easy-fs</code> 自下而上大致可以分成五个不同的层次：</p>

<dl>
  <dt>磁盘块设备接口层</dt>
  <dd>定义了以块大小为单位对磁盘块设备进行读写的 trait 接口</dd>
  <dt>块缓存层</dt>
  <dd>在内存中缓存磁盘块的数据， 避免频繁读写磁盘</dd>
  <dt>磁盘数据结构层</dt>
  <dd>磁盘上的超级块、 位图、 索引节点、 数据块、 目录项等核心数据结构和相关处理</dd>
  <dt>磁盘块管理器层</dt>
  <dd>合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构， 以及基于这些结构进行文件系统的创建等操作， 以及对磁盘块进行分配和回收处理</dd>
  <dt>索引节点层</dt>
  <dd>管理索引节点（即文件控制块）数据结构， 并实现文件创建/文件打开/文件读写等成员函数， 以向上支持文件操作相关的系统调用</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/fsos-fsdisk.png" alt="Filesystem OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Filesystem OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第六章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch6">[ch6]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件系统">1. 文件系统</h2>

<p>文件系统交互的主要对象是磁盘这类的存储器， 这类存储器和 RAM 的管理方式不同， 这类存储器以扇区 （一般为 512 bytes） 进行读写， 以块为单位进行存储 （一个块为由多个扇区组成）。 文件系统的职责就是将逻辑上的目录树结构映射存储到这类存储器中并进行管理。 另外， 为了适配管理多个文件系统， 在此基础上抽象出一层 <strong>虚拟文件系统（VFS, Virtual File System）</strong> 提供统一的接口和目录树的通用格式方便进行管理。</p>

<h2 id="2-块设备接口层">2. 块设备接口层</h2>

<p>文件系统以块为单位进行数据管理， 一般我们会通过 <strong>块设备驱动</strong> 完成对磁盘的数据的存取， 这需要文件系统提供接口对接驱动， 这种方式以二者职能为分界进行了层次化处理。 在 rCore 中提供 <code class="language-plaintext highlighter-rouge">BlockDevice</code> 抽象接口， 不过需要注意的是， 这个接口实现了 <code class="language-plaintext highlighter-rouge">Send</code>， <code class="language-plaintext highlighter-rouge">Sync</code>， <code class="language-plaintext highlighter-rouge">Any</code> 这几个 trait。 前两个见过面， 用以保证数据的线程安全， 但我目前还是不太理解下面这两句：</p>

<ul>
  <li><em>A type is Send if it is safe to send it to another thread.</em></li>
  <li><em>A type is Sync if it is safe to share between threads (<code class="language-plaintext highlighter-rouge">T</code> is Sync if and only if <code class="language-plaintext highlighter-rouge">&amp;T</code> is Send).</em></li>
</ul>

<p>由于 Rust 编译器需要知道 trait 实现时的具体大小， 因而 rCore 后续使用的时候都是以 <code class="language-plaintext highlighter-rouge">Arc&lt;dyn BlockDevice&gt;</code> 表明该 trait 类型， 被 <code class="language-plaintext highlighter-rouge">Arc</code> 引用包裹的静态大小是已知的， 这样编译器可以保证引用指向已分配堆的 <code class="language-plaintext highlighter-rouge">BlockDevice</code>， 同时还需要使用 <code class="language-plaintext highlighter-rouge">dyn</code> 关键字。</p>

<p>用到 <code class="language-plaintext highlighter-rouge">Any</code> 与 <code class="language-plaintext highlighter-rouge">BlockDevice</code> 是一个 trait 类型相关。 <code class="language-plaintext highlighter-rouge">Any</code> 的存在实现了 Rust 语言的部分的反射功能， 获得变量的类型 <code class="language-plaintext highlighter-rouge">TypeId</code>， 判断变量是否是指定类型， 转换该类型， 获取类型名称等， 具体的作用后续阅读代码再补充。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_dev.rs</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">BlockDevice</span> <span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="n">Any</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
    <span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">The Rustonomicon - 8.2. Send and Sync</a><br />
<a href="https://rustwiki.org/zh-CN/rust-by-example/trait/dyn.html">通过例子学 Rust 中文版 - 16.2. 使用 dyn 返回 trait</a><br />
<a href="https://www.jianshu.com/p/28386b52c607">Rust std-any 模块详解</a></p>
</blockquote>

<h2 id="3-块缓存层">3. 块缓存层</h2>

<p>块缓存层的存在是为了减少块设备频繁读写的开销， 相较于直接从 RAM 中获取数据， 读写磁盘的速度还是太慢了， 因而我们在软件层面实现块的缓存以加快数据的读写。 但缓存还得解决缓存一致性以及同步性等问题， rCore 使用块缓存全局管理器解决这些问题， 并通过该管理器一次性让更多的块合并操作， 这是因为连续的块的操作能够加速存取速度。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">],</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">modified</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每个 BlockCache 缓存一个磁盘块， 这是一个最小单位， rCore 提供了一些对缓存管理的方法：</p>

<ul>
  <li><strong>new</strong>： <code class="language-plaintext highlighter-rouge">BlockCache</code> 实现了 <code class="language-plaintext highlighter-rouge">new</code> 方法创建从磁盘读取一个 Block 到缓冲区。 前述所言， Block 大小和 Sector 大小一致均为 512 bytes， 这也是缓冲区 <code class="language-plaintext highlighter-rouge">cache</code> 被设置为 <code class="language-plaintext highlighter-rouge">BLOCK_SZ</code> 大小的原因。</li>
  <li><strong>addr_of_offset</strong>： 获取 <code class="language-plaintext highlighter-rouge">cache</code> 数组偏移 <code class="language-plaintext highlighter-rouge">offset</code> 大小的字节地址。</li>
  <li><strong>get_ref， get_mut</strong>： 通过调用 <code class="language-plaintext highlighter-rouge">addr_of_offset</code> 获取地址后， 将该地址声明为不可变或可变引用。</li>
</ul>

<p>rCore 将 <code class="language-plaintext highlighter-rouge">BlockCache::get_ref</code> 和 <code class="language-plaintext highlighter-rouge">BlockCache::get_mut</code> 封装成了 <code class="language-plaintext highlighter-rouge">BlockCache::read</code> 以及 <code class="language-plaintext highlighter-rouge">BlockCache::modify</code> 这两个泛型， 这两个函数后续用到非常多， 后面结合具体代码进行解释。 但从代码的构成而言， <code class="language-plaintext highlighter-rouge">read/modify</code> 构成了传入闭包 f 的一层执行环境，让它能够绑定到一个缓冲区上执行。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_ref</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>rCore 实现了很多与 <code class="language-plaintext highlighter-rouge">BlockCache</code> 相关的操作方法详见 Tutorial， 这里仅对个人疑难点做记录以及梳理思路。</p>
</blockquote>

<p>rCore 用 FIFO 作为简单的缓存替换策略并限定了缓存区的大小， <strong>块缓存全局管理器</strong> 完成了上述所说的缓存管理的功能。 值得注意的是缓存队列中存储的是 <strong>块编号</strong> 和 <strong>块缓存</strong> 组。 块缓存类型是 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</code>， 共享引用保证在当前 <strong>块缓存全局管理器</strong> 中保留一个引用外（FIFO 剔除缓存的依据）， 缓存请求者能够对缓存进行访问， 而 Mutex 则避免在后续多核拓展时的访存冲突。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCacheManager</span> <span class="p">{</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">struct BlockCacheManager</code> 实现了一个 <code class="language-plaintext highlighter-rouge">get_block_cache</code> 的方法， 通过将全局实例 <code class="language-plaintext highlighter-rouge">BLOCK_CACHE_MANAGER</code> 封装， 其他模块能够方便地调用 <code class="language-plaintext highlighter-rouge">get_block_cache</code> 获取 <code class="language-plaintext highlighter-rouge">block_id</code> 对应的缓存块， 但需要注意的是返回类型是 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</code> 调用者还需要通过 <code class="language-plaintext highlighter-rouge">.lock()</code> 方法获取互斥锁才能对 <code class="language-plaintext highlighter-rouge">BlockCache</code> 进行操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="n">BLOCK_CACHE_MANAGER</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.get_block_cache</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">block_device</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="4-磁盘布局及磁盘上数据结构">4. 磁盘布局及磁盘上数据结构</h2>

<p>前面几个部分比较好理解， 个人认为这个小节和 inode 小节最为关键且复杂。 要理解磁盘布局先得理解几个概念：</p>

<dl>
  <dt>索引节点(Inode, Index Node)</dt>
  <dd>Inode 编码了文件/目录的底层编号， 这个数据结构包含文件大小， 访问权限， 文件类型等信息， 还包含对数据的索引信息， 通过这些索引信息就能够找到数据块存储在磁盘上的位置。</dd>
  <dt>位图(Bitmap)</dt>
  <dd>位图用以标注索引节点以及数据块的分配情况， 通过位图能够方便分配和回收在磁盘上的存储资源。</dd>
</dl>

<p>rCore 中的磁盘布局如下图所示， 他们是以 Block ID 顺序排布的， 后续根据这个顺序对关键数据结构进行阐述。 这里需要注意的是， rCore 的假定内核仅管理一个块设备， 否则仅以 Block ID 作为标识， 在访问多个不同的块设备的时候会引起歧义。</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/layouts.png" alt="Disk Layouts, HangX-Ma" width="800" /><a id="disk-layouts"></a>
    <br />
    <font size="2" color="#999"><u>Disk Layouts, HangX-Ma</u></font>
</div>

<h3 id="41-super-block">4.1 Super Block</h3>

<p>一句话可以概括， Super Block 存储了后续四个分区占用的 <strong>块数量</strong>， 并利用 <strong>MAGIC</strong> 验证文件系统的合法性。</p>

<h3 id="42-inodedata-bitmap">4.2 Inode/Data Bitmap</h3>

<p>从磁盘布局可以看出， rCore 通过 <strong>Inode Bitmap</strong> 和 <strong>Data Bitmap</strong> 分别管理索引节点和数据块。 每个 Bitmap 可以占据多个块， 在 rCore 中一个块的大小和一个扇区的大小一致都是 512 bytes， 相当于每个 Bitmap 实际上可以管理 \(4096 \times n\) 个索引节点或数据块。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="n">start_block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">blocks</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">BitmapBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u64</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
</code></pre></div></div>

<p>rCore 教程中的 <code class="language-plaintext highlighter-rouge">struct Bitmap</code> 存储的是 <strong>Inode Bitmap</strong> 或 <strong>Data Bitmap</strong> 在磁盘中的位置和大小的信息， 而这个数据结构本身则是存储在 RAM 中的。 rCore 另外用 <code class="language-plaintext highlighter-rouge">BitmapBlock</code> 数组表示每个 4096-bit 大小的数据块。 理解这个数据结构的设计原理， <code class="language-plaintext highlighter-rouge">struct Bitmap</code> 中的 <code class="language-plaintext highlighter-rouge">alloc</code> 和 <code class="language-plaintext highlighter-rouge">dealloc</code> 两个方法的实现就容易理解了。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            start_block_id(Start ID)
                  v
        ----------+---------------------+--------
                  |//// Bitmap Area ////|
        ----------+---------------------+--------
                                        ^
                             start_block_id + blocks(End ID)
        Block ID =&gt; 
        (increase)
</code></pre></div></div>

<p>这里结合 <code class="language-plaintext highlighter-rouge">alloc</code> 函数阐明 <code class="language-plaintext highlighter-rouge">BlockCache</code> 提供的 <code class="language-plaintext highlighter-rouge">read/modify</code> 方法。 注意 <code class="language-plaintext highlighter-rouge">modify</code> 函数中的闭包， 它显式声明了传入闭包的参数的类型是 <code class="language-plaintext highlighter-rouge">&amp;mut BitmapBlock</code> 这样 <code class="language-plaintext highlighter-rouge">modify</code> 中才能将泛型 <code class="language-plaintext highlighter-rouge">T</code> 实例化为具体的类型 <code class="language-plaintext highlighter-rouge">BitmapBlock</code>。 这样通过声明的 <code class="language-plaintext highlighter-rouge">bitmap_block</code>， 我们实际上能对缓冲区的数据进行更改操作。 如果没有理解 <code class="language-plaintext highlighter-rouge">read/modify</code> 泛型的作用， 闭包中捕获的参数的数据来源就会混淆， 对后续的实验理解造成较大的阻碍。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">const</span> <span class="n">BLOCK_BITS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">BLOCK_SZ</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.blocks</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="nf">get_block_cache</span><span class="p">(</span>
                <span class="n">block_id</span> <span class="o">+</span> <span class="k">self</span><span class="py">.start_block_id</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
                <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nf">.lock</span><span class="p">()</span>
            <span class="nf">.modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> 
            <span class="p">|</span><span class="n">bitmap_block</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BitmapBlock</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">inner_pos</span><span class="p">))</span> <span class="o">=</span> <span class="n">bitmap_block</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.enumerate</span><span class="p">()</span>
                    <span class="nf">.find</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="o">**</span><span class="n">bits64</span> <span class="o">!=</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="p">{</span>
                        <span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="nf">.trailing_ones</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                    <span class="p">})</span> <span class="p">{</span>
                    <span class="c1">// modify cache</span>
                    <span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="n">inner_pos</span><span class="p">;</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">block_id</span> <span class="o">*</span> <span class="n">BLOCK_BITS</span> <span class="o">+</span> <span class="n">bits64_pos</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">inner_pos</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="k">if</span> <span class="n">pos</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="43-inode-blocks">4.3 Inode Blocks</h3>

<p>Inode 存储着每个文件/目录的元数据： 文件/目录大小 <code class="language-plaintext highlighter-rouge">size</code>， 索引节点类型 <code class="language-plaintext highlighter-rouge">type_</code>， 以及对数据块的索引 <code class="language-plaintext highlighter-rouge">direct/indirect1/indirect2</code>。 在虚拟内存映射的章节 rCore 通过三级页表进行索引， 这里的 Inode 索引方式也很类似。 rCore 设计的单个 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的大小是 128 bytes， 也就是 <strong>Inode Blocks</strong> 中每个块能够存储 4 个 <code class="language-plaintext highlighter-rouge">DiskInode</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">const</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">direct</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">indirect1</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">indirect2</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">type_</span><span class="p">:</span> <span class="n">DiskInodeType</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">DiskInodeType</span> <span class="p">{</span>
    <span class="n">File</span><span class="p">,</span>
    <span class="n">Directory</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的多级索引是这样理解的， 分为直接索引 (direct) 和 间接索引 (indirect1/indirect2)。</p>

<ul>
  <li><strong>直接索引</strong> <code class="language-plaintext highlighter-rouge">direct</code> 数组的每一个元素都保存着一个数据块的 Block ID， 这在文件尺寸不大于 <code class="language-plaintext highlighter-rouge">28 * 512 bytes = 14 KiB</code> 时使用。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/direct-index.png" alt="Direct Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Direct Index, HangX-Ma</u></font>
</div>

<ul>
  <li><strong>间接索引</strong>
    <ul>
      <li>装满 <code class="language-plaintext highlighter-rouge">direct</code> 这部分内容后需要用间接索引扩大索引范围。 可以使用 <code class="language-plaintext highlighter-rouge">indirect1</code> 存储一个数据块的 Block ID 获取到这个数据块的内容， 而这个数据块我们不直接保存数据， 而是将其当作一个跳板用来存储其他数据块的 Block ID。 512 bytes 的数据块以 <code class="language-plaintext highlighter-rouge">u32(4 bytes)</code> 为单位， 这个数据块最大能存储 128 个 Block ID， 这样我们还能额外索引到 <code class="language-plaintext highlighter-rouge">128 * 512 bytes = 64 KiB</code> 的数据。</li>
      <li>相同的道理， 一级间接索引和直接索引总共 78 KiB 空间都不够用， 就可以再加上二级间接索引， 通过二级索引先找到一级索引块的 Block ID， 这些一级间接索引指向的每个数据块都不直接保存数据， 而是存储其他数据块的 Block ID， 这样再通过一级索引就能确定最终的数据块， 这种设计能额外索引 8 MiB 的额外内容。</li>
    </ul>
  </li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/indirect-index.png" alt="Indirect Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Indirect Index, HangX-Ma</u></font>
</div>

<p><code class="language-plaintext success highlighter-rouge">NOTE: 关于 get_block_id 的一些疑惑和相关解释</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">inner_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基于直接索引和间接索引， <code class="language-plaintext highlighter-rouge">DiskInode</code> 提供了获取数据块索引的功能的 <code class="language-plaintext highlighter-rouge">get_block_id</code> 函数。 这个函数的接口需要读入一个 <code class="language-plaintext highlighter-rouge">inner_id</code>， 这个并不是对应实际的磁盘的 Block ID 的， 而是根据这个 <code class="language-plaintext highlighter-rouge">inner_id</code> 的大小结合我们存储在 <code class="language-plaintext highlighter-rouge">Inode</code> 中的 <code class="language-plaintext highlighter-rouge">direct</code>， <code class="language-plaintext highlighter-rouge">indirect1</code> 以及 <code class="language-plaintext highlighter-rouge">indirect2</code> 可以获取到对应的数据块所在的 Block ID。</p>
<blockquote>
  <p>那这些数据又是怎么来的？ 通过 <a href="#6-索引节点">6. 索引节点</a>， 中 <code class="language-plaintext highlighter-rouge">struct Inode</code> 提供了 <code class="language-plaintext highlighter-rouge">create</code> 方法。</p>
</blockquote>

<p>对于 <code class="language-plaintext highlighter-rouge">inner_id</code> 可以确定是使用直接索引还是间接索引， 直接索引 <code class="language-plaintext highlighter-rouge">direct</code> 范围是 \([0;27]\)，  <code class="language-plaintext highlighter-rouge">indirect1</code> 的范围是 \([28;127]\)， <code class="language-plaintext highlighter-rouge">indirect2</code> 的范围是 \([128;128*128-1]\)。 实际的 <code class="language-plaintext highlighter-rouge">inner_id</code> 和索引方式的分布值如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/inner-id.png" alt="Inner ID, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Inner ID, HangX-Ma</u></font>
</div>

<p>后续关于 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的各种辅助方法就不展开了。</p>

<h3 id="44-data-block--directory">4.4 Data Block / Directory</h3>

<p>对 <strong>文件</strong> 而言其内容就是字节序列， 保存文件内容的数据块可以用字节数组表示。 前述的 Inode 相关的 <code class="language-plaintext highlighter-rouge">read_at</code> 和 <code class="language-plaintext highlighter-rouge">write_at</code> 方法中就是对这些字节数组进行操作。 这里我对 <code class="language-plaintext highlighter-rouge">read_at</code> 以及 <code class="language-plaintext highlighter-rouge">write_at</code> 操作的数据的位置是有疑惑的， 因为 rCore 自下而上编写的这个教学手册， 底层的内容很可能是有上层的包装的 （突然就想起李雅普诺夫判定式了）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">type</span> <span class="n">DataBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">];</span>
</code></pre></div></div>

<p>对 <strong>目录</strong> 而言情况则有所不同， 我们需要建立一种树的结构进行逐级访问。 rCore 设计了 <code class="language-plaintext highlighter-rouge">struct DirEntry</code> 用以存储目录项结构， 其大小为 32 bytes， 这意味着每个 Data Block 可以最多存储 16 个目录项结构。 <code class="language-plaintext highlighter-rouge">name</code> 表示该目录下的一个文件名或子目录目录名， <code class="language-plaintext highlighter-rouge">inode_number</code> 则是这个文件或子目录所对应的 Inode 的节点编号。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">const</span> <span class="n">NAME_LENGTH_LIMIT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DirEntry</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">NAME_LENGTH_LIMIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">inode_number</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">DIRENT_SZ</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-磁盘块管理器">5. 磁盘块管理器</h2>

<p>在前面我们描述了磁盘的布局及其相应的数据结构， 这里就是将这些这些细节进行统筹管理， <code class="language-plaintext highlighter-rouge">struct EasyFileSystem</code> 中所保留的信息正好是 <a href="#disk-layouts">Disk Layouts</a> 中描述的几个部分。 另外， 保留 <code class="language-plaintext highlighter-rouge">block_device</code> 指针引用是方便下层数据结构访问块设备。 可以看到这个数据结构中是不包含 superblock 的， 但是在后续计算的时候需要考虑进去。 从这里开始， 所有的数据结构都存储在内存上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/efs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">EasyFileSystem</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">inode_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="n">inode_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// inode 区域的起始 block id</span>
    <span class="n">data_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// data 区域的起始 block id</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="6-索引节点">6. 索引节点</h2>

<p>服务于文件相关系统调用的索引节点层的代码在 <code class="language-plaintext highlighter-rouge">vfs.rs</code> 中， rCore 抽象了一层 Virtual Filesystem 方便使用者管理文件系统的文件与目录。</p>

<p><code class="language-plaintext highlighter-rouge">Inode</code> 和 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的区别从它们的名字中就可以看出： <code class="language-plaintext highlighter-rouge">DiskInode</code> 放在磁盘块中比较固定的位置，而 <code class="language-plaintext highlighter-rouge">Inode</code> 是放在内存中的记录文件索引节点信息的数据结构。 <code class="language-plaintext highlighter-rouge">Inode</code> 数据结构给使用者直接管理目录树结构中逻辑上的文件和目录的接口。 这个 <code class="language-plaintext highlighter-rouge">Inode</code> 在磁盘上所处的位置用 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 即可表示， <code class="language-plaintext highlighter-rouge">fs</code> 则给 Inode 提供了访问底层文件系统的接口。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Inode</span> <span class="p">{</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 后续还介绍了获取根目录 Inode, 文件索引， 文件列举， 文件创建， 文件清空， 文件读写的方式。 一直到这里把这几个函数读完， 以及将前述的所有内容再细读之后， 我才理清了 <code class="language-plaintext highlighter-rouge">DiskInode</code> 中的数据是如何被创建以及如何被索引管理的， 之前一直没搞懂究竟数据是如何被定位到 Data Block 的， 实际上就是 root_node 创建新的 child node 的时候 (Inode::create) 就通过 <code class="language-plaintext highlighter-rouge">EasyFileSystem::alloc_inode</code> 在 Inode Area 创建了一个新的 Inode， 最开始这个 Inode 是不存在任何数据的(<code class="language-plaintext highlighter-rouge">DiskInode::initialize</code> 返回的是个空的 <code class="language-plaintext highlighter-rouge">DiskInode</code>)， 只有在调用 <code class="language-plaintext highlighter-rouge">Inode::increase_size</code> 之后， 通过 <code class="language-plaintext highlighter-rouge">EasyFileSystem::alloc_data</code> 申请数据块后， 利用 <code class="language-plaintext highlighter-rouge">DiskInode::increase_size</code> 函数将这些数据块和 <code class="language-plaintext highlighter-rouge">direct</code>， <code class="language-plaintext highlighter-rouge">indirect1</code>， 以及 <code class="language-plaintext highlighter-rouge">indirect2</code> 填充并联系起来的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="cd">/// Increase the size of a disk inode</span>
<span class="k">fn</span> <span class="nf">increase_size</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">new_size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">disk_inode</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">DiskInode</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MutexGuard</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">disk_inode</span><span class="py">.size</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">blocks_needed</span> <span class="o">=</span> <span class="n">disk_inode</span><span class="nf">.blocks_num_needed</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">blocks_needed</span> <span class="p">{</span>
        <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">fs</span><span class="nf">.alloc_data</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">disk_inode</span><span class="nf">.increase_size</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.block_device</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="7-课后练习">7. 课后练习</h2>

<h3 id="71-编程练习">7.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="72-实验练习">7.2 实验练习</h3>

<h4 id="硬链接">硬链接</h4>

<p>硬链接要求两个不同的目录项指向同一个文件， 在 easy-fs 中就是两个不同名称目录项指向同一个磁盘块。 需要实现三个系统调用 <code class="language-plaintext highlighter-rouge">sys_linkat</code>， <code class="language-plaintext highlighter-rouge">sys_unlinkat</code>， 以及 <code class="language-plaintext highlighter-rouge">sys_stat</code>。</p>

<p>硬链接需要新的 Inode 的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 与被链接的对象是一致的， 这样才能保证链接到同一个文件数据， 而这两个数据则是通过 <code class="language-plaintext highlighter-rouge">get_disk_inode_pos</code> 函数获取到的， 依据是 <code class="language-plaintext highlighter-rouge">DirEntry</code> 中的 <code class="language-plaintext highlighter-rouge">inode_id</code> 这个数据。 所以 <code class="language-plaintext highlighter-rouge">sys_linkat</code> 的实现和 <code class="language-plaintext highlighter-rouge">Inode::create</code> 非常类似， 唯一不同的是 <code class="language-plaintext highlighter-rouge">new_inode_id</code> 不再是通过 <code class="language-plaintext highlighter-rouge">fs.alloc_inode</code> 获取一个新的 <code class="language-plaintext highlighter-rouge">inode_id</code>， 而是和需要链接的对象的完全一致。</p>

<p>对于 <code class="language-plaintext highlighter-rouge">sys_unlinkat</code> 就是和上述实现相反， 通过输入的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 这两个参数， 遍历 <code class="language-plaintext highlighter-rouge">file_count</code> 数量的 <code class="language-plaintext highlighter-rouge">DirEntry</code> 并将数据读取到 <code class="language-plaintext highlighter-rouge">buf</code> 中查看 <code class="language-plaintext highlighter-rouge">buf</code> 对应的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 是否和所给的参数一致， 另外实验不要求删除这个被分配的 inode。</p>

<p><code class="language-plaintext highlighter-rouge">sys_stat</code> 这部分遇到的比较大的问题是如何将 <code class="language-plaintext highlighter-rouge">fd_table</code> 获取的到的 <code class="language-plaintext highlighter-rouge">OSInode</code> 从一个 trait 转换成实际的数据类型。 参考了 <a href="https://github.com/yao-jz/rCore-lab/commit/5bdaac804d7ab042f337261ecefa50bda72c0896">yao-jz/rCore-lab - ch6</a> 中的实现， 需要给 File Trait 增加一个自己实现的 AnyConvertor Trait， 能够将任意类型转为 <code class="language-plaintext highlighter-rouge">&amp;dyn Any</code> 再通过 <code class="language-plaintext highlighter-rouge">downcast_ref::&lt;OSInode&gt;()</code> 强制转换为 <code class="language-plaintext highlighter-rouge">OSInode</code> 数据类型。 这样我们再给 <code class="language-plaintext highlighter-rouge">OSInode</code> 增加 <code class="language-plaintext highlighter-rouge">get_inode_id</code> 以及 <code class="language-plaintext highlighter-rouge">get_inode_pos</code> 获取 <code class="language-plaintext highlighter-rouge">inode_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_id</code> 和 <code class="language-plaintext highlighter-rouge">block_offset</code> 即可。 另外需要一个 <code class="language-plaintext highlighter-rouge">get_nlink_num</code> 函数获取 <code class="language-plaintext highlighter-rouge">nlink</code> 硬链接的数量， 思路和 unlink 的实现很类似， 也是遍历 <code class="language-plaintext highlighter-rouge">file_count</code> 数量的 <code class="language-plaintext highlighter-rouge">DirEntry</code> 只不过我们只计数。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">Any</span><span class="p">;</span>

<span class="cd">/// convert current type to &amp;dyn Any</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">AnyConvertor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="n">AnyConvertor</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/1b6c70b223719a7207a786fdc49e09eccce51480">commit#1b6c70b</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第六章：文件系统， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 5</title><link href="https://hangx-ma.github.io/2023/07/07/rcore-note-ch5.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 5" /><published>2023-07-07T00:00:00+08:00</published><updated>2023-07-07T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/07/rcore-note-ch5</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/07/rcore-note-ch5.html"><![CDATA[<p>Process OS 强化了以往用以调度应用的 task 的概念， 在这一层抽象的基础上发展出 process， 弱化了 CPU 与任务之间的耦合关系， 所以单从操作系统结构的角度分析其实并没有太大的变化。</p>

<div align="center">
    <img src="/norobots/images/2023-07-07-rcore-note-ch5/process-os-detail.png" alt="Process OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Process OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第五章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch5">[ch5]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-进程概念">1. 进程概念</h2>

<p><strong>进程</strong> 就是操作系统选取某个可执行文件并对其进行一次动态执行的过程， 对于可执行文件中给出的需求能相应对 <strong>硬件/虚拟资源</strong> 进行 <strong>动态绑定和解绑</strong>。 进程的引入让开发者能够控制程序的运行， 操作系统能够面向用户进行交互。 rCore 增添了操作系统中最为关键的几个系统调用： <code class="language-plaintext highlighter-rouge">sys_fork</code>， <code class="language-plaintext highlighter-rouge">sys_waitpid</code>， <code class="language-plaintext highlighter-rouge">sys_exec</code>， 以及 <code class="language-plaintext highlighter-rouge">sys_read</code>。 同样的， 通过引入 <code class="language-plaintext highlighter-rouge">buddy_system_allocator</code> 提供动态内存分配支持， 结合这些系统调用， 在用户态 rCore 提供了一个用户初始程序 <strong>initproc</strong>， 这让 rCore 具备了与应用层的交互能力， 但其背后则需依托 rCore 的进程管理。</p>

<h2 id="2-进程管理的组成结构">2. 进程管理的组成结构</h2>

<p>rCore 为增添了 <code class="language-plaintext highlighter-rouge">struct PidHandle</code> 作为每个进程的标识， 其实现与上一章的 Physical Frame 非常类似。 另外 rCore 改造了 <code class="language-plaintext highlighter-rouge">build.rs</code> 和 <code class="language-plaintext highlighter-rouge">loader.rs</code> 以使 rCore 能够支持应用名而非 task id 加载应用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/pid.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">PidHandle</span><span class="p">(</span><span class="k">pub</span> <span class="nb">usize</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="21-应用的内核栈">2.1 应用的内核栈</h3>

<p>由于引入了进程标识 PID， 之前用 task id 进行应用区分的方式需要用 PID 替代， 所有应用的内核栈的创建就与以往有所不同。 rCore 从 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中分离了 <code class="language-plaintext highlighter-rouge">KernelStack</code> 用以初始化与管理每个应用的内核栈。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/pid.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="n">pid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="22-进程控制块">2.2 进程控制块</h3>

<p>在内核中，每个进程的执行状态、资源控制等元数据均保存在一个被称为 <strong>进程控制块 (PCB, Process Control Block)</strong> 的结构中，它是内核对进程进行管理的单位。 对于 rCore 而言， PCB 其实是对原来的 TCB 的扩展， 并区分 immutable 与 mutable 两类数据 （ Inner 块使用 <code class="language-plaintext highlighter-rouge">UPSafeCell&lt;T&gt;</code> 管理可变数据）。 第五章新增的是 <code class="language-plaintext highlighter-rouge">parent</code>， <code class="language-plaintext highlighter-rouge">children</code>， 以及 <code class="language-plaintext highlighter-rouge">exit_code</code> 这几个可变量， 使用 <code class="language-plaintext highlighter-rouge">Weak</code> 智能指针能确保不影响父进程的引用计数， 而 <code class="language-plaintext highlighter-rouge">Arc</code> 则提供了对子进程的引用计数， 这两者的配合可以保证父子进程的双向关系以及控制子进程的资源回收了。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_stack</span><span class="p">:</span> <span class="n">KernelStack</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外我认为解决了上一章痛点问题的是关于任务控制模块的访问方式， rCore 的第五章提供了 <code class="language-plaintext highlighter-rouge">inner_exclusive_access</code> 方法， 此前我也尝试过类似的返回引用的方式避免直接拷贝一整个 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 以避免巨大的开销， 但当时没有考虑到可以在外层包裹一层 <code class="language-plaintext highlighter-rouge">UPSafeCell&lt;T&gt;</code>。 另外相应的， 增加了外增 Wrapper 以及 PID 后， 原来的 <strong>任务控制块创建</strong> 也要转变为 <strong>进程控制块创建</strong>， 其实主要差异就是 Kernel Stack 的创建以及新增的变量的初始化。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">impl</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">inner_exclusive_access</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RefMut</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">TaskControlBlockInner</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>除此之外就是在 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中实现几个关键的系统调用了。</p>

<blockquote>
  <p>需要一提的是， 由于增添了 <code class="language-plaintext highlighter-rouge">wrapper</code>， <code class="language-plaintext highlighter-rouge">os/src/task/mod.rs</code> 中的代码对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 中数据访问发生了变化， 这一块需要大改。</p>
</blockquote>

<h3 id="23-进程管理器">2.3 进程管理器</h3>

<p><strong>任务管理器</strong> 或称 <strong>进程管理器</strong> <code class="language-plaintext highlighter-rouge">TaskManager</code> 将 CPU 的监控职能拆分到处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 中， 其自身仅负责管理所有进程， 这种分离有助于后续实现多核环境的拓展。 这里比较关键的设计是将 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 用 <code class="language-plaintext highlighter-rouge">Arc</code> 智能指针管理， 并将其存储在堆上， 不仅减少开销也方便维护。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/manager.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskManager</span> <span class="p">{</span>
    <span class="n">ready_queue</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="24-cpu-管理器">2.4 CPU 管理器</h3>

<p>处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 负责维护 CPU 相关的状态。 其中 <code class="language-plaintext highlighter-rouge">current</code> 表示当前处理器上执行的进程任务， 而 <code class="language-plaintext highlighter-rouge">idle_task_cx</code> 则是 idle 控制流的任务上下文。 这个 idle 控制流运行在 CPU 启动栈上， 它会从 <code class="language-plaintext highlighter-rouge">TaskManager</code> 中选择一个进程任务放在当前的 CPU 核上运行。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/processor.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Processor</span> <span class="p">{</span>
    <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">idle_task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>idle 控制流的设计目的在于分离进程调度与 Trap， 换入/换出进程仅需要调用 <code class="language-plaintext highlighter-rouge">schedule</code> 函数， 通过 <code class="language-plaintext highlighter-rouge">__switch</code> 保存自身进程的上下文， 之后程序流会换回 <code class="language-plaintext highlighter-rouge">idle_task_cx_ptr</code> 中的内容重新回到 <code class="language-plaintext highlighter-rouge">run_tasks</code> 的 loop 循环中查找下一个待运行的进程。 这点设计和 xv6 如出一辙， 在 rCore 中则是会持续运行 <code class="language-plaintext highlighter-rouge">run_tasks</code> 用以进程的调度。 引用我自己在 rCore 留言板上的 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/47#issuecomment-1625393985">回答</a> 能帮助理解它的作用：</p>

<blockquote>
  <p>idle 控制流的设计和 xv6 的很像， rCore 让 <code class="language-plaintext highlighter-rouge">run_tasks</code> 始终保持运行， 可以把这个函数想象成一个游戏机，它的作用就是不断挑选可运行的游戏卡（进程）， 然后放到 CPU 这个卡槽中。 一定时间后这个 CPU 卡槽要给别的游戏卡（进程）用了就把这个当前的卡弹出来（这里就用了 <code class="language-plaintext highlighter-rouge">schedule</code> 函数弹出）， 然后游戏机又开始选下一张能用的游戏卡（进程）了。</p>

  <p>游戏卡（进程）只知道自己被插上要运行， 以及到某个点自己要弹出来， 它不知道游戏机的存在， 这样就做到了任务调度的透明。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/processor.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">run_tasks</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">PROCESSOR</span><span class="nf">.exclusive_access</span><span class="p">();</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">fetch_task</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idle_task_cx_ptr</span> <span class="o">=</span> <span class="n">processor</span><span class="nf">.get_idle_task_cx_ptr</span><span class="p">();</span>
            <span class="c1">// access coming task TCB exclusively</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task_inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">next_task_cx_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task_inner</span><span class="py">.task_cx</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">;</span>
            <span class="n">task_inner</span><span class="py">.task_status</span> <span class="o">=</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Running</span><span class="p">;</span>
            <span class="c1">// stop exclusively accessing coming task TCB manually</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">task_inner</span><span class="p">);</span>
            <span class="n">processor</span><span class="py">.current</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
            <span class="c1">// stop exclusively accessing processor manually</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">processor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="nf">__switch</span><span class="p">(</span>
                    <span class="n">idle_task_cx_ptr</span><span class="p">,</span>
                    <span class="n">next_task_cx_ptr</span><span class="p">,</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">switched_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">PROCESSOR</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">idle_task_cx_ptr</span> <span class="o">=</span> <span class="n">processor</span><span class="nf">.get_idle_task_cx_ptr</span><span class="p">();</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">processor</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">__switch</span><span class="p">(</span>
            <span class="n">switched_task_cx_ptr</span><span class="p">,</span>
            <span class="n">idle_task_cx_ptr</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-进程管理的实现机制">3. 进程管理的实现机制</h2>

<h3 id="31-初始进程创建">3.1 初始进程创建</h3>

<p>可以先看一下 rCore 在第五章的 <code class="language-plaintext highlighter-rouge">main.rs</code> 做的事情， 可以看到在内存管理模块初始化完成后， 会调用 <code class="language-plaintext highlighter-rouge">task</code> 子模块提供的 <code class="language-plaintext highlighter-rouge">add_initproc</code> 将初始进程 <code class="language-plaintext highlighter-rouge">ch5b_initproc</code> 加入进程任务管理器。 因而在 task 子模块中需要初始化进程控制块 <code class="language-plaintext highlighter-rouge">INITPROC</code>。 另外， <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 相较之前有所变更。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/main.rs</span>
<span class="nd">#[no_mangle]</span> <span class="c1">// avoid compiler confusion</span>
<span class="k">fn</span> <span class="nf">rust_main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">clear_bss</span><span class="p">();</span>
    <span class="nf">kernel_log_info</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] Hello, world!"</span><span class="p">);</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] back to world!"</span><span class="p">);</span>
    <span class="c1">// mm tests</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">heap_test</span><span class="p">();</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">frame_allocator_test</span><span class="p">();</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">remap_test</span><span class="p">();</span>

    <span class="nn">task</span><span class="p">::</span><span class="nf">add_initproc</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"after initproc!"</span><span class="p">);</span>

    <span class="nn">trap</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>
    <span class="nn">trap</span><span class="p">::</span><span class="nf">enable_timer_interrupt</span><span class="p">();</span>
    <span class="nn">timer</span><span class="p">::</span><span class="nf">set_next_trigger</span><span class="p">();</span>
    <span class="nn">loader</span><span class="p">::</span><span class="nf">list_apps</span><span class="p">();</span>
    <span class="nn">task</span><span class="p">::</span><span class="nf">run_tasks</span><span class="p">();</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Unreachable in rust_main!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="32-进程调度机制">3.2 进程调度机制</h3>

<p>进程调度一方面是 CPU 分给当前进程的时间片用尽触发 <code class="language-plaintext highlighter-rouge">SupervisorTimer</code> 中断需要调度， 另一方面是进程主动让出 CPU 的占用权， 都需要用到 <code class="language-plaintext highlighter-rouge">suspend_current_and_run_next</code> 这个函数。 在引入进程的抽象之后， 调度不需要进程本身更新关于 <code class="language-plaintext highlighter-rouge">__switch</code> 函数相关的内容， 只需要获取当前进程的控制块 TCB 并将其加入 task 队列中后使用 <code class="language-plaintext highlighter-rouge">schedule</code> 即可。 这也是前述引入 idle 控制流的好处之一， 对进程调度的解耦让整个代码流都干净了很多。</p>

<h3 id="33-进程的生成机制">3.3 进程的生成机制</h3>

<p>这块相较而言就会显得复杂一些， 在内核中唯一的初始化进程是 <code class="language-plaintext highlighter-rouge">initproc</code>， 后续的进程都需要通过 <code class="language-plaintext highlighter-rouge">fork/exec</code> 这两个系统调用提供的进程生成机制实现。</p>

<ul>
  <li>
    <p><strong>fork</strong></p>

    <p><code class="language-plaintext highlighter-rouge">fork</code> 需要对除了返回值外的父进程所有信息的完全复制， 这甚至要求地址空间的映射方式， 映射页的权限， 映射范围， 以及数据都需要与父进程一致， 不同的是最终映射到的具体的物理地址页 PPN。 在 rCore 中管理这部分信息的是 <code class="language-plaintext highlighter-rouge">memory_set.rs</code>， 为了复制这些信息新增了 <code class="language-plaintext highlighter-rouge">from_another</code> 函数拷贝一个 <strong>逻辑段</strong> 的上述数据。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>
  <span class="k">impl</span> <span class="n">MapArea</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_another</span><span class="p">(</span><span class="n">another</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MapArea</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="o">...</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>这之后真正对整个地址空间进行完全复制的是， <code class="language-plaintext highlighter-rouge">MemorySet</code> 中新增的 <code class="language-plaintext highlighter-rouge">from_existed_user</code> 函数。 该函数将生成一个新的 tranmpoline 并遍历当前用户态虚拟地址空间中所有的逻辑段并拷贝这些数据到目标地址空间。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>
  <span class="k">impl</span> <span class="n">MemorySet</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_existed_user</span><span class="p">(</span><span class="n">user_space</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MemorySet</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemorySet</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="o">...</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>可以看到 <code class="language-plaintext highlighter-rouge">TaskControlBlock::fork</code> 的代码和 <code class="language-plaintext highlighter-rouge">new</code> 基本一致， 只是它的数据来源于它的父进程， 子进程的地址空间通过 <code class="language-plaintext highlighter-rouge">MemorySet::from_existed_user</code> 建立。 另外， <code class="language-plaintext highlighter-rouge">sys_fork</code> 的实现中需要更改 <code class="language-plaintext highlighter-rouge">TrapContext</code> 中的 <code class="language-plaintext highlighter-rouge">a0</code> 寄存器， <code class="language-plaintext highlighter-rouge">trap_handler</code> 部分需要配合做出微调， 以保证能够通过返回值区分子进程和父进程。</p>
  </li>
  <li>
    <p><strong>exec</strong></p>

    <p><code class="language-plaintext highlighter-rouge">exec</code> 系统调用是载入一个新的 ELF 的代码和数据替换当前进程的应用地址空间中的内容并执行。 它要做的事情其实和 <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 也很像， 但我们不需要重新生成进程的 PID 以及分配新的 KernelStack， 这些信息原有的进程已经提供了， 仅需要将我们所需要的 <code class="language-plaintext highlighter-rouge">memory_set</code>， <code class="language-plaintext highlighter-rouge">user_sp</code>， <code class="language-plaintext highlighter-rouge">entry_point</code> 这些信息进行更新即可， 之后我们仅需要完善 <code class="language-plaintext highlighter-rouge">sys_exec</code> 系统调用的实现。</p>

    <p>最为关键的还是 <code class="language-plaintext highlighter-rouge">translated_str</code> 这个函数， <code class="language-plaintext highlighter-rouge">sys_exec</code> 需要对输入的 <code class="language-plaintext highlighter-rouge">path</code> 参数进行解析， 这个 <code class="language-plaintext highlighter-rouge">path</code> 的内容来自应用的虚拟地址空间。 因而 <code class="language-plaintext highlighter-rouge">translated_str</code> 就需要在该应用空间中通过查找 Page Table 的方式逐个拷贝字符串信息到当前 kernel 中的 <code class="language-plaintext highlighter-rouge">string</code> 变量中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/page_table.rs</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">translated_str</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">page_table</span> <span class="o">=</span> <span class="nn">PageTable</span><span class="p">::</span><span class="nf">from_token</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">va</span> <span class="o">=</span> <span class="n">ptr</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
      <span class="k">loop</span> <span class="p">{</span>
          <span class="k">let</span> <span class="n">ch</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">page_table</span>
              <span class="nf">.translate_va</span><span class="p">(</span><span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">va</span><span class="p">))</span>
              <span class="nf">.unwrap</span><span class="p">()</span>
              <span class="nf">.get_mut</span><span class="p">());</span>
          <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">string</span><span class="nf">.push</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">char</span><span class="p">);</span>
              <span class="n">va</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">string</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>在 kernel 中获取到了这个应用信息后就能通过 <code class="language-plaintext highlighter-rouge">loader.rs</code> 提供的 <code class="language-plaintext highlighter-rouge">get_app_data_by_name</code> 在指定的内存地址空间加载应用了。</p>
  </li>
  <li>
    <p><strong>read</strong></p>

    <p>最后的 <code class="language-plaintext highlighter-rouge">sys_read</code> 实现还没有涉及到文件系统， 因而需要调用 SBI 提供的接口以获取用户的键盘输入。</p>
  </li>
</ul>

<h3 id="34-进程资源回收机制">3.4 进程资源回收机制</h3>

<p>资源回收涉及到进程的退出， 在此之前 task 中实现此功能的是 <code class="language-plaintext highlighter-rouge">exit_current_and_run_next</code>  函数， 但相比之前的章节， ch5 需要该函数传入一个退出码， 这个退出码会写入到当前进程的进程控制块 TCB 中。 这里比较关键的一步操作是将当前进程的所有子进程的父进程更改为 <code class="language-plaintext highlighter-rouge">INITPROC</code>， 这样当前进程被回收后其子进程仍能被管理而不至于进入一种无法定义的状态。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">exit_current_and_run_next</span><span class="p">(</span><span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// ++++++ access initproc TCB exclusively</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initproc_inner</span> <span class="o">=</span> <span class="n">INITPROC</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">inner</span><span class="py">.children</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">child</span><span class="nf">.inner_exclusive_access</span><span class="p">()</span><span class="py">.parent</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">INITPROC</span><span class="p">));</span>
            <span class="n">initproc_inner</span><span class="py">.children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ++++++ stop exclusively accessing parent PCB</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>父进程的资源回收操作详见 <code class="language-plaintext highlighter-rouge">sys_waitpid</code> 系统调用。</p>

<h2 id="4-修复-syscall">4. 修复 syscall</h2>

<h3 id="41-sys_task_info">4.1 sys_task_info</h3>

<p>该系统调用主要是这几个 <code class="language-plaintext highlighter-rouge">get_*</code> 函数需要对应新的 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 的获取方式， 关键需要注意要用 <code class="language-plaintext highlighter-rouge">current_task</code> 获取当前的进程的 TCB 以免获取进程信息时所有权转移。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">task_info</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
        <span class="n">status</span><span class="p">:</span> <span class="nf">get_current_task_status</span><span class="p">(),</span>
        <span class="n">syscall_times</span><span class="p">:</span> <span class="nf">get_current_task_syscall_times</span><span class="p">(),</span>
        <span class="n">time</span><span class="p">:</span> <span class="nf">get_current_task_time_cost</span><span class="p">(),</span>
    <span class="p">};</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 记录内核态和用户态的进程开销需要用到一个 <code class="language-plaintext highlighter-rouge">checkpoint</code> 记录时刻点， 这个变量也要放入 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code>， 通过 <code class="language-plaintext highlighter-rouge">update_checkpoint</code> 函数更新时刻点并获取时间变化量。 不过在 <code class="language-plaintext highlighter-rouge">TaskControlBlock::fork</code> 函数中的初始化和 <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 有所不同， 前者需要将 <code class="language-plaintext highlighter-rouge">checkpoint</code> 的值通过 <code class="language-plaintext highlighter-rouge">get_time_ms</code> 更新为进程创建的时刻点， 否则新的子进程的计时仍会以 OS 运行的第一个程序为起始时刻点， 这样我们无法通过 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 时间相关的测试。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// record time point</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="cd">/// update checkpoint and return the diff time</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_checkpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">prev_point</span> <span class="o">=</span> <span class="k">self</span><span class="py">.checkpoint</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.checkpoint</span> <span class="o">=</span> <span class="nf">get_time_ms</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">self</span><span class="py">.checkpoint</span> <span class="o">-</span> <span class="n">prev_point</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 修改就是将其放入了子进程， 不做这个更改应该也不影响最终的结果。 另外 <code class="language-plaintext highlighter-rouge">user_time_start</code> 和 <code class="language-plaintext highlighter-rouge">user_time_end</code> 这一对记录用户态时间开销的函数接口和位置都没有变， <code class="language-plaintext highlighter-rouge">update_task_syscall_times</code> 亦是如此。 更新内核时间开销同样只用在 <code class="language-plaintext highlighter-rouge">exit_current_and_run_next</code> 以及 <code class="language-plaintext highlighter-rouge">suspend_current_and_run_next</code> 这两个临界态函数中调用 <code class="language-plaintext highlighter-rouge">update_checkpoint</code> 更新即可。</p>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/e887b13ad109771da03f97c25b2723425cd9b37f">commit#e887b13</a></p>
</blockquote>

<h3 id="42-sys_mmap-与-sys_munmap">4.2 sys_mmap 与 sys_munmap</h3>

<p>这个比较简单， 只用根据 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 变更后对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 的获取方式修改 <code class="language-plaintext highlighter-rouge">get_current_task_page_table</code>， <code class="language-plaintext highlighter-rouge">create_new_map_area</code>， <code class="language-plaintext highlighter-rouge">unmap_consecutive_area</code> 即可。</p>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d8e4b55f2243fe3c5808d23b41a8eccaf28edfe7">commit#d8e4b55</a></p>
</blockquote>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="实现-spawn-系统调用">实现 spawn 系统调用</h4>

<p>这部分实验要求使用 <code class="language-plaintext highlighter-rouge">fork</code> 和 <code class="language-plaintext highlighter-rouge">exec</code>， 但是可以借鉴这二者的写法， <code class="language-plaintext highlighter-rouge">path</code> 部分获取就是模仿 <code class="language-plaintext highlighter-rouge">exec</code> 写的。 实现该系统调用的主要想法是给新的应用数据 <code class="language-plaintext highlighter-rouge">elf_data</code> 建立一个新的进程模块， 这意味着我们需要以 <code class="language-plaintext highlighter-rouge">exec</code> 的角度去改编 <code class="language-plaintext highlighter-rouge">fork</code>。 一直到 <code class="language-plaintext highlighter-rouge">TrapContext</code> 这部分， 前面的内容和 <code class="language-plaintext highlighter-rouge">fork</code> 基本一致， 但是我们需要运行一个新的应用， 因而不能像 <code class="language-plaintext highlighter-rouge">fork</code> 那样沿用与其父进程一致的配置， 而需要创建一个全新的 <code class="language-plaintext highlighter-rouge">TrapContext</code> 以容纳 <code class="language-plaintext highlighter-rouge">entry_point</code>， <code class="language-plaintext highlighter-rouge">user_sp</code>， <code class="language-plaintext highlighter-rouge">kernel_stack_top</code> 这几个依托当前应用数据生成的信息。 最后也是最关键的， 我们需要返回子进程的 pid， 并且将这个子进程的进程控制模块加入到 task 队列中， 以使得操作系统能够分配资源执行该应用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// HINT: fork + exec =/= spawn</span>
<span class="cd">/// ALERT: Don't fork parent process address space</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_spawn</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">parent_inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">parent_inner</span><span class="py">.memory_set</span><span class="nf">.token</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">translated_str</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">elf_data</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_app_data_by_name</span><span class="p">(</span><span class="n">path</span><span class="nf">.as_str</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">memory_set</span><span class="p">,</span> <span class="n">user_sp</span><span class="p">,</span> <span class="n">entry_point</span><span class="p">)</span> <span class="o">=</span> <span class="nn">MemorySet</span><span class="p">::</span><span class="nf">from_elf</span><span class="p">(</span><span class="n">elf_data</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">trap_cx_ppn</span> <span class="o">=</span> <span class="n">memory_set</span>
            <span class="nf">.translate</span><span class="p">(</span><span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">TRAP_CONTEXT_BASE</span><span class="p">)</span><span class="nf">.into</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.ppn</span><span class="p">();</span>
        <span class="c1">// alloc a pid and a kernel stack in kernel space</span>
        <span class="k">let</span> <span class="n">pid_handle</span> <span class="o">=</span> <span class="nf">pid_alloc</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">kernel_stack</span> <span class="o">=</span> <span class="nn">KernelStack</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid_handle</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">kernel_stack_top</span> <span class="o">=</span> <span class="n">kernel_stack</span><span class="nf">.get_top</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task_control_block</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">TaskControlBlock</span> <span class="p">{</span>
            <span class="n">pid</span><span class="p">:</span> <span class="n">pid_handle</span><span class="p">,</span>
            <span class="n">kernel_stack</span><span class="p">,</span>
            <span class="n">inner</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span>
                <span class="nn">UPSafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">TaskControlBlockInner</span> <span class="p">{</span>
                    <span class="n">task_status</span><span class="p">:</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span><span class="p">,</span>
                    <span class="n">task_cx</span><span class="p">:</span> <span class="nn">TaskContext</span><span class="p">::</span><span class="nf">goto_trap_return</span><span class="p">(</span><span class="n">kernel_stack_top</span><span class="p">),</span>
                    <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
                    <span class="n">user_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">kernel_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">checkpoint</span><span class="p">:</span> <span class="nf">get_time_ms</span><span class="p">(),</span> <span class="c1">// give the new process a new start point</span>
                    <span class="n">memory_set</span><span class="p">,</span>
                    <span class="n">trap_cx_ppn</span><span class="p">,</span>
                    <span class="n">base_size</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.base_size</span><span class="p">,</span>
                    <span class="n">heap_bottom</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.heap_bottom</span><span class="p">,</span>
                    <span class="n">program_brk</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.program_brk</span><span class="p">,</span>
                    <span class="n">parent</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="p">)),</span>
                    <span class="n">children</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                    <span class="n">exit_code</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">},</span>
        <span class="p">});</span>
        <span class="c1">// add child</span>
        <span class="n">parent_inner</span><span class="py">.children</span><span class="nf">.push</span><span class="p">(</span><span class="n">task_control_block</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="c1">// prepare TrapContext in user space</span>
        <span class="k">let</span> <span class="n">trap_cx</span> <span class="o">=</span> <span class="n">task_control_block</span><span class="nf">.inner_exclusive_access</span><span class="p">()</span><span class="nf">.get_trap_cx</span><span class="p">();</span>
        <span class="o">*</span><span class="n">trap_cx</span> <span class="o">=</span> <span class="nn">TrapContext</span><span class="p">::</span><span class="nf">app_init_context</span><span class="p">(</span>
            <span class="n">entry_point</span><span class="p">,</span>
            <span class="n">user_sp</span><span class="p">,</span>
            <span class="n">KERNEL_SPACE</span><span class="nf">.exclusive_access</span><span class="p">()</span><span class="nf">.token</span><span class="p">(),</span>
            <span class="n">kernel_stack_top</span><span class="p">,</span>
            <span class="n">trap_handler</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">task_control_block</span><span class="py">.pid</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
        <span class="nf">add_task</span><span class="p">(</span><span class="n">task_control_block</span><span class="p">);</span>
        <span class="n">pid</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/74015ec9fd1e41526fe855d4d9744f59657d9d85">commit#74015ec</a></p>
</blockquote>

<h4 id="stride-调度算法">stride 调度算法</h4>

<p>stride 调度需要存储两个变量， 一个是 <code class="language-plaintext highlighter-rouge">stride</code>， 表示当前的进程已经运行的 “长度”， 这个长度是以 <code class="language-plaintext highlighter-rouge">pass</code> 为单位进行更新的。 那么第二个变量就是 <code class="language-plaintext highlighter-rouge">priority</code>， 表示调度的优先级， 于是有公式成立：</p>

\[pass = BIG\_STRIDE/priority\]

<p>其中 <code class="language-plaintext highlighter-rouge">BIG_STRIDE</code> 被定义为一个预定义的极大常数， 则该调度方案为每个进程分配的时间将与其优先级成正比。 实验中对这些变量还有以下的规约：</p>

<ul>
  <li>stride 调度要求进程优先级 \(\ge{2}\) ，所以设定进程优先级 \(\le{1}\) 会导致错误。</li>
  <li>进程初始 stride 设置为 0。</li>
  <li>进程初始优先级设置为 16。</li>
</ul>

<p>由于 priority \(\ge\) 2， 因而 pass \(\le\) BIG_STRIDE/2， 在不考虑溢出的情况下，  <code class="language-plaintext highlighter-rouge">STRIDE_MAX – STRIDE_MIN ≤ BigStride / 2</code>， 始终成立， 这一点用反证法可以证明。 但现实中必然需要考虑溢出， 那么这里可以利用符号整数的特性， 避免在溢出后某些本应延后调度的进程因为 <code class="language-plaintext highlighter-rouge">stride</code> 值溢出后从小值开始的缘故被优先调度。 所以， 可以将 <code class="language-plaintext highlighter-rouge">BIG_STRIDE</code> 设置为 <code class="language-plaintext highlighter-rouge">u64</code> 类型最大值， 结合 <code class="language-plaintext highlighter-rouge">STRIDE_MAX – STRIDE_MIN ≤ BigStride / 2</code> 亦会有 <code class="language-plaintext highlighter-rouge">STRIDE_MIN – STRIDE_STRIDE &gt;= -BigStride / 2</code>， 这个与 <code class="language-plaintext highlighter-rouge">i64</code> 的表示方式非常相似， 因而可以这样设计 stride 的比较方式：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Stride</span><span class="p">(</span><span class="nb">u64</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">Stride</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">i64</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">i64</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Stride</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我自己尝试了去实现 BinaryHeap 进行调度， 但是程序会卡死在 initproc 中， 作为一个 Rust 新手以及确实很久没接触算法了， 不知道什么地方除了问题， 于是就用了最简单的思路， 在每次 <code class="language-plaintext highlighter-rouge">fetch</code> 下一个 task 之前对这个队列中的 task 做检查， 找到最小的 stride。 这里每次将初始最小值设定为 <code class="language-plaintext highlighter-rouge">0x7FFF_FFFF</code> 是为了解决前述的溢出问题， 本质上利用有符号整数的思想就是把大于 <code class="language-plaintext highlighter-rouge">MAX/2</code> 等价为负数。 这样 TIPs 中说明的 <em>使用 8 bits 存储 stride, BIG_STRIDE = 255, 则: <code class="language-plaintext highlighter-rouge">(125 &lt; 255) == false</code>, <code class="language-plaintext highlighter-rouge">(129 &lt; 255) == true</code></em> 就好理解了。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/manager.rs</span>
<span class="cd">/// A simple FIFO scheduler.</span>
<span class="k">impl</span> <span class="n">TaskManager</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="cd">/// Take a process out of the ready queue</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">min_stride</span> <span class="o">=</span> <span class="mi">0x7FFF_FFFF</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">inner</span><span class="nf">.get_status</span><span class="p">()</span> <span class="o">==</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">inner</span><span class="py">.stride</span> <span class="o">&lt;</span> <span class="n">min_stride</span> <span class="p">{</span>
                    <span class="n">min_stride</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.stride</span><span class="p">;</span>
                    <span class="n">min_index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.get</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
            <span class="n">inner</span><span class="py">.stride</span> <span class="o">+=</span> <span class="n">BIG_STRIDE</span> <span class="o">/</span> <span class="n">inner</span><span class="py">.priority</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.remove</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5abe01a7d69f4f0486888c78acf065e4ee296989">commit#5abe01a</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第五章：进程， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 4</title><link href="https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 4" /><published>2023-07-04T00:00:00+08:00</published><updated>2023-07-04T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/04/rcore-note-ch4</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html"><![CDATA[<p>该章节是目前最复杂的一个章节， 涉及到操作系统的内存管理的策略和方法。 在 <code class="language-plaintext highlighter-rouge">no_std</code> 裸机环境下， rCore 使用 <code class="language-plaintext highlighter-rouge">buddy_system_allocator</code> 为需要动态内存分配的数据结构提供 <code class="language-plaintext highlighter-rouge">Global Allocator</code>。 该章节的主要目的就是实现一个 <strong>地址空间（Address Space）</strong> 抽象， 并在内核中建立虚实地址空间的映射机制， 给应用程序提供一个基于地址空间的安全虚拟内存环境并灵活使用内存。</p>

<p>现代计算机基本使用 <strong>分页内存管理</strong>， 以使得内核始终以一个固定的极小单位管理应用数据， 这既能利用插槽式的简单的内存分配算法避免生成 <strong>内存外碎片</strong>， 又能使未使用的 <strong>内存内碎片</strong> 尽可能小以提高内存的使用率。 关于内存地址映射个人觉得 rCore 讲的比较啰嗦， MIT 的 xv6 的教材很简略但很容易理解可以先阅读 <a href="https://pdos.csail.mit.edu/6.1810/2022/xv6/book-riscv-rev3.pdf">xv6 book - Page tables</a> 建立相关概念再阅读 rCore 的教材。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/addr-space-os-detail.png" alt="Address Space OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Address Space OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第四章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch4">[ch4]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-sv39-多级页表的机制">1. Sv39 多级页表的机制</h2>

<div align="center">
    <a id="translation-details"></a>
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/address-translation.png" alt="RISC-V address translation details, MIT xv6" width="600" />
    <br />
    <font size="2" color="#999"><u>RISC-V address translation details, MIT xv6</u></font>
</div>

<p>rCore 和 xv6 都使用了 Sv39 模式， 这意味着 64-bit 的 <strong>VA (Virtual Address)</strong> 仅有低端的 39 bits 是被使用的。 而这 39 位又被划分为两部分， 被称为 <strong>VPN (Virtual Page Number)</strong> 的高 27 位用于索引 <strong>PTE (Page Table Entry)</strong>， PTE 是存放在每个应用的 Page Table 中， 由 44 位的 <strong>PPN (Physical Page Number)</strong>  与 10 位标志位组成， 这 PTE 实际构成了虚拟地址与物理地址的索引关系。 另外低 12 位是表示页内的偏移量， 这是因为我们使用 <strong>分页内存管理</strong>， 最小的内存单位是 <em>页</em>， 这低 12 位最终会与 PPN 组合成为实际的 56 位物理地址。</p>

<blockquote>
  <p>需要明确的是 \(One Page: 2^{12} = 4096\)， 因而虚拟地址的低 12 位才被称作是页内的偏移量， 因为 12 位正好构成了一个页的大小。</p>
</blockquote>

<p>上图描述了三级页表的查询方式， Sv48 可以使用四级页表， 具体的设计依具体情况而定。 多级页表的构建是为了节省内存开销， 我们只需要按需增添 PTE。 我们可以通过三级页表进行逐级索引， 依据上图由 <em>L2</em> 的 512 个一级页表可以索引， <em>L1</em> 的 \(512\times{512}\) 个二级页表， 这样的开销会比直接映射的页表小得多。 例如我们当前仅需要建立一个地址映射， 那么只需要各使用 <em>L2</em>， <em>L1</em>， <em>L0</em> 三级页表中的一个 PTE， 我们节省了 511 个 <em>L1</em> PTE， \(511\times{512}\) 个 <em>L0</em> PTE。</p>

<p>如果每个地址映射都需要经历三级查表效率肯定会低， 因而 MMU 会提供 <strong>TLB (Translation Look-Aside Buffer)</strong> 缓存来加快映射查询， 但需要注意的是， 映射关系发生改变后缓存就失效了， 我们需要通过 <code class="language-plaintext highlighter-rouge">sfence.vma</code> 指令刷新 TLB。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/page-table.png" alt="Translation process, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Translation process, rCore</u></font>
</div>

<p>在 rCore 中， 虚拟地址 <strong>(VA, Virtual Address)</strong> 中的最小单位被称为 <em>Page</em>， 其对应的物理地址 <strong>(PA, Physical Address)</strong> 中的最小单位被称为 <em>Frame</em>， 这二者的关系可以从上图可以窥见一斑， 二者大小一样都是 4096 Bytes。</p>

<h2 id="2-sv39-分页管理设计">2. Sv39 分页管理设计</h2>

<h3 id="21-frame-allocator---物理页帧管理">2.1 frame allocator - 物理页帧管理</h3>

<p>rCore 中内核直接管理了虚拟内存和物理内存。 <em>Frame</em> 所在的空间位于 <code class="language-plaintext highlighter-rouge">ekernel</code> 与 <code class="language-plaintext highlighter-rouge">MEMORY_END</code> 之间。 rCore 使用 <code class="language-plaintext highlighter-rouge">struct StackFrameAllocator</code> 实现 <strong>FRAME_ALLOCATOR</strong>， 并开放给其他内核模块两个用以分配和回收物理地址 <em>frame</em> 的接口： <code class="language-plaintext highlighter-rouge">frame_alloc</code> 以及 <code class="language-plaintext highlighter-rouge">frame_dealloc</code>。 值得注意的是 <code class="language-plaintext highlighter-rouge">frame_alloc</code> 返回的类型是封装 <code class="language-plaintext highlighter-rouge">PhysPageNum</code> 的 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 类型， 该类型实现了 <code class="language-plaintext highlighter-rouge">Drop</code> Trait， 这是一种 RAII 的思想， 当 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 的声明周期结束， 其包裹的 <code class="language-plaintext highlighter-rouge">PhysPageNum</code> 能通过编译器自动回收到 <code class="language-plaintext highlighter-rouge">FRAME_ALLOCATOR</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/frame_allocator.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FrameTracker</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FrameTracker</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">frame_dealloc</span><span class="p">(</span><span class="k">self</span><span class="py">.ppn</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><b>内核访问物理页帧</b></p>

<p>为了让内核能访问实际的物理地址， rCore 设计了三种粒度的访问方式： 基于 PTE， 基于 Bytes， 基于变量类型。 至此， 物理地址空间的分配以及访问的框架已经建成， 后续需要做的就是构建虚拟地址与物理地址映射的 <strong>页表(Page Table)</strong>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/address.rs</span>

<span class="k">impl</span> <span class="n">PhysPageNum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_pte_array</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="n">PageTableEntry</span><span class="p">];</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_bytes_array</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">];</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="22-page-table---映射表构建">2.2 Page Table - 映射表构建</h3>

<p>构建页表的基本单元就是 <strong>PTE(Page Table Entry)</strong>， 这里有个关键概念需要澄清， 页表的存储位置。 其实从 xv6 的那张 <a href="#translation-details"><em>RISC-V address translation details, MIT xv6</em></a> 也可以看出， 通过索引从 <em>Lx</em> 定位到的 PPN 会指向下一级 Page Table， 这意味着 Page Table 实际上也是存储在具体的物理页帧上的， 并且每个 PTE 对应唯一的一个 PPN。 因而 rCore 对 Page Table 的数据结构的设计就包括了定位 Page Table 的 <code class="language-plaintext highlighter-rouge">root_ppn</code> 以及 Page Table 中包含的各个 PTE 项 <code class="language-plaintext highlighter-rouge">frames</code>。</p>

<blockquote>
  <p>估计是为了让 <code class="language-plaintext highlighter-rouge">root_ppn</code> 和 <code class="language-plaintext highlighter-rouge">frames</code> 的指向和含义统一才把 PTE 命名为 frame， 个人感觉直接用 PTE 会清晰很多。 这里 rCore 又提及 RAII 的思想， <code class="language-plaintext highlighter-rouge">frames</code> 内部变量通过 <code class="language-plaintext highlighter-rouge">Vec</code> 数据结构绑定 <code class="language-plaintext highlighter-rouge">FrameTracker</code>， 可以保证声明周期结束后对 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 的内存自动回收。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="n">root_ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
    <span class="n">frames</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">FrameTracker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就不难理解 <code class="language-plaintext highlighter-rouge">struct PageTable</code> 初始化的流程了， 每个 Page Table 都需要向 frame allocator 先申请一个物理页帧将其 PPN 作为 <code class="language-plaintext highlighter-rouge">root_ppn</code> 唯一标识。</p>

<h3 id="23-建立-va-与-pa-的映射关系">2.3 建立 VA 与 PA 的映射关系</h3>

<p>Page Table 必然是动态变化的， 程序运行的时候会通过 <code class="language-plaintext highlighter-rouge">Page Fault</code> Trap 来实现对内存页的按需分配。 当我们知道虚拟地址空间的某个 VA 的时候， 需要通过前述的 Page Table 找到或建立一个关于物理页帧映射。 Xv6 中是通过 <code class="language-plaintext highlighter-rouge">walk</code> 函数实现的， rCore 提供了两个基础函数 <code class="language-plaintext highlighter-rouge">find_pte_create</code> 以及 <code class="language-plaintext highlighter-rouge">find_pte</code>， 区别就在于是否在某一级页表的 PTE 未创建时创建一个新的 PTE。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/address.rs</span>

<span class="k">impl</span> <span class="n">VirtPageNum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">indexes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">vpn</span> <span class="o">=</span> <span class="k">self</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0usize</span><span class="p">;</span> <span class="mi">3</span><span class="p">];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpn</span> <span class="o">&amp;</span> <span class="mi">511</span><span class="p">;</span>
            <span class="n">vpn</span> <span class="o">&gt;&gt;=</span> <span class="mi">9</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">idx</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">find_pte_create</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">find_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 通过 <code class="language-plaintext highlighter-rouge">indexes</code> 解析 VPN (Virtual Page Number)， 找到三级页表每一级中的 leaf PTE 的索引号。 这里会用到 PTE 中的 Flags 部分的信息。 标志位 <code class="language-plaintext highlighter-rouge">V</code> 表示当前的 PTE 为合法有效的， 在建立新的 PTE 的时候需要更新该标志位， 否则会引起 Page Fault。 基于这几个函数， rCore 封装了两个更便利的函数方便 Page Table 的维护， 用 <code class="language-plaintext highlighter-rouge">map/unmap</code> 为当前的 Page Table 增加或删除 PTE。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">,</span> <span class="n">ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">PTEFlags</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pte</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_pte_create</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">(),</span> <span class="s">"vpn {:?} is mapped before mapping"</span><span class="p">,</span> <span class="n">vpn</span><span class="p">);</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nn">PageTableEntry</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ppn</span><span class="p">,</span> <span class="n">flags</span> <span class="p">|</span> <span class="nn">PTEFlags</span><span class="p">::</span><span class="n">V</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pte</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_pte</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">(),</span> <span class="s">"vpn {:?} is invalid before unmapping"</span><span class="p">,</span> <span class="n">vpn</span><span class="p">);</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nn">PageTableEntry</span><span class="p">::</span><span class="nf">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>手动页表查询</strong>： Page Table 还实现了两个特殊的函数模仿 MMU 获取 Page Table。 <code class="language-plaintext highlighter-rouge">from_token</code> 直接读取 <code class="language-plaintext highlighter-rouge">satp</code> 寄存器中的 PPN 段获取一个 Page Table， 之后就能直接通过 <code class="language-plaintext highlighter-rouge">translate</code> 函数得到 VPN 对应的第三级的 PTE。</p>
</blockquote>

<h2 id="3-地址空间与抽象">3. 地址空间与抽象</h2>

<p>rCore 抽象了两种概念来管理整个虚拟内存及其映射的物理内存。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/addr-space-abstract.png" alt="Address space abstraction, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Address space abstraction, HangX-Ma</u></font>
</div>

<ul>
  <li>
    <p><strong>逻辑段： 一段连续地址的虚拟内存</strong></p>

    <p>rCore 使用 <code class="language-plaintext highlighter-rouge">sruct MapArea</code> 表示逻辑段。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">vpn_range</code> 表明该逻辑段的在虚拟地址的范围以及长度；</li>
      <li><code class="language-plaintext highlighter-rouge">map_type</code> 则表示了虚拟地址和物理地址的映射办法， 直接映射 （<code class="language-plaintext highlighter-rouge">MapType::Identical</code>） 又或是通过 <strong>FRAME_ALLOCATOR</strong> 随机分配物理帧 （<code class="language-plaintext highlighter-rouge">MapType::Framed</code>） （外设地址都是直接映射的， 这样区分有助于后续的应用拓展）；</li>
      <li>既然区分了映射方式， 存储映射关系的数据结构也会不同， <code class="language-plaintext highlighter-rouge">data_frames</code> 用于存储 leaf PTE 的 PPN 与其对应的 VPN 之间的关系， 仅用在 <code class="language-plaintext highlighter-rouge">Framed</code> 映射办法。</li>
      <li>
        <p>最后的 <code class="language-plaintext highlighter-rouge">map_perm</code> 其实就和 Linux 系统的 RWXU 的含义基本接近了。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/memory_set.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">MapArea</span> <span class="p">{</span>
    <span class="n">vpn_range</span><span class="p">:</span> <span class="n">VPNRange</span><span class="p">,</span>
    <span class="n">data_frames</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">VirtPageNum</span><span class="p">,</span> <span class="n">FrameTracker</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">map_type</span><span class="p">:</span> <span class="n">MapType</span><span class="p">,</span>
    <span class="n">map_perm</span><span class="p">:</span> <span class="n">MapPermission</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>地址空间：一系列有关联的逻辑段</strong></p>

    <p>rCore 通过 <code class="language-plaintext highlighter-rouge">struct MemorySet</code> 封装这些逻辑段， 这是因为虽然逻辑段本身是连续的一段虚拟地址， 但多个逻辑段之间可能并不是连续的。 注意这里的 <code class="language-plaintext highlighter-rouge">page_table</code> 是一个 <em>Root Page Table</em>， 包含了该所有的 PTE 的物理页帧， 而 <code class="language-plaintext highlighter-rouge">areas</code> 则包含了数据所在的物理页帧， 这样的的设计构成了一个地址空间所需的所有的物理页帧。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>

  <span class="k">pub</span> <span class="k">struct</span> <span class="n">MemorySet</span> <span class="p">{</span>
      <span class="n">page_table</span><span class="p">:</span> <span class="n">PageTable</span><span class="p">,</span>
      <span class="n">areas</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">MapArea</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="31-内核地址空间">3.1 内核地址空间</h3>

<p>Sv39 规定 64 位虚拟地址的 [63:39] 这 25 位必须和第 38 位相同， 否则 MMU 会直接认定它是一个不合法的虚拟地址。 因而虚拟地址空间可以被划分为低地址的 \(2^{39}\) bytes (512 GB)， 以及当第 38 位为 1 时的 512 GB， 分别称为 <em>High Half</em> 以及 <em>Low Half</em>。 rCore 设计的内核空间如下图所示。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/kernel-as-high.png" alt="Kernel address space high half, rCore" width="400" />
    <br />
    <font size="2" color="#999"><u>Kernel address space high half, rCore</u></font>
</div>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/kernel-as-low.png" alt="Kernel address space low half, rCore" width="300" />
    <br />
    <font size="2" color="#999"><u>Kernel address space low half, rCore</u></font>
</div>

<h3 id="32-应用地址空间">3.2 应用地址空间</h3>

<p>rCore 设计的内核空间如下图所示， 具体含义和解释见 rCore Tutorial 相关章节的内容。 需要注意的是， 几个具有不同访问权限的逻辑段之间需要通过页面对齐进行限制与区分。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/app-as-full.png" alt="Application address space, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Application address space, rCore</u></font>
</div>

<h2 id="4-基于地址空间的分时多任务">4. 基于地址空间的分时多任务</h2>

<h3 id="41-trampoline">4.1 Trampoline</h3>

<p><strong>Trampoline</strong> 部分的代码是由原来的 <code class="language-plaintext highlighter-rouge">trap.S</code> 更改得到的， 其特殊之处在于 Kernel 以及 App 的地址空间的同一位置都有这一段数据， 并且被映射到同一个存放该段代码的物理页帧。 这种设计保证内核态和用户态的虚拟地址空间的切换使用的映射方式相同， 保证这段切换地址空间的指令控制流可以平滑执行。 为方便实现， rCore 直接在多级页表中插入了对 trampoline 的映射而不是新增一个逻辑段。</p>

<p>另外这里提到了虚拟地址空间的切换， 这是 trampoline 命名的由来以及其需要解决的问题。 由于 RISC-V 仅提供了一个 <code class="language-plaintext highlighter-rouge">sscratch</code> 寄存器用以周转数据， 但开启虚拟映射后， 应用地址空间切换到内核应用空间需要用到 <code class="language-plaintext highlighter-rouge">satp</code> 寄存器， 我们无法通过一个寄存器完成 <code class="language-plaintext highlighter-rouge">satp</code> 与 <code class="language-plaintext highlighter-rouge">sp</code> 两个寄存器信息的流转。 因而， 比较合适的办法就是将应用的 <code class="language-plaintext highlighter-rouge">Trap Context</code> 保存在每个应用的用户态虚拟地址空间的 High Half， 紧贴着 Trampoline。</p>

<h3 id="42-改进-syscall">4.2 改进 syscall</h3>

<p>rCore 的手册更改了 <code class="language-plaintext highlighter-rouge">sys_write</code> 系统调用， 通过 <code class="language-plaintext highlighter-rouge">translated_byte_buffer</code> 在内核空间中开辟了一个可以访问应用数据的区域（实际上是将应用数据从用户态虚拟地址空间拷贝到了内核态虚拟地址空间以供内核访问）。 相应的， 前述章节需要访问应用态数据的系统调用均需要通过这种间接的方式进行数据的访问与更改。 这也就是 <code class="language-plaintext highlighter-rouge">sys_get_time</code> 以及 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 在第四章失效的原因。</p>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="重写-sys_get_time-和-sys_task_info">重写 <em>sys_get_time</em> 和 <em>sys_task_info</em></h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_get_time</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TimeVal</span><span class="p">,</span> <span class="n">_tz</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">us</span> <span class="o">=</span> <span class="nf">get_time_us</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">dst_vec</span> <span class="o">=</span> <span class="nf">translated_byte_buffer</span><span class="p">(</span>
        <span class="nf">current_user_token</span><span class="p">(),</span>
        <span class="n">ts</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TimeVal</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">time_val</span> <span class="o">=</span> <span class="n">TimeVal</span> <span class="p">{</span>
            <span class="n">sec</span><span class="p">:</span> <span class="n">us</span> <span class="o">/</span> <span class="mi">1_000_000</span><span class="p">,</span>
            <span class="n">usec</span><span class="p">:</span> <span class="n">us</span> <span class="o">%</span> <span class="mi">1_000_000</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">src_ptr</span> <span class="o">=</span> <span class="n">time_val</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TimeVal</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">in</span> <span class="n">dst_vec</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit_len</span> <span class="o">=</span> <span class="n">dst</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">dst</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="nn">core</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span>
                <span class="n">src_ptr</span><span class="nf">.wrapping_byte_add</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">unit_len</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span>
                <span class="n">unit_len</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dst_vec</span> <span class="o">=</span> <span class="nf">translated_byte_buffer</span><span class="p">(</span>
        <span class="nf">current_user_token</span><span class="p">(),</span>
        <span class="n">ti</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">task_info</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
        <span class="n">status</span><span class="p">:</span> <span class="nf">get_current_task_status</span><span class="p">(),</span>
        <span class="n">syscall_times</span><span class="p">:</span> <span class="nf">get_current_task_syscall_times</span><span class="p">(),</span>
        <span class="n">time</span><span class="p">:</span> <span class="nf">get_current_task_time_cost</span><span class="p">(),</span>
    <span class="p">};</span>
    <span class="c1">// println!("[kernel]: time {} syscall_time {}", task_info.time, task_info.syscall_times[super::SYSCALL_GET_TIME]);</span>
    <span class="k">let</span> <span class="n">src_ptr</span> <span class="o">=</span> <span class="n">task_info</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskInfo</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">in</span> <span class="n">dst_vec</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit_len</span> <span class="o">=</span> <span class="n">dst</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">dst</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="nn">core</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span>
                <span class="n">src_ptr</span><span class="nf">.wrapping_byte_add</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">unit_len</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span>
                <span class="n">unit_len</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/b1ac23ab6103d75398e859fe68df01789950cf0e">commit#b1ac23a</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/db314555940997712b4afba2c19ce41c5c8c26ed">commit#db31455</a></p>
</blockquote>

<h4 id="mmap-和-munmap-匿名映射"><em>mmap</em> 和 <em>munmap</em> 匿名映射</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>

<span class="cd">/// port: page permission [2:0] X|W|R</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_mmap</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span> <span class="cm">/* start need to be page aligned */</span> <span class="p">||</span> 
        <span class="n">port</span> <span class="o">&amp;</span> <span class="o">!</span><span class="mi">0x7</span> <span class="o">!=</span> <span class="mi">0</span> <span class="cm">/* other bits of port needs to be zero */</span> <span class="p">||</span>
        <span class="n">port</span> <span class="o">&amp;</span> <span class="mi">0x7</span> <span class="o">==</span><span class="mi">0</span> <span class="cm">/* No permission set, meaningless */</span> <span class="p">||</span>
        <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span> <span class="cm">/* mapping range should be an legal address */</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// check the range [start, start + len)</span>
    <span class="k">let</span> <span class="n">start_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="nf">.floor</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">end_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">vpns</span> <span class="o">=</span> <span class="nn">VPNRange</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start_vpn</span><span class="p">,</span> <span class="n">end_vpn</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">vpn</span> <span class="k">in</span> <span class="n">vpns</span> <span class="p">{</span>
       <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_current_task_page_table</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// we find a pte that has been mapped</span>
            <span class="k">if</span> <span class="n">pte</span><span class="nf">.is_valid</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// all ptes in range has pass the test</span>
    <span class="nf">create_new_map_area</span><span class="p">(</span>
        <span class="n">start_vpn</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="n">end_vpn</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="nn">MapPermission</span><span class="p">::</span><span class="nf">from_bits_truncate</span><span class="p">((</span><span class="n">port</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">|</span> <span class="nn">MapPermission</span><span class="p">::</span><span class="n">U</span>
    <span class="p">);</span>
    <span class="mi">0</span>
<span class="p">}</span>


<span class="cd">/// munmap the mapped virtual addresses</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_munmap</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span> <span class="p">||</span> <span class="n">start</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// avoid undefined situation</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">MAXVA</span> <span class="o">-</span> <span class="n">len</span> <span class="p">{</span>
        <span class="n">mlen</span> <span class="o">=</span> <span class="n">MAXVA</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">unmap_consecutive_area</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mlen</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>

<span class="c1">//* ch4-lab2, mmap, munmap</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_current_task_page_table</span><span class="p">(</span><span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PageTableEntry</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.translate</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_new_map_area</span><span class="p">(</span><span class="n">start_va</span><span class="p">:</span> <span class="n">VirtAddr</span><span class="p">,</span> <span class="n">end_va</span><span class="p">:</span> <span class="n">VirtAddr</span><span class="p">,</span> <span class="n">perm</span><span class="p">:</span> <span class="n">MapPermission</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.insert_framed_area</span><span class="p">(</span><span class="n">start_va</span><span class="p">,</span> <span class="n">end_va</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">unmap_consecutive_area</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">start_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="nf">.floor</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">end_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">vpns</span> <span class="o">=</span> <span class="nn">VPNRange</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start_vpn</span><span class="p">,</span> <span class="n">end_vpn</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">vpn</span> <span class="k">in</span> <span class="n">vpns</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.translate</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.get_page_table</span><span class="p">()</span><span class="nf">.unmap</span><span class="p">(</span><span class="n">vpn</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Also unmapped if no PTE found</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5e57b472225f7d037535038ba6c037e9566cfeb3">commit#5e57b47</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/165bda860fb29ab4c3af68e308b3f82080825031">commit#165bda8</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第四章：地址空间， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 3</title><link href="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 3" /><published>2023-07-01T00:00:00+08:00</published><updated>2023-07-01T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/01/rcore-note-ch3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html"><![CDATA[<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第三章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch3">[ch3]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>隔了这么就才整到第三章， 毕竟最近杂活儿有点多， 另外第二章的编程题也是安排很不合理， 把后面的内容提前扔给读者结果第三章实验部分要推倒重来太浪费时间了。 更新这章的 OS 框架的时候变动的地方有些多， 尤其是 <code class="language-plaintext highlighter-rouge">Makefile</code> 部分以及 <code class="language-plaintext highlighter-rouge">build.rs</code> 部分和 <em>rCore-Tutorial-Guide-2023S</em> 中进行了同步以及微调。</p>
</blockquote>

<h2 id="1-multi-program-os">1. Multi-program OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/multiprog-os-detail.png" alt="Multi-program OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Multi-program OS Details, rCore</u></font>
</div>

<p>要满足 <strong>任务切换</strong> 的要求， 所以程序需要预先被加载到一个固定的内存地址， 而不是所有程序共用一个入口地址。 rCore 添加了 <code class="language-plaintext highlighter-rouge">user/build.py</code> 读取 <code class="language-plaintext highlighter-rouge">os/src/link_app.S</code> 并对每个程序的地址空间进行更改以适应前述要求。</p>

<p>与 Trap 不同， Mult-program OS 中的任务切换发生在内核态 （S Mode） 且不涉及特权级切换， 通过 <code class="language-plaintext highlighter-rouge">__switch</code> 函数实现两个不同的 <code class="language-plaintext highlighter-rouge">Task Context</code> 的切换。</p>

<blockquote>
  <p><strong>为什么 <code class="language-plaintext highlighter-rouge">__switch</code> 需要通过汇编的完成主要功能？</strong><br />
由于任务切换不涉及特权级的改变， 因而需要保存的上下文就比较少， 仅需要保存 <code class="language-plaintext highlighter-rouge">ra</code> 入口地址， <code class="language-plaintext highlighter-rouge">sp</code> 栈指针， 以及 Callee 负责寄存器 <code class="language-plaintext highlighter-rouge">s0~s11</code> 即可。 高级程序语言会在函数中自己使用一些通用的寄存器， 可能会发生意料之外的控制流， 另外 <code class="language-plaintext highlighter-rouge">__switch</code> 函数仅作为 label 存在不会被 Rust/C 编译器处理， 这些都是使用汇编完成 <code class="language-plaintext highlighter-rouge">__switch</code> 主体功能的原因。</p>
</blockquote>

<h2 id="2-cooperative-os">2. Cooperative OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/more-task-multiprog-os-detail.png" alt="Cooperative OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Cooperative OS Details, rCore</u></font>
</div>

<p>Multi-program OS 仅仅介绍了任务切换中的 <strong>换栈</strong> 需求， 任务切换还需要指示任务的状态， 维护这一信息。 这里我仅记录初始化流程中的几个自己困惑的细节。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">in</span> <span class="n">tasks</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">task</span><span class="py">.task_cx</span> <span class="o">=</span> <span class="nn">TaskContext</span><span class="p">::</span><span class="nf">goto_restore</span><span class="p">(</span><span class="nf">init_app_cx</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">task</span><span class="py">.task_status</span> <span class="o">=</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/task/context.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">goto_restore</span><span class="p">(</span><span class="n">kstack_ptr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">__restore</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">ra</span><span class="p">:</span> <span class="n">__restore</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sp</span><span class="p">:</span> <span class="n">kstack_ptr</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TASK_MANAGER</code> 通过 <code class="language-plaintext highlighter-rouge">init_app_cx</code> 函数初始化了每个 task 的内核栈， 而 <code class="language-plaintext highlighter-rouge">goto_restore</code> 的设计就非常巧妙， 这里并没有进入 <code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 标签处， 而是将任务栈的 <code class="language-plaintext highlighter-rouge">ra</code> 初始化为 <code class="language-plaintext highlighter-rouge">__restore</code> 地址， 这样当 <code class="language-plaintext highlighter-rouge">__switch</code> 完成后 <code class="language-plaintext highlighter-rouge">ret</code> 就能直接进入<code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 恢复到用户态继续执行任务。 相应的其中的 <code class="language-plaintext highlighter-rouge">sp</code> 指针被初始化为内核栈指针。</p>

<blockquote>
  <p><strong>丢失的 <code class="language-plaintext highlighter-rouge">mv sp, a0</code></strong></p>

  <ul>
    <li>
      <p>可以顺着控制流梳理一遍， 第一次用到 <code class="language-plaintext highlighter-rouge">__switch</code> 是初始化时运行 <code class="language-plaintext highlighter-rouge">run_first_task</code> 函数。 <code class="language-plaintext highlighter-rouge">__switch</code> 将 <code class="language-plaintext highlighter-rouge">unused</code> 中的垃圾数据保存在了程序栈后切换到了第一个 task （此后就是内核栈和用户栈之间的切换了）， 通过 <code class="language-plaintext highlighter-rouge">ra</code> 指向的 <code class="language-plaintext highlighter-rouge">__restore</code> 进行上下文恢复， 对于 task 而并不需要再次更新 <code class="language-plaintext highlighter-rouge">sp</code>， 该值已经在 <code class="language-plaintext highlighter-rouge">__switch</code> 中被恢复成该任务对应的内核指针了。</p>
    </li>
    <li>
      <p>另一个就是进入 trap 之后， <code class="language-plaintext highlighter-rouge">__alltrap</code> 最后进入 <code class="language-plaintext highlighter-rouge">trap_handler</code> 函数， 该函数最后会在返回参数的 <code class="language-plaintext highlighter-rouge">a0</code> 中保存之前存入的 <code class="language-plaintext highlighter-rouge">TrapContext</code>， 而在此之前有这么两句指令说明了 <code class="language-plaintext highlighter-rouge">sp</code> 就是这个 <code class="language-plaintext highlighter-rouge">TrapContext</code>。 因而无需再进行重复保存。</p>

      <div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="c1"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span><span class="w">
 </span><span class="n">mv</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w">
 </span><span class="n">call</span><span class="w"> </span><span class="n">trap_handler</span><span class="w">
</span></code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<h2 id="3-timesharing-os">3. Timesharing OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/time-task-multiprog-os-detail.png" alt="Timesharing OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Timesharing OS Details, rCore</u></font>
</div>

<h2 id="4-课后练习">4. 课后练习</h2>

<p>这章的编程题还是有必要提前做一下的， 汲取了上一章的教训这次先看了 lab 部分， 发现 lab 有个要求是记录当前的正在运行的 task 的运行总时长， 这部分时间既包括内核态与用户态两部分的运行时间， 正好编程题包括了。 这部分可以选择性的完成几个基础练习， 难的部分再好好研究一下。</p>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li>
    <p><em><strong>扩展内核， 能够显示操作系统切换任务的过程。</strong></em></p>

    <p>只用在 <code class="language-plaintext highlighter-rouge">os/src/task/mod.rs</code> 的 <code class="language-plaintext highlighter-rouge">run_next_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 加入打印就行， 另外在这里我对任务切换的流程进行了优化， 仅在当前 <code class="language-plaintext highlighter-rouge">current != next</code> 时才进行 <code class="language-plaintext highlighter-rouge">Task Context</code> 交换以及打印相关的信息， 这样能减少内核开销。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/mod.rs</span>
 <span class="k">fn</span> <span class="nf">run_next_task</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_next_task</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">self</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
         <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
         <span class="o">...</span>
         <span class="c1">// ch3-pro1</span>
         <span class="k">if</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">next</span> <span class="p">{</span>
             <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] task switch from {} to {}"</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
             <span class="k">unsafe</span> <span class="p">{</span>
                 <span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">);</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除此之外 <code class="language-plaintext highlighter-rouge">struct TaskManagerInner</code> 中我添加了 <code class="language-plaintext highlighter-rouge">alive_task_num</code> 用以记录仍在 <code class="language-plaintext highlighter-rouge">Ready</code> 以及 <code class="language-plaintext highlighter-rouge">Running</code> 的 task 的数量， 仅在 <code class="language-plaintext highlighter-rouge">alive_task_num &gt; 1</code> 的时候才在 <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中添加打印以保持输出面板整洁以及系统开销最小。</p>

    <blockquote>
      <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/4f1dd08bae3e884a06e2a8141bf0fa4d6909310a">commit#4f1dd08</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/208d86306ee7bba5149fbd38acfb62f6d08e9d84">commit#208d863</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计每个应用执行后的完成时间： 用户态完成时间和内核态完成时间。</strong></em></p>

    <p>lab 相关的重点， <code class="language-plaintext highlighter-rouge">sys_task_info</code> 大部分信息其实都需要 task module 的支持。 另外， 每个 task 都是独立的， 因而需要在 <code class="language-plaintext highlighter-rouge">struct TaskControlBlock</code> 中增加记录 task 运行时间的变量。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
 <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
     <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>之后比较关键的是如何记录这个时间， 这个我在之前 chapter2 实现了类似的函数， 基本思路就是利用 riscv 的 mtime 寄存器， 需要有个特定的变量存储 mtime 寄存器的值并在每次进入该 task 时计算与现在的 mtime 的插值获取时间信息的变更。</p>
    <blockquote>
      <p>lab 中要求时间单位为 ms， 可以使用 <code class="language-plaintext highlighter-rouge">timer.rs</code> 的 <code class="language-plaintext highlighter-rouge">get_time_ms</code> 函数。</p>
    </blockquote>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskManagerInner</span> <span class="p">{</span>
     <span class="cd">/// task list</span>
     <span class="n">tasks</span><span class="p">:</span> <span class="p">[</span><span class="n">TaskControlBlock</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">],</span>
     <span class="cd">/// id of current `Running` task</span>
     <span class="n">current_task</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// the number of tasks that have not exit</span>
     <span class="n">alive_task_num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// record time point</span>
     <span class="n">checkpoint</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <dl>
      <dt>内核态时间</dt>
      <dd>在 <code class="language-plaintext highlighter-rouge">run_first_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中更新信息， 另外需要在 task 退出时打印耗时。</dd>
      <dt>用户态时间</dt>
      <dd>用户态和内核态的分界处就是 trap， 因而在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的起始位置和末尾位置可分别作为 user time 的开始以及 user time 的结束。</dd>
    </dl>

    <blockquote>
      <p>具体实现可以参考课后参考答案部分 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5904c2fcb253a5bfa694ab94e0c7e3006f510238">commit#5904c2f</a>， :sob: <strong>我把 <code class="language-plaintext highlighter-rouge">user_time_start</code> 和 <code class="language-plaintext highlighter-rouge">user_time_end</code></strong> 的位置搞反了， 后续所有的版本都要更改。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>编写浮点应用程序A， 并扩展内核， 支持面向浮点应用的正常切换与抢占。</strong></em></p>

    <p>这块没怎么搞懂， 看起来要加很多东西。</p>
  </li>
  <li>
    <p><em><strong>编写应用程序或扩展内核， 能够统计任务切换的大致开销。</strong></em></p>

    <p>这里的参考答案是有问题的， <code class="language-plaintext highlighter-rouge">__switch</code> 之后会跳转到 <code class="language-plaintext highlighter-rouge">__restore</code> 恢复到用户态，后面那句只有下一次用户态 trap 后才会执行。 虽然不对我还是测试了一下， 发现 context switch 要花费几百毫秒， 这肯定是不可能的。 可行的办法是更改 <code class="language-plaintext highlighter-rouge">goto_restore</code> 函数， 将每个 <code class="language-plaintext highlighter-rouge">__switch</code> 调用的返回地址更改为 <code class="language-plaintext highlighter-rouge">__pre_restore</code> 并在这里插入一个更新 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中的 <code class="language-plaintext highlighter-rouge">switch_time</code> 的值， 这样才能统计不同的 task 的 switch context 开销。</p>

    <ul>
      <li>
        <p>首先需要在 <code class="language-plaintext highlighter-rouge">os/src/task/task.rs</code> 的 <code class="language-plaintext highlighter-rouge">struct TaskControlBlock</code> 中插入统计每个 task 任务切换上下文开销的变量。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/task/task/rs</span>
  <span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
      <span class="k">pub</span> <span class="n">switch_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>更新 <code class="language-plaintext highlighter-rouge">trap.S</code> 并在尾部插入如下代码， 相应的需要更改 <code class="language-plaintext highlighter-rouge">goto_restore</code> 中 <code class="language-plaintext highlighter-rouge">ra</code> 地址为 <code class="language-plaintext highlighter-rouge">__pre_restore</code>。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">__pre_restore</span><span class="p">:</span>
      <span class="n">mv</span> <span class="n">a0</span><span class="p">,</span> <span class="n">sp</span>
      <span class="n">call</span> <span class="n">switch_cost</span>
      <span class="n">mv</span> <span class="n">sp</span><span class="p">,</span> <span class="n">a0</span>
      <span class="n">j</span> <span class="n">__restore</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>context switch 的开销统计的相关函数如下。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/task/mod.rs</span>
  <span class="k">pub</span> <span class="k">static</span> <span class="k">mut</span> <span class="n">SWITCH_TASK_START</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWITCH_TASK_START</span> <span class="o">=</span> <span class="nf">get_time_us</span><span class="p">();</span>
      <span class="nn">switch</span><span class="p">::</span><span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">);</span>
      <span class="c1">// 记录除了第一次运行外的 switch cost</span>
      <span class="k">crate</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">update_switch_cost</span><span class="p">(</span><span class="nf">get_time_us</span><span class="p">()</span> <span class="o">-</span> <span class="n">SWITCH_TASK_START</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_switch_cost</span><span class="p">(</span><span class="n">cost</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
      <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
      <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.switch_time</span> <span class="o">+=</span> <span class="n">cost</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// os/src/trap/mod.rs</span>
  <span class="nd">#[no_mangle]</span>
  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">switch_cost</span> <span class="p">(</span><span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
      <span class="k">crate</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">update_switch_cost</span><span class="p">(</span><span class="nf">get_time_us</span><span class="p">()</span> <span class="o">-</span> <span class="n">SWITCH_TASK_START</span><span class="p">);</span>
      <span class="n">cx</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>

    <blockquote>
      <p>具体的实现和细节可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/4e9425855a85e601fa02070c41da72b5a4f1b7c1">commit#4e9425</a>， 但当时做的时候遗漏了 <code class="language-plaintext highlighter-rouge">__switch</code> 计时函数中的 <code class="language-plaintext highlighter-rouge">crate::task::update_switch_cost(get_time_us() - SWITCH_TASK_START);</code> 导致内核只能记载程序 <strong>switch to not running</strong> 即程序开始第一次运行前的开销。 具体可以参考 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/141#issuecomment-1637146452">Mars</a> 在 rCore 相关章节的留言。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核，支持在内核态响应中断。</strong></em></p>
  </li>
  <li>
    <p><em><strong>扩展内核，支持在内核运行的任务（简称内核任务），并支持内核任务的抢占式切换。</strong></em></p>
  </li>
</ol>

<h3 id="42-实验练习">4.2 实验练习</h3>

<h4 id="获取任务信息">获取任务信息</h4>

<p>做完编程题的第二个就跑来做 lab 了， 事情比我想得要复杂一些。 这里需要声明一下 <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html">rCore-Tutorial-Guide 2023</a> 实验指导书对应的 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2023S">test repo</a> 和当前的 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a> 是有差异的， 如果你和我一样是按照 tutorial 一步步搭起来的 OS 请注意以下这些细节。</p>

<p>Guide 2023S 中提供的接口函数是如下形式， 在具体实现的时候由于 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 中存在一个数组结构， 需要添加 <code class="language-plaintext highlighter-rouge">#[derive(Clone, Copy)]</code>， 如果添加了 <code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 修饰， 后续在 user 目录下的 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 需要保持声明的一致性， 否则 os 部分的 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 将无法正确赋值。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>
<span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span>

<span class="k">struct</span> <span class="n">TaskInfo</span> <span class="p">{</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我最开始设想在 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 外在包裹一个 <code class="language-plaintext highlighter-rouge">TaskInfoWrapper</code>， 并将其声明为如下 case1 形式， 但问题也随之而来， 程序运行会出现 <em><strong>PageFault</strong></em> 错误。 而 case2 这样试图将 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 作为可变量用 <code class="language-plaintext highlighter-rouge">UPSafeCell</code> 保护， 之后再通过 <code class="language-plaintext highlighter-rouge">lazy_static!</code> 宏声明一个 <code class="language-plaintext highlighter-rouge">[TaskInfoWrapper;MAX_APP_NUM]</code> 全局数组变量则会遇到 Copy Trait 未实现的问题。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// case1</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="n">TaskInfo</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// case2</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因而我想现阶段我没办法找到一种合适的办法构造一个全局数组变量去存储每个 task info， 那不如利用现有的资源， 每个 task 都维护了一个 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 变量， 此前的编程题作业在这里面添加了 <code class="language-plaintext highlighter-rouge">kernel_time</code> 以及 <code class="language-plaintext highlighter-rouge">user_time</code>， 不如再增加一个 <code class="language-plaintext highlighter-rouge">syscall_times</code> 数组变量（与所给测例一致）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>剩下的事情就比较简单了， 给 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 提供一个可以获取当前 task 的 <code class="language-plaintext highlighter-rouge">TaskCOntrolBlock</code> 的函数， 以及一个可以在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的 syscall 之前调用的增加 <code class="language-plaintext highlighter-rouge">syscall_times</code> 值的函数就能基本满足题干的要求， 我是这么实现的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_current_task_block</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_task_syscall_times</span><span class="p">(</span><span class="n">syscall_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.syscall_times</span><span class="p">[</span><span class="n">syscall_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/syscall/process.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task_block</span> <span class="o">=</span> <span class="nf">get_current_task_block</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
            <span class="n">status</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.task_status</span><span class="p">,</span>
            <span class="n">syscall_times</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.syscall_times</span><span class="p">,</span>
            <span class="n">time</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.kernel_time</span> <span class="o">+</span> <span class="n">task_block</span><span class="py">.user_time</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d5f55551e5e3428ca7c17026329c2d84fe9bde4f">commit#d5f5555</a>, 但该 commit 中我还对之前的 <code class="language-plaintext highlighter-rouge">sys_write</code> 的 checker 函数进行了更新。</p>
</blockquote>

<p class="error">需要注意 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 需要单独运行测试， 否则 <code class="language-plaintext highlighter-rouge">get_time</code> 函数获取的几个时间点的差值会受到其他程序影响而产生很大偏差。 另外测例中的 <code class="language-plaintext highlighter-rouge">println!</code> 是调用了 flush 函数的， 因而在 rCore 2023S 提供的测试环境中确实会有两次 write 系统调用， 但是按照 tutorial 搭的 OS 现阶段仅有一次 write 系统调用， 若这个测试没通过可以自行修改一下。</p>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第三章：多道程序与分时多任务， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Start from scratch: Neovim for Rust</title><link href="https://hangx-ma.github.io/2023/06/23/neovim-config.html" rel="alternate" type="text/html" title="Start from scratch: Neovim for Rust" /><published>2023-06-23T00:00:00+08:00</published><updated>2023-06-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/23/neovim-config</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/23/neovim-config.html"><![CDATA[<blockquote>
  <p>配置文件可以在 <a href="https://github.com/HangX-Ma/dotfiles/tree/main/nvim">nvim-config</a> repo 下查看， 配完后感觉没有汇编支持不适合 OS 底层开发， 到时候再看看吧， 先用回 vscode。</p>
</blockquote>

<h2 id="0-安装-neovim">0. 安装 Neovim</h2>

<p>使用 <a href="https://github.com/neovim/neovim/releases/tag/stable">Nvim release build</a> 的方式， 省心省力。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/neovim/neovim/releases/download/stable/nvim-linux64.tar.gz
<span class="nb">tar</span> <span class="nt">-xvf</span> nvim-linux64.tar.gz
vim ~/.bashrc
<span class="c"># .bashrc</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/nvim-linux64/bin:<span class="nv">$PATH</span>
<span class="c"># back to cli</span>
<span class="nb">source</span> ~/.bashrc
</code></pre></div></div>

<h2 id="1-vim-选项配置">1. vim 选项配置</h2>

<blockquote>
  <p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门 - 阮一峰</a><br />
<a href="https://www.xwxwgo.com/post/2022/09/21/spell_check_in_nvim/">Neovim拼写检查</a></p>
</blockquote>

<h2 id="2-快捷键配置">2. 快捷键配置</h2>

<p><a href="https://juejin.cn/book/7051157342770954277/section/7051536642238054430">Neovim 配置实战：从0到1打造自己的IDE</a></p>

<h2 id="3-安装-packer-插件管理器">3. 安装 Packer 插件管理器</h2>

<p>参照 Packer 的 repo 的配置内容快速安装 <a href="https://github.com/wbthomason/packer.nvim">packer.nvim</a>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--depth</span> 1 https://github.com/wbthomason/packer.nvim<span class="se">\</span>
 ~/.local/share/nvim/site/pack/packer/start/packer.nvim
</code></pre></div></div>

<p><a href="https://github.com/wbthomason/packer.nvim#bootstrapping">Bootstrapping</a> 这一章节提供了一种便利的方式配置插件， 在导入配置后能自动安装已配置完的插件， 在 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins/plugins.lua</code> 中拷贝这部分代码作为插件配置的基础。 我们创建 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins</code> 文件夹用以管理各个安装的插件。 若需要对插件进行自定义配置， 我们需要创建相关的 lua 文件， 例如 <code class="language-plaintext highlighter-rouge">onedark.lua</code> 之后在 <code class="language-plaintext highlighter-rouge">init.lua</code> 文件中 <code class="language-plaintext highlighter-rouge">require(plugins.onedark)</code> 即可应用相关的配置。</p>

<h2 id="4-插件安装">4. 插件安装</h2>

<h3 id="41-安装-onedark---dark-主题">4.1 安装 OneDark - Dark 主题</h3>

<p>主要参考 <a href="https://github.com/navarasu/onedark.nvim">onedark.nvim</a>， 加入插件后自定义配置即可。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- lua/plugins/plugins.lua</span>
<span class="n">use</span> <span class="s1">'navarasu/onedark.nvim'</span>
</code></pre></div></div>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- plugins/onedark.lua</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="n">setup</span> <span class="p">{</span>
    <span class="c1">-- Main options --</span>
    <span class="n">style</span> <span class="o">=</span> <span class="s1">'dark'</span><span class="p">,</span>
    <span class="n">transparent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">-- Show/hide background</span>
<span class="p">}</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="nb">load</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="42-status-line">4.2 Status Line</h3>

<p>主要参考 <a href="https://github.com/nvim-lualine/lualine.nvim">lualine.nvim</a>， 拷贝 <a href="https://github.com/nvim-lualine/lualine.nvim#default-configuration">default configuration</a> 到 <code class="language-plaintext highlighter-rouge">lua/plugins/lualine.lua</code>， 其余步骤与上述一致。 后续若没有特殊情况就不重复说明相关步骤。</p>

<blockquote>
  <p>值得注意的是， 添加相关的插件后需要在 nvim 中运行 <code class="language-plaintext highlighter-rouge">PackerSync</code> 以安装相关插件， 否则 nvim 会报错。</p>
</blockquote>

<h3 id="43-navigation">4.3 Navigation</h3>

<dl>
  <dt>File Explorer: <a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree.nvim</a></dt>
  <dd>提供了便捷的文件管理树的功能， 所有的文件操作可以通过键盘实现</dd>
  <dt>Tmux Navigator: <a href="https://github.com/christoomey/vim-tmux-navigator">vim-tmux-navigator.nvim</a></dt>
  <dd>tmux (terminal multiplexer) 是一个终端复用器， 主要可以用于分屏和保持会话。 保持会话的意思是， 即使关闭终端窗口， 或者 SSH 由于各种原因连接中断， 在服务器端 tmux 中的会话和对应的进程仍然不会终止。 tmux 能够创建多个会话 （session）， 每个会话能够创建多个窗口 （window）， 每个窗口又可以分为多个窗格 （pane）。</dd>
  <dt>Buffer Line: <a href="https://github.com/akinsho/bufferline.nvim">bufferline.nvim</a></dt>
  <dd>这个插件提供了类似 vscode 的标签页的功能</dd>
  <dt>Outline: <a href="https://github.com/simrat39/symbols-outline.nvim">symbols-outline.nvim</a></dt>
  <dd>类似 vscode 中的 Outline， 基于 LSP 实现的函数与符号树， 方便查看代码实现的整体结构。</dd>
</dl>

<blockquote>
  <p><a href="https://blog.51cto.com/u_11090813/5575032">从零开始配置 vim(13)——标签页插件 - jesssic</a>
<a href="https://blog.51cto.com/u_11090813/5759499">从零开始配置vim(26)——LSP UI 美化 - jesssic</a></p>
</blockquote>

<h3 id="44-highlight">4.4 Highlight</h3>

<dl>
  <dt>Code Highlighting: <a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter.nvim</a></dt>
  <dd>nvim-treesitter 插件提供基于 <a href="https://github.com/tree-sitter/tree-sitter">tree-sitter</a> 的多个基础功能， 它可以让你在 nvim 中高效的实现 <strong>代码高亮， 增量选择</strong> 等功能。</dd>
  <dt>Syntax Highlighting: <a href="https://github.com/p00f/nvim-ts-rainbow">nvim-ts-rainbow</a></dt>
  <dd>该插件依赖于 nvim-treesitter， 允许多种配置策略为不同的文件类型提供高亮支持。</dd>
</dl>

<h3 id="45-terminal">4.5 Terminal</h3>

<dl>
  <dt>Terminal: <a href="https://github.com/akinsho/toggleterm.nvim">toggleterm.nvim</a></dt>
  <dd>虽然用 nvim 默认的指令可以在编辑文档时打开 Terminal， 但是 toggleterm.nvim 提供了更为便捷以及功能更强大的 Terminal 管理方案。</dd>
</dl>

<blockquote>
  <p><a href="https://www.youtube.com/watch?v=5OD-7h7gzxU">Neovim - Toggleterm | Open terminal programs in Neovim - Youtube</a>
<a href="https://blog.51cto.com/u_11090813/5647999">从零开始配置vim(19)——终端配置 - jesssic</a></p>
</blockquote>

<h3 id="46-search">4.6 Search</h3>

<dl>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/popup.nvim">popup.nvim</a></dt>
  <dd>plenary.nvim 的必要组件， 能够提供与 vim <code class="language-plaintext highlighter-rouge">popup_*</code> 兼容的 API 接口。</dd>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/plenary.nvim">plenary.nvim</a></dt>
  <dd>telescope.nvim 的必要组件， 能够提供异步编程， 目录扫描等基础功能。</dd>
  <dt>Fuzzy Finder: <a href="https://github.com/nvim-telescope/telescope.nvim">telescope.nvim</a></dt>
  <dd>telescope.nvim 能在 neovim 中提供文件名模糊搜索和文本内容搜索的功能， 以及更多复杂的功能。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/609527018">Vim/Neovim 全文检索插件 – telescope.nvim - 知乎</a></p>
</blockquote>

<h3 id="47-comment">4.7 Comment</h3>

<dl>
  <dt>Smart Comment: <a href="https://github.com/numToStr/Comment.nvim">Comment.nvim</a></dt>
  <dd>能够方便的对代码进行注释， 这个插件的配置更灵活也更强大。</dd>
</dl>

<h3 id="48-自动补全与内容查看">4.8 自动补全与内容查看</h3>

<h4 id="481-lsp-mason">4.8.1 LSP， Mason</h4>

<dl>
  <dt>Language Server Protocol: <a href="https://github.com/neovim/nvim-lspconfig">nvim-lspconfig</a></dt>
  <dd>Language Server Protocol (LSP) 是微软为开发工具提出的一个协议， 它将编程工具解耦成了Language Server 与 Language Client 两部分。 Client 专注于页面样式实现， Server 负责提供语言支持， 包括常见的自动补全， 跳转到定义， 查找引用， 悬停文档提示等功能。</dd>
  <dt>Portable Package Manager: <a href="https://github.com/williamboman/mason.nvim">mason.nvim</a></dt>
  <dd>mason.nvim 是下一代 nvim-lsp-installer， 能够方便地安装和管理 LSP servers， DAP servers， linters， 以及 formatters.</dd>
  <dt>Packer: <a href="https://github.com/williamboman/mason-lspconfig.nvim">mason-lspconfig.nvim</a></dt>
  <dd>mason-lspconfig.nvim 为 mason.nvim 以及 nvim-lspconfig 建立了桥梁， 方便两个插件的协同工作和配置。</dd>
  <dt>UI: <a href="https://github.com/j-hui/fidget.nvim">fidget.nvim</a></dt>
  <dd>nvim-lsp progress 的独立 UI插件， 将这部分信息显示在窗口右下角为程序员更专注编程提供便利。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/444836713">Neovim 内置 LSP 配置 (一)：基础配置 - 知乎</a></p>
</blockquote>

<h4 id="482-补全与自动提示">4.8.2 补全与自动提示</h4>

<dl>
  <dt>AutoPair: <a href="https://github.com/windwp/nvim-autopairs">nvim-autopairs</a></dt>
  <dd>自动补全括号的插件， 具体作用之后用了补充。</dd>
  <dt>Completion: <a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a></dt>
  <dd>自动补全的引擎， 支持 LSP 以及自定义灵活配置， 我们需要安装如下插件 <code class="language-plaintext highlighter-rouge">neovim/nvim-lspconfig</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-nvim-lsp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-buffer</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-path</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-cmdline</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/nvim-cmp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-vsnip</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/vim-vsnip</code>, <code class="language-plaintext highlighter-rouge">saadparwaiz1/cmp_luasnip</code></dd>
  <dt>Friendly Snippets: <a href="https://github.com/rafamadriz/friendly-snippets">friendly-snippets</a></dt>
  <dd>更够为不同语言提供 Snippets 支持。</dd>
</dl>

<h3 id="49-debug">4.9 Debug</h3>

<dl>
  <dt>Debugger: <a href="https://github.com/puremourning/vimspector">vimspector</a></dt>
  <dd>多语言的带图形界面的调试工具， 看起来挺复杂。</dd>
  <dt>Debug Adapter Protocol: <a href="https://github.com/mfussenegger/nvim-dap">nvim-dap</a></dt>
  <dd>Nvim-dap 是基于 Neovim 的 Debug Adapter Protocol 客户端实现的， 能够进行基本的断点、 步进等操作， 并监视应用的状态。</dd>
</dl>

<h3 id="410-rust-语言支持">4.10 Rust 语言支持</h3>

<dl>
  <dt>Code: <a href="https://rust-analyzer.github.io/">rust-analyzer</a></dt>
  <dd>rust-analyzer 基于 LSP 实现， 它为许多代码编辑器 (包括 VS Code、 Emacs 和 Vim) 提供了补全和跳转定义等特性。</dd>
</dl>

<blockquote>
  <p>nvim 打开后使用 <code class="language-plaintext highlighter-rouge">:Mason</code> 选择 rust-analyzer 按 i 可以便捷安装。</p>
</blockquote>

<dl>
  <dt>Tool: <a href="https://github.com/simrat39/rust-tools.nvim">rust-tools.nvim</a></dt>
  <dd>为 rust 编程提供便利的实用工具。</dd>
</dl>

<h3 id="411-clipboard">4.11 Clipboard</h3>

<dl>
  <dt>Clipboard: <a href="https://github.com/EtiamNullam/deferred-clipboard.nvim/tree/master">deferred-clipboard.nvim</a></dt>
  <dd>打通操作系统与 nvim 之间的桥梁， 二者能共用剪贴板的缓存。</dd>
</dl>

<h3 id="412-git">4.12 Git</h3>

<dl>
  <dt>LazyGit: <a href="https://github.com/kdheepak/lazygit.nvim">lazygit.nvim</a></dt>
  <dd>Git 相关组件， 实现 commit, push 等操作的可视化。</dd>
  <dt>Git Signs: <a href="https://github.com/lewis6991/gitsigns.nvim">gitsigns.nvim</a></dt>
  <dd>提供了和 Git 相关的功能， 例如查看 git diff， last commit， status bar 等， 类似 vscode 中的 GitLen。</dd>
</dl>

<h3 id="413-speed-up">4.13 Speed Up</h3>

<dl>
  <dt>FileType: <a href="https://github.com/nathom/filetype.nvim">filetype.nvim</a></dt>
  <dd>filetype.nvim 是为了替代 nvim 启动时引用的 <code class="language-plaintext highlighter-rouge">filetype.vim</code> 文件， 该文件的目的是创建一系列自动命令， 根据文件名设置 filetype 变量， 但该文件的载入耗费了大量的时间， filetype.nvim 能优化这一载入过程， 对启动过程进行加速。</dd>
  <dt>Lua Loader: <a href="https://github.com/lewis6991/impatient.nvim">impatient.nvim</a></dt>
  <dd>该插件在 neovim 0.9 后就不需要了， 只用开启 <code class="language-plaintext highlighter-rouge">vim.loader.enable()</code> 即可对 lua 模块以及文件的载入进行加速。</dd>
</dl>

<h3 id="414-greeter">4.14 Greeter</h3>

<dl>
  <dt>Greeter: <a href="https://github.com/startup-nvim/startup.nvim">startup.nvim</a></dt>
  <dd>自定义 nvim 启动界面， 能够自己更换喜欢的主题！</dd>
</dl>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/617522665">从零开始：使用Neovim搭建Rust开发IDE - 知乎</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/467428462">我的现代化 NeoVim 配置介绍/教程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="neovim" /><summary type="html"><![CDATA[鉴于NvChard 这类整包的灵活性不高， 以及 vscode 经常抽风的现实情况， 从零开始搭建用于 Rust 编程环境的 Neovim]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 2</title><link href="https://hangx-ma.github.io/2023/06/23/rcore-note-ch2.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 2" /><published>2023-06-23T00:00:00+08:00</published><updated>2023-06-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/23/rcore-note-ch2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/23/rcore-note-ch2.html"><![CDATA[<div align="center">
    <img src="/norobots/images/2023-06-23-rcore-note-ch2/batchos-details.png" alt="Batch OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Batch OS Details, rCore</u></font>
</div>

<p>第二章需要实现实现一个 <code class="language-plaintext highlighter-rouge">邓氏鱼</code> 操作系统， 它能够感知多个应用程序的存在， 并一个接一个地运行这些应用程序， 当一个应用程序执行完毕后， 会启动下一个应用程序， 直到所有的应用程序都执行完毕。</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第二章相关内容的实现可查看 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch2-lab">[ch2-lab]</a> <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch2-pro">[ch2-pro]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-实现应用程序---代码解析与提要">1. 实现应用程序 - 代码解析与提要</h2>

<ol>
  <li>
    <p>根据 <a href="https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html#%E4%BB%8E%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8-rust-%E5%87%BD%E6%95%B0">Rust 程序设计语言</a> 中的描述， 创建一个允许其他语言调用 Rust 函数需要添加 <code class="language-plaintext highlighter-rouge">extern</code> 标识。 另外 <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> 能保证 Rust 函数名不会被编译器处理变得难以阅读与定位， 使其保留原有的名称方便被其他语言指定与链接。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">#[no_mangle]</span>
 <span class="nd">#[link_section</span> <span class="nd">=</span> <span class="s">".text.entry"</span><span class="nd">]</span>
 <span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">_start</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span>
     <span class="nf">clear_bss</span><span class="p">();</span>
     <span class="nf">exit</span><span class="p">(</span><span class="nf">main</span><span class="p">());</span>
     <span class="nd">panic!</span><span class="p">(</span><span class="s">"unreachable after sys_exit!"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><a href="https://marcin.juszkiewicz.com.pl/download/tables/syscalls.html">Linux kernel system calls for all architectures</a> 中可以查阅 RISCV-64 规约的系统函数调用的接口与调用的 ID 号。</p>
  </li>
  <li>
    <p><a href="https://wangchujiang.com/rust-cn-document-for-docker/edition-guide/rust-2018/macros/macro-changes.html">Rust 版本指南</a> 中提及了 macro 的变化， 在 Rust 2015 版本， 当我们要导入外部 crate 的宏， 必须要使用 <code class="language-plaintext highlighter-rouge">#[macro_use]</code> 属性， 最直接的例子是在 <code class="language-plaintext highlighter-rouge">user/src/lang_items.rs</code> 中的 <code class="language-plaintext highlighter-rouge">println</code> 宏的使用， 我们可以通过在 <code class="language-plaintext highlighter-rouge">user/src/lib.rs</code> 在通过 <code class="language-plaintext highlighter-rouge">mod console;</code> 导入 console crate 前使用 <code class="language-plaintext highlighter-rouge">#[macro_use]</code> 就能在 user 被管理的各个 crate 中使用 console 提供的宏了（前提是宏需要用 <code class="language-plaintext highlighter-rouge">#[macro_export]</code> 修饰）。</p>
  </li>
</ol>

<h2 id="2-实现批处理操作系统">2. 实现批处理操作系统</h2>

<h3 id="21-build-构建脚本">2.1 build 构建脚本</h3>

<p><a href="https://course.rs/cargo/reference/build-script/intro.html">Rust语言圣经(Rust Course) - 9.3.10</a> 描述了 rust 中的构建脚本的作用， 一言以蔽之， 构建脚本会在项目被构建之前 Cargo 会编译构建脚本生成可执行文件并执行相应的任务， 其多用于 C 依赖库构建， 或指定依赖库， 以及进行平台的配置等预处理过程。 在 rCore 的项目中， os 项目工程的根目录下的 <code class="language-plaintext highlighter-rouge">build.rs</code> 主要完成的是链接功能性的二进制工具， 静态链接这些测试文件以在后续运行时动态调用。</p>

<p>值得一提的是， Rust 的构建脚本是通过 <code class="language-plaintext highlighter-rouge">println!</code> 宏与 Cargo 进行通信的， 通信内容是以 <code class="language-plaintext highlighter-rouge">cargo:</code> 开头的一系列字符串。 在我们撰写 chapter 2 的 <code class="language-plaintext highlighter-rouge">build.rs</code> 时， 使用 <code class="language-plaintext highlighter-rouge">wrtieln!</code> 宏写入信息需要注意使用 <code class="language-plaintext highlighter-rouge">r#"..."#</code> 取消转义， 以免导致不必要的麻烦。</p>

<blockquote>
  <p><a href="https://course.rs/basic/compound-type/string-slice.html">Rust语言圣经(Rust Course) - 2.4.1</a></p>
</blockquote>

<h3 id="22-批处理模块">2.2 批处理模块</h3>

<p>讲到这个章节的时候对 Rust 的 Crate, Module, Package, <code class="language-plaintext highlighter-rouge">use</code> 这些细节产生了疑问， 之前初学 Rust 走马观花过了一遍书没有实际案例分析， 对相关概念了解不深， <strong>Rust Course</strong> 以及 <strong>Rust学习笔记</strong> 分别用理论以及具体案例讲解和分析了相关内容， 非常的清晰。 在 rCore 的构建中， 对功能模块进行分级归类我觉得很重要， 不能一股脑的使用新的模块导入方式， 既然 Rust 1.3.0 以后提供了新的选择， 就不妨做好取舍。</p>

<blockquote>
  <p><a href="https://course.rs/basic/crate-module/intro.html">Rust语言圣经(Rust Course) - 2.12 包和模块</a><br />
<a href="https://skyao.io/learning-rust/docs/build/module/rust-module-system-explanation.html">对Rust的模块系统的清晰解释 - Rust 学习笔记</a></p>
</blockquote>

<h2 id="3-实现特权级的切换">3 实现特权级的切换</h2>

<h3 id="31-关于-userstack-与-kernelstack">3.1 关于 UserStack 与 KernelStack</h3>

<p>批处理操作系统被设计为运行在内核态特权级（RISC-V 的 S 模式）而应用程序被设计为运行在用户态特权级（RISC-V 的 U 模式）， 在 AEE(Application Execution Environment) 中受到操作系统监管， 执行过程中需要切换特权级。 Context 即上下文需要在特权级切换前后保持不变， 内核态和用户态的上下文信息需要保存在不通的栈中以保证数据的隔离。 rCore 保存上下文信息的栈是这样设计的， <code class="language-plaintext highlighter-rouge">get_sp</code> 返回数组结尾地址， 即栈底位置（栈由上向下生长， 栈底的地址比栈顶高， 除非像当前这样栈为空栈底和栈顶处于同一个地址）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(align(</span><span class="mi">4096</span><span class="nd">))]</span>
<span class="k">struct</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">USER_STACK_SIZE</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">USER_STACK_SIZE</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>未初始化的全局变量和局部静态变量默认值都是 0， 一般来说会将这部分信息存放在 .bss 段并预留未定义的全局变量符号。 这里声明了一个全局静态变量并强制 4096 对齐。 通过 <code class="language-plaintext highlighter-rouge">readelf -t os/target/riscv64gc-unknown-none-elf/release/os</code> 读取编译出的 ELF 文件， <code class="language-plaintext highlighter-rouge">.rodata</code> 段被 4096 对齐了， 更改栈的大小也能确认 <code class="language-plaintext highlighter-rouge">KernelStack</code> 以及 <code class="language-plaintext highlighter-rouge">UserStack</code> 被放在了 <code class="language-plaintext highlighter-rouge">.rodata</code> 中。 初始化为 0 的全局变量和未初始化的全局变量的性质应当一致， 但这里出现了例外。 Rust 中的 static 变量实际声明了一段固定的内存空间且其中的内容不可变， 猜测 Rust 编译器倾向于将只读部分的预留内存保存在 <code class="language-plaintext highlighter-rouge">.rodata</code> 段。</p>

<blockquote>
  <p><a href="https://doc.rust-lang.org/reference/items/static-items.html">The Rust Reference - 6.10 Static items</a><br />
<em>Non-mut static items that contain a type that is not interior mutable may be placed in read-only memory.</em></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>There are 20 section headers, starting at offset 0x187ca0:

Section Headers:
  <span class="o">[</span>Nr] Name
       Type              Address          Offset            Link
       Size              EntSize          Info              Align
       Flags
  <span class="o">[</span> 0]
       NULL             0000000000000000  0000000000000000  0
       0000000000000000 0000000000000000  0                 0
       <span class="o">[</span>0000000000000000]:
  <span class="o">[</span> 1] .text
       PROGBITS         0000000080200000  0000000000001000  0
       00000000000033ce 0000000000000000  0                 4
       <span class="o">[</span>0000000000000006]: ALLOC, EXEC
  <span class="o">[</span> 2] .rodata
       PROGBITS         0000000080204000  0000000000005000  0
       00000000000062d0 0000000000000000  0                 4096
       <span class="o">[</span>0000000000000012]: ALLOC, MERGE
  <span class="o">[</span> 3] .data
       PROGBITS         000000008020b000  000000000000c000  0
       0000000000007430 0000000000000000  0                 8
       <span class="o">[</span>0000000000000003]: WRITE, ALLOC
  <span class="o">[</span> 4] .bss
       NOBITS           0000000080213000  0000000000013430  0
       00000000000100c0 0000000000000000  0                 8
       <span class="o">[</span>0000000000000003]: WRITE, ALLOC
</code></pre></div></div>

<p>最简单的办法就是将 <code class="language-plaintext highlighter-rouge">USER_STACK</code> 以及 <code class="language-plaintext highlighter-rouge">KERNEL_STACK</code> 这两个变量声明为 <code class="language-plaintext highlighter-rouge">static mut</code> 类型， 就能将这两块内存初始化为 <code class="language-plaintext highlighter-rouge">.bss</code> 段。</p>

<blockquote>
  <p><a href="https://course.rs/advance/global-variable.html">Rust语言圣经(Rust Course) - 4.7 全局变量</a></p>
</blockquote>

<h2 id="32-non-stable-rust-abi">3.2 Non Stable Rust ABI</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">KERNEL_STACK</span><span class="p">:</span> <span class="n">KernelStack</span> <span class="o">=</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">KERNEL_STACK_SIZE</span><span class="p">],</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">mut</span> <span class="n">USER_STACK</span><span class="p">:</span> <span class="n">UserStack</span> <span class="o">=</span> <span class="n">UserStack</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">USER_STACK_SIZE</span><span class="p">],</span>
<span class="p">};</span>

<span class="k">impl</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">KERNEL_STACK_SIZE</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cx_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="nf">.get_sp</span><span class="p">()</span> <span class="o">-</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TrapContext</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">cx_ptr</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">cx_ptr</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在此处 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1186485130">issue - whfuyn</a> 提出了两个问题， <code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__alltraps</code> 段在最后调用了 <code class="language-plaintext highlighter-rouge">trap_handler</code> 以处理 <code class="language-plaintext highlighter-rouge">trap</code> 的内容， 但 Rust ABI 是 unstable 的， 我在这篇文章 <a href="https://viruta.org/rust-stable-abi.html">“Rust does not have a stable ABI” - Federico’s Blog</a> 中找到了相应的解释， 虽然对 ABI 的作用还是理解不是很深刻， 但也理解了为什么 <code class="language-plaintext highlighter-rouge">src/context.rs</code> 中的 <code class="language-plaintext highlighter-rouge">TrapContext</code> 会写成下面这种形式。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TrapContext</span> <span class="p">{</span>
    <span class="cd">/// general regs[0..31]</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">32</span><span class="p">],</span>
    <span class="cd">/// CSR sstatus      </span>
    <span class="k">pub</span> <span class="n">sstatus</span><span class="p">:</span> <span class="n">Sstatus</span><span class="p">,</span>
    <span class="cd">/// CSR sepc</span>
    <span class="k">pub</span> <span class="n">sepc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 的声明使得字段的顺序、 大小以及对齐方式与 C 中完全一致。 <code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 结构体使得结构体的对齐量为 <strong>最大对齐量的字段</strong>， 字段的尺寸和偏移量由以下算法决定：</p>

<ol>
  <li>
    <p>把当前偏移量设为从 0 字节开始。</p>
  </li>
  <li>
    <p>对于结构体中的每个字段， 按其声明的先后顺序， 首先确定其尺寸和对齐量； 如果当前偏移量不是对其齐量的整倍数， 则向当前偏移量添加填充字节， 直至其对齐量的倍数1； 至此， 当前字段的偏移量就是当前偏移量； 下一步再根据当前字段的尺寸增加当前偏移量。</p>
  </li>
  <li>
    <p>最后， 整个结构体的尺寸就是当前偏移量向上取整到结构体对齐量的最小整数倍数。</p>
  </li>
</ol>

<blockquote>
  <p><a href="https://nomicon.purewhite.io/other-reprs.html">Rust 秘典（死灵书）- 2.3 可选的数据布局</a><br />
<a href="https://rustwiki.org/zh-CN/reference/type-layout.html">Rust 参考手册 中文版 - 10.3 类型布局</a></p>
</blockquote>

<h3 id="33-static-mut-与-unsafecell">3.3 static mut 与 UnSafeCell</h3>

<p>同样是 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1186485130">issue - whfuyn</a> 提出的问题， 可以看到原来的 <code class="language-plaintext highlighter-rouge">KernelStack</code> 结构体实现了 <code class="language-plaintext highlighter-rouge">fn get_sp</code> 以及 <code class="language-plaintext highlighter-rouge">pub fn push_context</code> 两个函数， 但是这两个函数都使用 <code class="language-plaintext highlighter-rouge">&amp;self</code> 共享不可变引用。 毫无疑问 <code class="language-plaintext highlighter-rouge">self.data</code> 访问了 <code class="language-plaintext highlighter-rouge">KernelStack</code> 的内部量， 并且在 <code class="language-plaintext highlighter-rouge">push_context</code> 中我们将指针的地址强制转换为了一个 <strong>可变裸指针</strong>， 裸指针的解引用是不安全的， 没有借用和声明周期的检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get_sp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="n">KERNEL_STACK_SIZE</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cx_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="nf">.get_sp</span><span class="p">()</span> <span class="o">-</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TrapContext</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">cx_ptr</span> <span class="o">=</span> <span class="n">cx</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">cx_ptr</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>The Rust Reference</strong> 对内部可变性的定义是这样的：</p>

<dl>
  <dt>interior mutability</dt>
  <dd>A type has interior mutability if its internal state can be changed through a shared reference to it.</dd>
</dl>

<p>显然这违反了共享引用（类似 <code class="language-plaintext highlighter-rouge">&amp;self</code>）所指向的值不变的要求。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 是唯一允许的方式达到内部可变性， <code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code> 的内部实现也是通过 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 达到的。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 使用了 <code class="language-plaintext highlighter-rouge">#[lang = "unsafe_cell"]</code> 宏以让编译器对其进行特殊处理， 使其不具备声明周期的 <strong>协/逆变</strong> 特性。 因而我们要实现内部可变性必须通过 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 以避免未定义行为， 我们无法处理生命周期的问题。 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 能够实现从不可变引用到 <strong>可变裸指针</strong> 的安全转换， 我们尽可能多的将安全检查问题交给编译器。</p>

<p>原来的 <code class="language-plaintext highlighter-rouge">batch.rs</code> 使用 <code class="language-plaintext highlighter-rouge">UnSafeCell&lt;T&gt;</code> 后的版本可查看 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/8fbb8e0f506d23ae958414bf085a2580b29e4472">commit#8fbb8e0</a>。</p>

<blockquote>
  <p><a href="https://github.com/rust-lang-nursery/lazy-static.rs/issues/117">(soundness regression) static mut could be avoided. #117 - rust-lang-nursery/lazy-static.rs</a><br />
<a href="https://github.com/rust-lang/rust/issues/53639">Consider deprecation of UB-happy static mut #53639 - rust-lang/rust</a><br />
<a href="https://zhuanlan.zhihu.com/p/598708941">关于 Rust 的 UnsafeCell、Cell 与 RefCell - 知乎</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/miri.html">Rust语言圣经(Rust Course) - 13.6.3 Miri</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/stacked-borrow.html">Rust语言圣经(Rust Course) - 13.6.4 栈借用</a><br />
<a href="https://course.rs/too-many-lists/unsafe-queue/testing-stacked-borrow.html">Rust语言圣经(Rust Course) - 13.6.5 测试栈借用</a><br />
<a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/core/cell/struct.UnsafeCell.html">Struct core::cell::UnsafeCell</a><br />
<a href="https://doc.rust-lang.org/stable/reference/interior-mutability.html">The Rust Reference - 10.4. Interior mutability</a></p>
</blockquote>

<h3 id="34-关于-trap">3.4 关于 trap</h3>

<p>在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 中， 对于 <code class="language-plaintext highlighter-rouge">Exception::UserEnvCall</code> 异常， 有一个更新 <code class="language-plaintext highlighter-rouge">sepc</code> 寄存器信息的指令为 <code class="language-plaintext highlighter-rouge">cx.sepc += 4</code>， 根据 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1573703987">issue</a> 中的一条回答是这样解释的：</p>

<blockquote>
  <p>中断和异常的触发方式不同， 因此硬件设置的“默认执行的下一条指令的地址”也不同。 异常是由于一条指令的执行触发的， 此时硬件默认会将 <code class="language-plaintext highlighter-rouge">sepc</code> 仍然设置为这条指令的地址， 等内核处理完之后再执行一次， 期待这次指令能够正常执行； 而中断是在一条指令执行完毕之后， CPU 检测到了中断， 此时硬件会将 <code class="language-plaintext highlighter-rouge">sepc</code> 设置为下一条指令的地址， 因为没有任何理由再执行一次刚刚执行完的指令。</p>
</blockquote>

<h2 id="4-课后练习">4 课后练习</h2>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li><em><strong>实现一个裸机应用程序 A， 能打印调用栈。</strong></em>
    <div align="center">
     <img src="/norobots/images/2023-06-23-rcore-note-ch2/StackFrame.png" alt="Stack Frame, rCore" width="600" />
     <br />
     <font size="2" color="#999"><u>Stack Frame, rCore</u></font>
 </div>

    <p>根据 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html">第一章 - 为内核支持函数调用</a> 描述的 RISC-V 的栈帧结构， 对第一章的编程题进行更改实现即可， 主要改动还是 <code class="language-plaintext highlighter-rouge">asm</code> 中的内容。 具体可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/blob/main/os/src/stack_btrace.rs">stack_btrace.rs</a>。</p>
  </li>
  <li>
    <p><em><strong>扩展内核， 实现新系统调用 <code class="language-plaintext highlighter-rouge">get_taskinfo</code>， 能显示当前 task 的 id 和 task name； 实现一个裸机应用程序 B， 能访问 <code class="language-plaintext highlighter-rouge">get_taskinfo</code> 系统调用。</strong></em></p>

    <p>这部分真的折磨， 实在是想不到裸机情况下怎么获取 bin 文件的 prefix 名称， 考虑过添加 bin 文件 header 的方式但想想还是奇怪。 主要思路是考虑在 <code class="language-plaintext highlighter-rouge">APP_MANAGER</code> 中就把这部分信息填好， 能力有限不搞了。</p>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计多个应用的执行过程中系统调用编号和访问此系统调用的次数。</strong></em></p>

    <p>这部分第一个想法就是用哈希表， 找了挺久发现一个 <a href="https://crates.io/crates/hashbrown">hashbrown</a> 库是能用在 no_std 环境的。 我实现了 <code class="language-plaintext highlighter-rouge">os/src/syscall/stats.rs</code> 提供了两个函数分别是 <code class="language-plaintext highlighter-rouge">stats_update</code>（放在 trap_handler 的 <code class="language-plaintext highlighter-rouge">UserEnvCall</code> 异常） 以及 <code class="language-plaintext highlighter-rouge">stats_clear_and_print</code>（放在 <code class="language-plaintext highlighter-rouge">run_next_app</code> 之前）。 但是遇到一个问题， 但是当前的 OS 实现下是不能使用 heap 存储 static 变量的信息的， 需要之后再进行测试。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> error: no global memory allocator found but one is required<span class="p">;</span>
 <span class="nb">link </span>to std or add <span class="sb">`</span><span class="c">#[global_allocator]` to a static item that implements the GlobalAlloc trait</span>
</code></pre></div>    </div>

    <blockquote>
      <p><a href="https://juejin.cn/s/rust%20no%20std%20hash_map">rust no std hash_map - 稀土掘金</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计每个应用执行后的完成时间。</strong></em></p>

    <p>原来想用 <a href="https://crates.io/crates/embedded-time">embedded-time</a> 这个库替代标准库中的 time crate， 但是那个 Clock Trait 需要知悉硬件的信息才能实现就放弃了这个想法。 记得在第一章作业的 comment 有人提了一嘴有 time 相关的寄存器， 而且在 qemu 中这个 time 相关的时钟频率是 10 KHz。 所幸 riscv 库提供了这部分寄存器的读写， 只要在 <code class="language-plaintext highlighter-rouge">run_next_app</code> 函数的开始记录程序开始的时刻， 另外就是在异常退出或者 exit 函数调用中的 <code class="language-plaintext highlighter-rouge">run_next_app</code> 函数前获取时间间隔即可。</p>

    <blockquote>
      <p>需要注意 u64 整数溢出以及可能出现的时刻点信息未获取为空的情况， 可以考虑使用 <code class="language-plaintext highlighter-rouge">Option</code>。 具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/ce558ec5c6a6cf1610e8e74e7a5c57fe1b4db6bb">comment#ce558ec</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 统计执行异常的程序的异常情况（主要是各种特权级涉及的异常）， 能够打印异常程序的出错的地址和指令等信息。</strong></em></p>

    <p>编程题的设计好奇怪啊， 各种穿插， 直接仿照参考部分加上一些异常情况的处理， 具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d7f16c747fdd5b5e38bb97a87486f8a80bac9a27">commit#d7f16c7</a>。</p>
  </li>
</ol>

<h3 id="42-实验练习">4.2 实验练习</h3>

<h4 id="421-sys_write-安全检查">4.2.1 sys_write 安全检查</h4>

<p>相关实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch2-lab">ch2-lab</a>， 主要想法就是检查当前传入的 <code class="language-plaintext highlighter-rouge">buf</code> 地址的合法性。</p>

<dl>
  <dt>应用空间合法性</dt>
  <dd>app 经过 <code class="language-plaintext highlighter-rouge">load_app</code> 函数已经加载到了指定的内存空间中， 因而我们需要检查传入的 <code class="language-plaintext highlighter-rouge">buf</code> 指针所处位置是否在 <strong>[APP_BASE_ADDRESS, APP_BASE_ADDRESS + APP_SIZE_LIMIT]</strong> 之间， 即检查应用空间的合法性。</dd>
  <dt>用户栈空间合法性</dt>
  <dd>需要注意的是， 栈是从上往下生长的， 因而获取栈指针之后， 我们需要检查 <code class="language-plaintext highlighter-rouge">buf</code> 可能在用户栈的范围是 <strong>[USER_STACK_PTR_ADDR - USER_STACK_SIZE, USER_STACK_PTR_ADDR]</strong>。</dd>
</dl>

<h4 id="422-问答题">4.2.2 问答题</h4>

<ol>
  <li>
    <p><em>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。请自行测试这些内容 (运行 Rust 三个 bad 测例 ) ，描述程序出错行为，注明你使用的 sbi 及其版本。</em></p>

    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">bad_address.rs</code>， <code class="language-plaintext highlighter-rouge">bad_instruction.rs</code>， <code class="language-plaintext highlighter-rouge">bad_register.rs</code> 运行的结果如下：</p>

      <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SBI及其版本信息： RustSBI version 0.3.0-alpha.4, adapting to RISC-V SBI v1.0.0</span>
<span class="o">[</span>kernel] Loading app_5
<span class="o">[</span>kernel] PageFault <span class="k">in </span>application, kernel killed it.
<span class="o">[</span>kernel] Loading app_6
<span class="o">[</span>kernel] IllegalInstruction <span class="k">in </span>application, kernel killed it.
<span class="o">[</span>kernel] Loading app_7
<span class="o">[</span>kernel] IllegalInstruction <span class="k">in </span>application, kernel killed it.
</code></pre></div>      </div>

      <ul>
        <li><code class="language-plaintext highlighter-rouge">bad_address.rs</code> 出现 <code class="language-plaintext highlighter-rouge">PageFault</code> 是因为非法访问了 0 地址空间并尝试对其进行值写入， 而程序的起始地址是 <code class="language-plaintext highlighter-rouge">0x80400000</code>。</li>
        <li><code class="language-plaintext highlighter-rouge">bad_instruction.rs</code> 以及 <code class="language-plaintext highlighter-rouge">bad_register.rs</code> 分别因为在 U Mode 调用了 <code class="language-plaintext highlighter-rouge">sret</code> S 特权级指令以及访问了 <code class="language-plaintext highlighter-rouge">sstatus</code> S 特权级寄存器而出错。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>请结合用例理解 <a href="https://github.com/rcore-os/rCore-Tutorial-v3/blob/ch2/os/src/trap/trap.S">trap.S</a> 中两个函数 <code class="language-plaintext highlighter-rouge">__alltraps</code> 和 <code class="language-plaintext highlighter-rouge">__restore</code> 的作用，并回答如下几个问题:</em></p>

    <ul>
      <li><em>L40： 刚进入 <code class="language-plaintext highlighter-rouge">__restore</code> 时， <code class="language-plaintext highlighter-rouge">a0</code> 代表了什么值。请指出 <code class="language-plaintext highlighter-rouge">__restore</code> 的两种使用情景。</em>
        <blockquote>
          <p>这个问题我在 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/17#issuecomment-1611036350">chapter2 issues</a> 中有进行回答， 应当为 kernel 的 <code class="language-plaintext highlighter-rouge">sp</code>。</p>

          <ul>
            <li><code class="language-plaintext highlighter-rouge">__restore</code> 可以初始化内核栈以及用户栈指针地址， 进行用户态程序的加载， S Mode =&gt; U Mode；</li>
            <li>除此之外， 可以进行 trap 后的上下文恢复回到用户态。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L46-L51： 这几行汇编代码特殊处理了哪些寄存器？ 这些寄存器的的值对于进入用户态有何意义？ 请分别解释。</em>
        <blockquote>

          <pre><code class="language-asm">ld t0, 32*8(sp)   # 从内核栈中读取 sstatus 值
ld t1, 33*8(sp)   # 从内核栈中读取 spec 值
ld t2, 2*8(sp)    # 从内核栈中读取 sscratch 值
# 以下分别将读取的值写入对应的 CSR 特殊寄存器中
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
</code></pre>

          <ul>
            <li><code class="language-plaintext highlighter-rouge">sstatus</code> 表示程序状态， 其中的 SPP 指明了上一个状态时 U Mode， 可以帮助我们恢复到用户态。</li>
            <li><code class="language-plaintext highlighter-rouge">sepc</code> 其实就是 S Mode 下的 <code class="language-plaintext highlighter-rouge">pc</code>， 可以指定用户态的程序的入口位置。</li>
            <li><code class="language-plaintext highlighter-rouge">sscratch</code> 可以用来交换内核态与用户态的 <code class="language-plaintext highlighter-rouge">sp</code> 寄存器的值。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L53-L59： 为何跳过了 <code class="language-plaintext highlighter-rouge">x2</code> 和 <code class="language-plaintext highlighter-rouge">x4</code>？</em>
        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">sp(x2)</code> 是栈指针， 我们需要使用栈指针来定位缓存在内核栈和用户栈中的寄存器的位置； <code class="language-plaintext highlighter-rouge">tp(x4)</code> 是线程指针寄存器， 对于 uni-processor 而言用不到。</p>
        </blockquote>
      </li>
      <li><em>L63：该指令之后， <code class="language-plaintext highlighter-rouge">sp</code> 和 <code class="language-plaintext highlighter-rouge">sscratch</code> 中的值分别有什么意义？</em>
        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">sp</code> 中存储的是用户栈栈顶的 <code class="language-plaintext highlighter-rouge">sp</code>， <code class="language-plaintext highlighter-rouge">sscratch</code> 中存储的是内核栈栈顶的 <code class="language-plaintext highlighter-rouge">sp</code>。</p>
        </blockquote>
      </li>
      <li><em><code class="language-plaintext highlighter-rouge">__restore</code> 中发生状态切换在哪一条指令？ 为何该指令执行之后会进入用户态？</em>
        <blockquote>
          <p>状态切换发生在 <code class="language-plaintext highlighter-rouge">sret</code> 指令。<code class="language-plaintext highlighter-rouge">csrw sstatus, t0</code> 中将特权级设置为 U， <code class="language-plaintext highlighter-rouge">sstatus</code> 的 <code class="language-plaintext highlighter-rouge">SPP</code> 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息， 可以从多个方面控制 S 特权级的 CPU 行为和执行状态。 在 <code class="language-plaintext highlighter-rouge">sret</code> 执行后硬件会做这两件事：</p>

          <ul>
            <li>CPU 会将当前的特权级按照 <code class="language-plaintext highlighter-rouge">sstatus</code> 的 <code class="language-plaintext highlighter-rouge">SPP</code> 字段设置为 U；</li>
            <li>CPU 会跳转到 <code class="language-plaintext highlighter-rouge">sepc</code> 寄存器指向的那条指令， 然后继续执行。</li>
          </ul>
        </blockquote>
      </li>
      <li><em>L13：该指令之后， <code class="language-plaintext highlighter-rouge">sp</code> 和 <code class="language-plaintext highlighter-rouge">sscratch</code> 中的值分别有什么意义？</em>
        <blockquote>
          <p>与 L63 行为正好相反。</p>
        </blockquote>
      </li>
      <li><em>从 U 态进入 S 态是哪一条指令发生的？</em>
        <blockquote>
          <p>进入 Trap 之前会有 syscall， 而 syscall 的第一句就是 <code class="language-plaintext highlighter-rouge">ecall</code>， 调用完就切换状态了。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><em>对于任何中断， <code class="language-plaintext highlighter-rouge">__alltraps</code> 中都需要保存所有寄存器吗？ 你有没有想到一些加速 <code class="language-plaintext highlighter-rouge">__alltraps</code> 的方法？ 简单描述你的想法。</em></p>

    <blockquote>
      <p>可以仅保存内核态中断服务程序所必须的状态， 包括CPU寄存器、 内核堆栈、 硬件中断等参数。 <a href="https://www.cnblogs.com/mysky007/p/12306407.html">[参考]</a></p>
    </blockquote>
  </li>
</ol>

<h2 id="5-调试记录">5 调试记录</h2>

<h3 id="51-no_std-引入的错误">5.1 <em>no_std</em> 引入的错误</h3>

<p>使用了 <code class="language-plaintext highlighter-rouge">#![no_std]</code> 之后 rust-analyzer 会注释一个 “can’t find crate for <code class="language-plaintext highlighter-rouge">test</code>” 错误， 看着突兀的红色警告很是不爽。 rCore-Tutorial-v3 的 <code class="language-plaintext highlighter-rouge">.vscode/setting.json</code> 通过更改 rust-analyzer 的配置来尝试解决问题， 但是我在尝试 Google 搜索的所有结果后都没有解决问题。 但在 rust 社区我找到了一条帖子 <a href="https://users.rust-lang.org/t/error-e0463-cant-find-crate-for-test/73098">[error[E0463]: can’t find crate for <code class="language-plaintext highlighter-rouge">test</code>]</a>， 确实能消除这类报错并且不会对编译以及输出产生影响。 而我们所要做的更改也非常简单， 只需要在根文件 <code class="language-plaintext highlighter-rouge">main.rs</code> 中加入以下代码即可。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![reexport_test_harness_main</span> <span class="nd">=</span> <span class="s">"test_main"</span><span class="nd">]</span>
<span class="nd">#![feature(custom_test_frameworks)]</span>
<span class="nd">#![test_runner(test_runner)]</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_runner</span><span class="p">(</span><span class="n">_test</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">i32</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="52-在-no_std-环境下增加-test-用例">5.2 在 no_std 环境下增加 test 用例</h3>

<p>挖的坑还是要填的， 知其然知其所以然， 写 chapter2 的编程题的时候就在想可能得用到测试用例测试函数， 不然堆在主干代码中非常难管理。 所幸有人已经在如何实现 <strong>自定义框架测试</strong> 这块进行了研究了， 照着知乎这篇文章按流程分析， 我找到了 <a href="https://github.com/rust-osdev/bootimage">rust-osdev/bootimage</a> 这个库， 它几乎能满足 qemu 创建 test 的所有需求但是目前仅支持 x86 架构， 这意味当前 rCore 使用 test 测试的构想落空了。</p>
<blockquote>
  <p>不枉我耗了一个晚上去找资料， 只能用朴素的办法了。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/main.rs</span>
<span class="nd">#![reexport_test_harness_main</span> <span class="nd">=</span> <span class="s">"test_main"</span><span class="nd">]</span> <span class="c1">// 创建新的 test 的入口函数</span>
<span class="nd">#![feature(custom_test_frameworks)]</span> <span class="c1">// 自定义 test 框架的属性声明</span>
<span class="nd">#![test_runner(test_runner)]</span> <span class="c1">// test 执行函数为 test_runner</span>
<span class="nd">#[no_mangle]</span> <span class="c1">// avoid compiler confusion</span>
<span class="k">fn</span> <span class="nf">rust_main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="nf">test_main</span><span class="p">();</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span> <span class="c1">// 保证该函数仅在 test 情形下生成</span>
<span class="k">fn</span> <span class="nf">test_runner</span><span class="p">(</span><span class="n">tests</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">()])</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Running {} tests"</span><span class="p">,</span> <span class="n">tests</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">for</span> <span class="n">test</span> <span class="k">in</span> <span class="n">tests</span> <span class="p">{</span>
        <span class="nf">test</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://os.phil-opp.com/testing/">Writing an OS in Rust - Testing, Philipp Oppermann’s blog</a><br />
<a href="https://zhuanlan.zhihu.com/p/90758552">使用Rust编写操作系统（四）：内核测试 - 知乎</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第二章：批处理系统， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 1</title><link href="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 1" /><published>2023-06-19T00:00:00+08:00</published><updated>2023-06-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/19/rcore-note-ch1</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/19/rcore-note-ch1.html"><![CDATA[<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第一章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch1">[ch1]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-为内核支持函数调用">1. 为内核支持函数调用</h2>

<h3 id="11-导读问答">1.1 导读问答</h3>

<ul>
  <li>
    <p><em>如何使得函数返回时能够跳转到调用该函数的下一条指令，即使该函数在代码中的多个位置被调用？</em></p>

    <blockquote>
      <p>RISC-V 中 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器 （即 <code class="language-plaintext highlighter-rouge">x1</code> 寄存器） 是用来保存函数的返回地址的， 函数调用时会使用相关的跳转指令 <code class="language-plaintext highlighter-rouge">jal</code> 或者 <code class="language-plaintext highlighter-rouge">jalr</code>， 这两条指令都会在函数调用前将 <code class="language-plaintext highlighter-rouge">pc+4</code> 即下一条指令的地址存入 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器， 一般情况下 <code class="language-plaintext highlighter-rouge">rd</code> 寄存器会选为 <code class="language-plaintext highlighter-rouge">ra</code>。 在函数需要返回时， 只需要通过 <code class="language-plaintext highlighter-rouge">ret</code> 汇编伪指令， 即可使主程序继续在 <code class="language-plaintext highlighter-rouge">ra</code> 保存的物理地址继续执行， 这里 <code class="language-plaintext highlighter-rouge">ret</code> 伪指令会被解析为 <code class="language-plaintext highlighter-rouge">jalr x0, 0(ra)</code>。 但在使用 <code class="language-plaintext highlighter-rouge">ra</code> 寄存器时需要注意函数调用上下文， 保证控制流转移前后特定的寄存器值保持不变。</p>
    </blockquote>
  </li>
  <li>
    <p><em>对于一个函数而言，保证它调用某个子函数之前，以及该子函数返回到它之后（某些）通用寄存器的值保持不变有何意义？</em></p>

    <blockquote>
      <p>这些特定的寄存器分为 <em><strong>Caller-Saved</strong></em> 和 <em><strong>Callee-Saved</strong></em> 两类， 对于编译器而言， 每个函数的编译是独立的， 子函数的寄存器是未知的， 这些寄存器的值的改变可能会影响整个函数的运行。 例如 <code class="language-plaintext highlighter-rouge">ra</code> 在嵌套函数调用中， 若没有保存通用寄存器的值， 可能会因子函数覆盖了 <code class="language-plaintext highlighter-rouge">ra</code> 的值而使得控制流出现混乱。 因而保证这些特定的通用寄存器的值保持不变可以保证 <strong>多层嵌套调用</strong> 的正确， 以及实现对寄存器的复用 （寄存器资源非常珍贵）。</p>
    </blockquote>
  </li>
  <li>
    <p><em>调用者函数和被调用者函数如何合作保证调用子函数前后寄存器内容保持不变？调用者保存和被调用者保存寄存器的保存与恢复各自由谁负责？它们暂时被保存在什么位置？它们于何时被保存和恢复（如函数的开场白/退场白）？</em></p>

    <blockquote>
      <p>需要依据 <strong>Calling Convention</strong> 对各自需要保存的寄存器进行保存， 正如 <strong>Caller-Saved</strong> 和 <strong>Callee-Saved</strong> 二者的字面含义， 调用者保存寄存器就由调用函数保存， 被调用者寄存器则由被调用函数保存， 这些寄存器都被保存在 <strong>栈帧</strong> 上。 一般在被调用函数开始时会保存这些寄存器， 而在被调用函数结束时会恢复寄存器， 这对于 <strong>Caller</strong> 和 <strong>Callee</strong> 而言是一致的。</p>
    </blockquote>
  </li>
  <li>
    <p><em>在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分的？</em></p>

    <blockquote>
      <p>主要还是根据 <strong>调用规范</strong>（Calling Convention）</p>

      <ul>
        <li>a0~a7（<code class="language-plaintext highlighter-rouge">x10~x17</code>）， 用来传递输入参数， 其中的 a0 和 a1 还用来保存返回值。 <strong>调用者保存</strong>。</li>
        <li>t0~t6(<code class="language-plaintext highlighter-rouge">x5~x7</code>, <code class="language-plaintext highlighter-rouge">x28~x31</code>)， 作为临时寄存器使用，在被调函数中可以随意使用无需保存。</li>
        <li>s0~s11(<code class="language-plaintext highlighter-rouge">x8~x9</code>, <code class="language-plaintext highlighter-rouge">x18~x27</code>)， 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 <strong>被调用者保存</strong>。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>sp</em> 和 <em>ra</em> 是调用者还是被调用者保存寄存器，为什么这样约定？</p>

    <blockquote>
      <ul>
        <li>ra(<code class="language-plaintext highlighter-rouge">x1</code>) 是被调用者保存的。 被调用者函数可能也会调用函数， 在调用之前就需要修改 <code class="language-plaintext highlighter-rouge">ra</code> 使得这次调用能正确返回。 因此，每个函数都需要在开头保存 <code class="language-plaintext highlighter-rouge">ra</code> 到自己的栈帧中，并在结尾使用 <code class="language-plaintext highlighter-rouge">ret</code> 返回之前将其恢复。</li>
        <li>sp(<code class="language-plaintext highlighter-rouge">x2</code>) 是被调用者保存的。sp 是栈指针 (Stack Pointer) 寄存器， 它指向下一个将要被存储的栈顶位置。 sp 寄存器和 fp 寄存器构成了当前栈帧的空间范围， 同样的被调用函数也会调用其他函数， 这会更新栈帧， 所以 sp 以及 fp 都约定为被调用者保存寄存器。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><em>如何使用寄存器传递函数调用的参数和返回值？如果寄存器数量不够用了，如何传递函数调用的参数？</em></p>

    <blockquote>
      <p>a0~a7 可用以传递函数参数， 而 a0， a1 则用以保存函数返回值。 若寄存器数量不足， 可以通过栈进行参数传递， 在参数压栈结束后， 可以在 a0 或者 a1 中保存当前 sp 的值 （栈顶位置）， 通过偏移获取栈中保存的参数。</p>
    </blockquote>
  </li>
</ul>

<h3 id="12-程序解释与问题记录">1.2 程序解释与问题记录</h3>

<p>在该章节的评论区讨论最多的是 <code class="language-plaintext highlighter-rouge">extern "C"</code> 以及 <code class="language-plaintext highlighter-rouge">*mut u8</code> 裸指针转换的问题， 下面的代码是更改完善后的。 linker script 中的全局变量定义后， 在 C 语言中可以通过 <code class="language-plaintext highlighter-rouge">extern int x</code> 这种形式导入， 这在 rust 中也是可以通过类似的方式实现的， 可以参考 <a href="https://github.com/rustsbi/rustsbi-qemu/blob/main/rustsbi-qemu/src/main.rs#L70">rustsbi</a> 中的方式。 另外， 根据 <em>Rust 程序设计语言</em> 中的 <em>19.1不安全的 Rust: 解引用裸指针</em> 中的 <a href="https://kaisery.github.io/trpl-zh-cn/ch19-01-unsafe-rust.html#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88">描述</a> <code class="language-plaintext highlighter-rouge">(ptr as *mut u8)</code> 实际是将 <code class="language-plaintext highlighter-rouge">ptr</code> 所指向的 64 位地址转为 <code class="language-plaintext highlighter-rouge">u8</code> 类型的可变指针， <code class="language-plaintext highlighter-rouge">ptr.write_volatile(0)</code> 方法将 0 写入指针类型 <code class="language-plaintext highlighter-rouge">ptr</code> 存储的地址所指向的 1 字节内存区域。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">clear_bss</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">sbss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">mut</span> <span class="n">ebss</span><span class="p">:</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">sbss</span> <span class="k">as</span> <span class="nb">usize</span><span class="o">..</span><span class="n">ebss</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">ptr</span><span class="p">|{</span>
                <span class="c1">// use volatile to avoid compiler optimization</span>
                <span class="p">(</span><span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span><span class="nf">.write_volatile</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="error">但是这种 <code class="language-plaintext highlighter-rouge">static mut var: u64</code> 的实现办法后来在调用 <code class="language-plaintext highlighter-rouge">info!</code> 这类 log 打印的时候出现了问题， 提示找不到 <code class="language-plaintext highlighter-rouge">ebss</code> 所在位置， 或者有几个全局变量的值无法正确读取， 但 <code class="language-plaintext highlighter-rouge">恢复成 fn ebss()</code> 就可以了。</p>

<p>另外关于栈中在 linker script 中被置于 <code class="language-plaintext highlighter-rouge">.bss</code> 段也有讨论， 在 <em>程序员的修养——链接、装载与库</em> 中就有提及</p>

<div style="font-weight: bold; font-style: italic;">
<p>
“链接器为目标文件分配地址和空间” 这句话中的 “地址和空间” 其实有两个含义：第一个是在输出的可执行文件中的空间；第二个是在装载后的虚拟地址中的虚拟地址空间。
</p>
</div>

<p>对于 <code class="language-plaintext highlighter-rouge">.bss</code> 这样的段来说， 分配空间的意义只局限于虚拟地址空间， 因为它在文件中并没有内容。 对于栈的初始化而言， 将其置于 <code class="language-plaintext highlighter-rouge">.bss</code> 段可避免其占用实际的 ELF 文件的空间， 但在后续加载内核内核后， 该部分栈会被分配到 VMA 中占据一定的虚拟内存空间。</p>

<h2 id="2-rustsbi">2. RustSBI</h2>

<p>SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用 Rust 语言实现的 SBI。 RustSBI 的功能和 u-boot(SPL) 很类似但相较而言简单很多， 只需要在 boot 阶段为上层应用完成初始化工作后转移控制权给内核。 但是， RustSBI 又直接构成了内核和硬件沟通的桥梁， 为操作系统提供一系列二进制接口，以便其获取和操作硬件信息， RustSBI 能在内核运行时响应内核的请求为内核提供服务。</p>

<p>Western Digital 在 2019 年 12 月的一份 <a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf"><em>An Introduction to RISC-V Boot Flow</em></a> 报告中有这么一幅流程图阐述了 RISC-V 的 boot 流程。</p>

<div align="center">
    <img src="/norobots/images/2023-06-19-rcore-note-ch1/riscv-upstream-boot-flow.png" alt="RISC-V Upstream Boot Flow, Western Digital" width="800" />
    <br />
    <font size="2" color="#999"><u>RISC-V Upstream Boot Flow, Western Digital</u></font>
</div>

<p>这里引用 <a href="https://github.com/denglj">dengji</a> 在附录 C 评论中对 boot 流程以及对 RISV-V SBI 的解释：</p>

<ul>
  <li><strong>Loader</strong> 要干的事情，就是内存初始化， 以及加载 Runtime 和 BootLoader 程序。 而Loader自己也是一段程序，常见的Loader就包括 BIOS/UEFI， 后者是前者的继任者。</li>
  <li><strong>Runtime</strong> 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，为 OS 提供服务，当我们要在同一套硬件系统中运行不同的操作系统， 或者做硬件级别的虚拟化时， 就离不开Runtime 服务的支持。 SBI 就是 RISC-V 架构的 Runtime 规范。</li>
  <li><strong>BootLoader</strong> 要干的事情包括文件系统引导、 网卡引导、 操作系统启动配置项设置、 操作系统加载等等。常见的 BootLoader 包括 GRUB，U-Boot，LinuxBoot 等。</li>
  <li>而 <strong>BIOS/UEFI</strong> 的大多数实现， 都是 Loader、 Runtime、 BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。 如果把 BIOS 当做一个泛化的术语使用， 而不是指某个具体实现的话， 那么可以认为 SBI 是 BIOS 的组成部分之一。</li>
</ul>

<blockquote>
  <p><a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">An Introduction to RISC-V Boot Flow</a><br />
<a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/appendix-c/index.html">附录 C：深入机器模式：RustSBI</a></p>
</blockquote>

<h2 id="3-print-与-println-宏">3. print 与 println 宏</h2>

<p>借机复习一下 macro， 被 <a href="https://dtolnay.github.io/rust-quiz/1">rust-quiz</a> 痛打的经历历历在目。 宏主要分为 <code class="language-plaintext highlighter-rouge">macro_rules!</code> 这样的声明宏以及 <code class="language-plaintext highlighter-rouge">procedural</code> 过程宏。 在一个文件中调用宏之前必须定义它， 或者将其引入作用域之中。 实现 <code class="language-plaintext highlighter-rouge">print!</code> 宏以及 <code class="language-plaintext highlighter-rouge">println!</code> 宏需要 <code class="language-plaintext highlighter-rouge">#[macro_export]</code> 注解表明引入改宏到作用域之中。 以 <code class="language-plaintext highlighter-rouge">print!</code> 宏为例， 由内向外展开分析， 需要记住 <a href="https://veykril.github.io/tlborm/decl-macros/macros-methodical.html#metavariables">2.1 A Methodical Introduction</a> 中 Repetition 原则， <code class="language-plaintext highlighter-rouge">$ (...) sep rep</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">print</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$fmt</span><span class="p">:</span> <span class="n">literal</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">:</span> <span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="nn">console</span><span class="p">::</span><span class="nf">print</span><span class="p">(</span><span class="nd">format_args!</span><span class="p">(</span><span class="nv">$fmt</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">println</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$fmt</span><span class="p">:</span> <span class="n">literal</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">:</span> <span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="nn">console</span><span class="p">::</span><span class="nf">print</span><span class="p">(</span><span class="nd">format_args!</span><span class="p">(</span><span class="nd">concat!</span><span class="p">(</span><span class="nv">$fmt</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="nv">$</span><span class="p">(,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$arg</span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="o">?</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">, $($arg: tt)+</code> 该部分会匹配由 <code class="language-plaintext highlighter-rouge">,</code> 分隔的一段重复序列， <code class="language-plaintext highlighter-rouge">+</code> 表示改重复部分至少出现一次， 重复的内容是 token tree， 它将被捕获存放在元变量 <code class="language-plaintext highlighter-rouge">arg</code> 中。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$($fmt: literal $(...)?)</code> 该部分有 <code class="language-plaintext highlighter-rouge">literal</code> fragment-specifier， 根据 <a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">The Rust Reference - 8.2.1. Literal expression</a> 中的描述， <em>literal expression</em> 是主要在编译阶段分析的常量表达式， 由单个 token 构成， 一般而言 <strong>CHAR， STRING， RAW STRING， BYTE， BYTE STRING， RAW BYTE STRING， INTEGER， FLOAT， BOOL</strong> 均为 literal 类型。 根据 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference - 3.1 Macros By Example</a> 中的描述， 在 MacroMatch <code class="language-plaintext highlighter-rouge">() =&gt; {}</code> 中应当由两组匹配模式， 一组是 <code class="language-plaintext highlighter-rouge">$fmt: literal</code> 对应 <code class="language-plaintext highlighter-rouge">$ ( IDENTIFIER_OR_KEYWORD except crate | RAW_IDENTIFIER | _ ) : MacroFragSpec</code>， 另一组就是 <code class="language-plaintext highlighter-rouge">$(, $($arg: tt)+)?</code>， 对应 <code class="language-plaintext highlighter-rouge">$ ( MacroMatch+ ) MacroRepSep? MacroRepOp</code>。</p>
  </li>
  <li>
    <p>Matcher 的右侧就是 MacroTranscriber， 可以看到我们使用了外部函数 <code class="language-plaintext highlighter-rouge">print</code>， 并用 <code class="language-plaintext highlighter-rouge">format_args!</code> 宏将 <code class="language-plaintext highlighter-rouge">$fmt $(, $($arg)+)?</code> 组装成完整的字符串， 这类似 C/C++ 中的 <code class="language-plaintext highlighter-rouge">sprintf</code>。 另外在 <code class="language-plaintext highlighter-rouge">println!</code> 中使用的 <code class="language-plaintext highlighter-rouge">concat!</code> 宏将多个字符串连接在一起。</p>
  </li>
</ul>

<blockquote>
  <p><a href="https://rustwiki.org/zh-CN/std/macro.format_args.html">rustwiki - Macro std::format_args</a><br />
<a href="https://doc.rust-lang.org/std/macro.concat.html">rust-lang doc - Macro std::concat</a><br />
<a href="https://doc.rust-lang.org/reference/index.html">The Rust Reference</a><br />
<a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a><br />
<a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html">Rust 程序设计语言 - 19.5 宏</a></p>
</blockquote>

<h2 id="4-课后练习">4. 课后练习</h2>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li>
    <p><em>实现一个linux应用程序A，显示当前目录下的文件名。（用C或Rust编程）</em></p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">process</span><span class="p">::</span><span class="n">Command</span><span class="p">};</span>
 <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"ls"</span><span class="p">)</span><span class="nf">.arg</span><span class="p">(</span><span class="s">"-a"</span><span class="p">)</span><span class="nf">.output</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"failed to execute the process"</span><span class="p">);</span>
     <span class="k">let</span> <span class="n">file_list</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8</span><span class="p">(</span><span class="n">output</span><span class="py">.stdout</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">file_list</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>实现一个linux应用程序B，能打印出调用栈链信息。（用C或Rust编程）</em></p>

    <div align="center">
     <img src="/norobots/images/2023-06-19-rcore-note-ch1/StackFrame.png" alt="Stack Frame, x86" width="400" />
     <br />
     <font size="2" color="#999"><u>Stack Frame, x86</u></font>
 </div>

    <p>根据文档描述， 栈帧存储着函数之间的调用信息， 当前栈帧的头部是 <em>sp(x1)</em> 指向的位置， 尾部是 <em>fp(s0)</em> 指向的位置。 其中 <code class="language-plaintext highlighter-rouge">fp</code> 寄存器中保存了父栈帧的结束地址， x86 架构的结构与 RISC-V 有所不同， <code class="language-plaintext highlighter-rouge">rbp</code> 存储的内容就是父栈帧的 <code class="language-plaintext highlighter-rouge">rbp</code> 地址。 另外， 在调试过程中发现有 <code class="language-plaintext highlighter-rouge">stack overflow</code> 的错误， 参考给出解释需要用到 <code class="language-plaintext highlighter-rouge">libunwind</code> 库解决标准库不存储栈帧指针的问题， 遂仅进行有限个栈帧回溯。 注意需要开启 <code class="language-plaintext highlighter-rouge">force-frame-pointers</code> 编译选项。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">arch</span><span class="p">::</span><span class="n">asm</span><span class="p">;</span>

 <span class="k">fn</span> <span class="nf">print_stack_trace_chain</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">let</span> <span class="n">fp</span><span class="p">:</span> <span class="nb">usize</span><span class="p">;</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"== STACK TRACE BEGIN"</span><span class="p">);</span>
     <span class="k">unsafe</span> <span class="p">{</span>
         <span class="nd">asm!</span> <span class="p">(</span>
             <span class="s">"mov {fp}, rbp"</span><span class="p">,</span>
             <span class="n">fp</span> <span class="o">=</span> <span class="nf">out</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="n">fp</span><span class="p">,</span>
         <span class="p">);</span>
     <span class="p">}</span>

     <span class="k">let</span> <span class="k">mut</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
     <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
         <span class="nd">println!</span><span class="p">(</span><span class="s">" == {:#p}"</span><span class="p">,</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">);</span>
         <span class="n">fp</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
             <span class="p">(</span><span class="n">fp</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">)</span><span class="nf">.offset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.read</span><span class="p">()</span>
         <span class="p">};</span>
     <span class="p">}</span>
     <span class="nd">println!</span><span class="p">(</span><span class="s">"== STACK TRACE END"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>实现一个基于rcore/ucore tutorial的应用程序C，用sleep系统调用睡眠5秒（in rcore/ucore tutorial v3: Branch ch1）</em></p>

    <p>折腾半天读不到 MIE， SIP 寄存器的值， 暂时搁置了。</p>

    <blockquote>
      <p><a href="https://siriusdemon.github.io/Rare/v3-CSR.html">Rare: Rust A Riscv Emulator</a><br />
<a href="https://dingfen.github.io/risc-v/2020/08/05/riscv-privileged.html">RISC-V 特权架构</a></p>
    </blockquote>
  </li>
</ol>

<h3 id="42-问答题">4.2 问答题</h3>

<ol>
  <li>
    <p><em>应用程序在执行过程中， 会占用哪些计算机资源？</em></p>

    <blockquote>
      <p>CPU/GPU 计算资源， 内存/外存资源， 缓存资源等。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请用相关工具软件分析并给出应用程序A的代码段/数据段/堆/栈的地址空间范围。</em></p>

    <blockquote>
      <p>使用 <code class="language-plaintext highlighter-rouge">readelf -S pro1</code> 查看 section headers 信息， 我的程序的代码段地址空间为 [0x7080, 0x4ef04]， 数据段地址空间范围是 [0x65000, 0x65038] 这里有做地址对齐。 另外， 堆/栈的信息是动态分配的， 根据参考中的说明， 需要在后台查看 <code class="language-plaintext highlighter-rouge">/proc/[pid]/maps</code>。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请简要说明应用程序与操作系统的异同之处。</em></p>

    <blockquote>
      <p>应用程序和操作系统其实都可以被称作一种系统程序， 不同的是二者对于硬件的支配能力。 操作系统和硬件直接相关， 能够独立地运行在硬件设备上并对硬件以及外设进行控制， 它为上层的应用程序提供了服务与接口， 从这点可以看出， 应用程序对硬件的管理是间接的， 它需要向操作系统请求各种服务与功能， 这也是操作系统的隔离性与安全性要求。 另外， 应用程序一般默认被认定为恶意的， 反之操作系统是值得信任的。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请基于 QEMU 模拟 RISC—V 的执行过程和 QEMU 源代码， 说明 RISC-V 硬件加电后的几条指令在哪里？ 完成了哪些功能？</em></p>

    <blockquote>
      <p>对 QEMU 的执行流程不是太了解， 但按照前述的 boot flow， 第一阶段肯定是模拟 ROM 中的指令进行初始化， 在 <code class="language-plaintext highlighter-rouge">qemu7.0.0/hw/riscv/boot.c</code> 中可以找到 <code class="language-plaintext highlighter-rouge">riscv_setup_rom_reset_vec</code>， 相当于 ROM 的初始化设置， 具体的配置内容如 <code class="language-plaintext highlighter-rouge">reset_vec</code> 所示。</p>
    </blockquote>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/* reset vector */</span>
  <span class="kt">uint32_t</span> <span class="n">reset_vec</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mh">0x00000297</span><span class="p">,</span>                  <span class="cm">/* 1:  auipc  t0, %pcrel_hi(fw_dyn) */</span>
      <span class="mh">0x02828613</span><span class="p">,</span>                  <span class="cm">/*     addi   a2, t0, %pcrel_lo(1b) */</span>
      <span class="mh">0xf1402573</span><span class="p">,</span>                  <span class="cm">/*     csrr   a0, mhartid  */</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="mh">0x00028067</span><span class="p">,</span>                  <span class="cm">/*     jr     t0 */</span>
      <span class="n">start_addr</span><span class="p">,</span>                  <span class="cm">/* start: .dword */</span>
      <span class="n">start_addr_hi32</span><span class="p">,</span>
      <span class="n">fdt_load_addr</span><span class="p">,</span>               <span class="cm">/* fdt_laddr: .dword */</span>
      <span class="n">fdt_load_addr_hi32</span><span class="p">,</span>
                                   <span class="cm">/* fw_dyn: */</span>
  <span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">riscv_is_32bit</span><span class="p">(</span><span class="n">harts</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0202a583</span><span class="p">;</span>   <span class="cm">/*     lw     a1, 32(t0) */</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0182a283</span><span class="p">;</span>   <span class="cm">/*     lw     t0, 24(t0) */</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0202b583</span><span class="p">;</span>   <span class="cm">/*     ld     a1, 32(t0) */</span>
      <span class="n">reset_vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0182b283</span><span class="p">;</span>   <span class="cm">/*     ld     t0, 24(t0) */</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p>AUIPC (add upper immediate to pc)， 其作用是计算 PC 的相对地址并将结果存储在 rd 中。 根据 <a href="https://sourceware.org/binutils/docs/as/RISC_002dV_002dModifiers.html">9.38.3 RISC-V Assembler Modifiers</a> 中的描述， <code class="language-plaintext highlighter-rouge">%pcrel_hi</code> 以及 <code class="language-plaintext highlighter-rouge">%pcrel_lo</code> 的定义为：</p>

      <dl>
        <dt>%pcrel_hi(symbol)</dt>
        <dd>The high 20 bits of relative address between pc and symbol.</dd>
        <dt>%pcrel_lo(label)</dt>
        <dd>The low 12 bits of relative address between pc and symbol.</dd>
      </dl>

      <p>另外需要注意的是 <code class="language-plaintext highlighter-rouge">1b</code> 实际上是 RISC-V 汇编 Label 的一种写法， 拆开来是 <strong>1</strong> <strong>backward</strong>， 表示在 <strong>1</strong> 这个标签值之后的标签。 同样道理可能会出现 <code class="language-plaintext highlighter-rouge">1f</code>， 意思就正好相反表示在 <strong>1</strong> 这个标签之前。 也就是前两句实际是处理 Code Independent 设计的获取 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 的地址。</p>

      <dl>
        <dt>mhartid</dt>
        <dd>Hart ID Register (mhartid), 运行当前代码的硬件线程 （hart） 的 ID。</dd>
      </dl>

      <p>因而在获取 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 的地址后， 会将当前代码硬件线程的 ID 存储到 <code class="language-plaintext highlighter-rouge">a0</code> 寄存器中。 另外在跳转到 <code class="language-plaintext highlighter-rouge">fw_dyn</code> 地址后， 由于我们的系统是 RISCV64， 因而 <code class="language-plaintext highlighter-rouge">ld a1, 32(t0)</code> 会将 <code class="language-plaintext highlighter-rouge">fdt_load_addr</code> 即 Flatten Device Tree 的地址写入 <code class="language-plaintext highlighter-rouge">a1</code> 之后更新 <code class="language-plaintext highlighter-rouge">t0</code> 为 <code class="language-plaintext highlighter-rouge">start_addr</code> 后适用 <code class="language-plaintext highlighter-rouge">jr t0</code> 指令跳转到 <code class="language-plaintext highlighter-rouge">start</code> 也就是程序的入口地址处。</p>
    </blockquote>

    <p><a href="https://stackoverflow.com/questions/73945372/question-aboutpcrel-hi-and-pcrel-lo-for-qemu-virt-machine">[Question about%pcrel_hi and %pcrel_lo for qemu virt machine] - StackOverflow</a><br />
 <a href="https://stackoverflow.com/questions/65879012/what-do-pcrel-hi-and-pcrel-lo-actually-do">[What do %pcrel_hi and %pcrel_lo actually do?] - StackOverflow</a></p>
  </li>
  <li>
    <p><em>RISC-V 中的 SBI 的含义和功能是啥？</em></p>

    <blockquote>
      <p>SBI 是 Supervisor Binary Interface 缩写， SBI允许在所有 RISC-V 实现上， 通过定义平台（或虚拟化管理程序）特定功能的抽象， 使监管者模式 （S-mode 或 VS-mode） 的软件具备可移植性。 SBI 的设计遵循 RISC-V 的一般原则， 即核心部分小而精简， 同时具备一组可选的模块化扩展功能。 这套特权态软件和运行机器的二进制接口把机器行为抽象了， 特权态软件通过这套二进制标准向底层机器请求服务。这个特权态软件包括 host 上的内核， 也包括跑在 guest 上的内核。</p>
    </blockquote>
  </li>
  <li>
    <p><em>为了让应用程序能在计算机上执行， 操作系统与编译器之间需要达成哪些协议？</em></p>

    <blockquote>
      <p>操作系统为程序提供了库文件， 编译器依赖这些程序文件以生成适用操作系统与平台的特定文件格式， 在 Linux 中这种文件格式是 ELF， 在 Windows 中是 COFF 等。 这类程序文件需要为操作系统提供符号表、 段等各种必要的信息， 使得程序能够在特定的内存空间正常运行。</p>
    </blockquote>
  </li>
  <li>
    <p><em>请简要说明从 QEMU 模拟的 RISC-V 计算机加电开始运行到执行应用程序的第一条指令这个阶段的执行过程。</em></p>

    <blockquote>
      <p>RustSBI 会在内核加载前完成一系列的初始化操作， 例如串口， Flash 等设备， 之后会将控制权递交给 Kernel （这里没有 u-boot， RustSBI 直接加载了内核）。 同样的， 内核会对网口、内存、文件系统等进行初始化并在最后跳转到应用程序的第一条指令处。</p>
    </blockquote>
  </li>
  <li>
    <p><em>为何应用程序员编写应用时不需要建立栈空间和指定地址空间？</em></p>

    <blockquote>
      <p>操作系统抽象了内存管理， 一般而言 MMU 管理了应用程序的地址空间， 完成了虚拟地址到实际物理地址的映射。 栈空间和堆空间同样依赖虚拟地址映射， 而这部分底层工作已经交由操作系统分配以及管理了。</p>
    </blockquote>
  </li>
  <li>
    <p><em>现代的很多编译器生成的代码， 默认情况下不再严格保存/恢复栈帧指针。 在这个情况下， 我们只要编译器提供足够的信息， 也可以完成对调用栈的恢复。… 根据给出这些信息，调试器可以如何复原出最顶层的几个调用栈信息？假设调试器可以理解编译器生成的汇编代码。</em></p>

    <div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">disassemble</span><span class="w"> </span><span class="n">flap</span><span class="w">
 </span><span class="n">Dump</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">flap</span><span class="o">:</span><span class="w">
 </span><span class="mh">0x0000000000010730</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+0</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">-16</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">唯一入口</span><span class="w">
 </span><span class="mh">0x0000000000010732</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+2</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">sd</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010742</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+18</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ld</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="mh">0x0000000000010744</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+20</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">16</span><span class="w">
 </span><span class="mh">0x0000000000010746</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+22</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ret</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="n">唯一出口</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010750</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+32</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">j</span><span class="w">       </span><span class="mh">0x10742</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">disassemble</span><span class="w"> </span><span class="n">flip</span><span class="w">
 </span><span class="n">Dump</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">flip</span><span class="o">:</span><span class="w">
 </span><span class="mh">0x0000000000010752</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+0</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">-16</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">唯一入口</span><span class="w">
 </span><span class="mh">0x0000000000010754</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+2</span><span class="o">&gt;:</span><span class="w">     </span><span class="n">sd</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010764</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+18</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ld</span><span class="w">      </span><span class="n">ra</span><span class="p">,</span><span class="m">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
 </span><span class="mh">0x0000000000010766</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+20</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="m">16</span><span class="w">
 </span><span class="mh">0x0000000000010768</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+22</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">ret</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="n">唯一出口</span><span class="w">
 </span><span class="n">...</span><span class="w">
 </span><span class="mh">0x0000000000010772</span><span class="w"> </span><span class="o">&lt;</span><span class="m">+32</span><span class="o">&gt;:</span><span class="w">    </span><span class="n">j</span><span class="w">       </span><span class="mh">0x10764</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">
 </span><span class="n">End</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">assembler</span><span class="w"> </span><span class="n">dump.</span><span class="w">

 </span><span class="c1"># state</span><span class="w">
 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">pc</span><span class="w">
 </span><span class="o">$</span><span class="m">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="w"> </span><span class="mh">0x10752</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">sp</span><span class="w">
 </span><span class="o">$</span><span class="m">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="mh">0x40007f1310</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">$</span><span class="n">ra</span><span class="w">
 </span><span class="o">$</span><span class="m">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="w"> </span><span class="mh">0x10742</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">

 </span><span class="p">(</span><span class="n">gdb</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="o">/</span><span class="m">6</span><span class="n">a</span><span class="w"> </span><span class="o">$</span><span class="n">sp</span><span class="w">
 </span><span class="mh">0x40007f1310</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10750</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flap</span><span class="m">+32</span><span class="o">&gt;</span><span class="w">
 </span><span class="mh">0x40007f1320</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10772</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+32</span><span class="o">&gt;</span><span class="w">
 </span><span class="mh">0x40007f1330</span><span class="o">:</span><span class="w">   </span><span class="o">???</span><span class="w">     </span><span class="mh">0x10764</span><span class="w"> </span><span class="o">&lt;</span><span class="n">flip</span><span class="m">+18</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div>    </div>

    <blockquote>
      <p>根据上述信息， 当前的 <code class="language-plaintext highlighter-rouge">pc</code> 在 <code class="language-plaintext highlighter-rouge">flip</code> 函数的入口位置， 此时的 <code class="language-plaintext highlighter-rouge">sp</code> 在 <code class="language-plaintext highlighter-rouge">0x4007f1310</code> 处， 而 <code class="language-plaintext highlighter-rouge">ra</code> 在 <code class="language-plaintext highlighter-rouge">0x10742</code> 处， 说明 <code class="language-plaintext highlighter-rouge">flip</code> 函数调用后会返回到 <code class="language-plaintext highlighter-rouge">flap</code> 函数中， 此时对应的指令为 <code class="language-plaintext highlighter-rouge">ld ra,8(sp)</code>， 那么读取到的 <code class="language-plaintext highlighter-rouge">ra</code> 为 <code class="language-plaintext highlighter-rouge">0x10750</code>， 返回的位置仍在 <code class="language-plaintext highlighter-rouge">flap</code> 中， 并根据指令其仍会 跳转到 <code class="language-plaintext highlighter-rouge">0x10742</code> 处并继续从栈中取出地址 <code class="language-plaintext highlighter-rouge">0x10772</code> 跳转到 <code class="language-plaintext highlighter-rouge">flip</code> 中的 <code class="language-plaintext highlighter-rouge">j 0x10764</code>。</p>
    </blockquote>

    <p><a href="https://www.openeuler.org/zh/blog/zhangxinhao/risc-v/2020-11-28-RISC-V.html">RISC-V特权级架构与系统启动</a></p>
  </li>
</ol>

<h2 id="5-实验练习">5. 实验练习</h2>

<p><a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/chapter1/index.html">rCore-Tutorial-Guide-2023S</a> 中没有 ch1 相关练习的， 作者已经实现了依赖 <code class="language-plaintext highlighter-rouge">std::log</code> 的打印输出， 既然这样不如直接在我们之前按照文档构建的 LibOS 上进行更改， 另外顺带把 Makefile 文件功能也补补全。</p>

<dl>
  <dt>Log Info</dt>
  <dd>照着 docs.rs 网址中的 <a href="https://docs.rs/log/0.4.19/log/index.html">Crate log</a> 的说明就可以了。 <a href="https://github.com/HangX-Ma/rcore-sp23/blob/main/ch1/os/src/logging.rs" class="button button--outline-primary button--pill">logging.rs</a></dd>
  <dt>Kernel Info</dt>
  <dd>打印信息也比较简单， 仿照前面的 <code class="language-plaintext highlighter-rouge">clear_bss</code> 函数的写法获取全局变量的地址即可。 <a href="https://github.com/HangX-Ma/rcore-sp23/blob/main/ch1/os/src/main.rs" class="button button--outline-primary button--pill">main.rs</a></dd>
</dl>

<blockquote>
  <p>Spring 2023 版的实验指导书精简了很多内容， 但提供了 ch3 到 ch6, 以及 ch8 这几个章节的 test 代码届时可以直接使用。</p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第一章：应用程序与基本执行环境， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Async Programming in Rust: Futures, Async/Await</title><link href="https://hangx-ma.github.io/2023/06/16/rust-async.html" rel="alternate" type="text/html" title="Async Programming in Rust: Futures, Async/Await" /><published>2023-06-16T00:00:00+08:00</published><updated>2023-06-16T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/16/rust-async</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/16/rust-async.html"><![CDATA[<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=lJ3NC-R3gSI">Rust’s Journey to Async/Await - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-2019/">[Slide]</a></li>
  <li><a href="https://www.youtube.com/watch?v=NNwK5ZPAJCk">The Talk You’ve Been Await-ing for - QCon New York 2019</a>, <a href="https://www.infoq.com/presentations/rust-async-await/">[Slide]</a></li>
  <li><a href="https://course.rs/advance/async/intro.html">Rust语言圣经(Rust Course) - 异步编程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[Rust 异步编程中涉及到 Futures， Async/Await 等设计， 这种 Event Driven Programming 以及 Non-Blocking 的设计与构想非常重要。]]></summary></entry></feed>