<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-07-26T09:52:28+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">STM32F103 Vofa+ 配置与调试指南</title><link href="https://hangx-ma.github.io/2023/07/19/vofaplus.html" rel="alternate" type="text/html" title="STM32F103 Vofa+ 配置与调试指南" /><published>2023-07-19T00:00:00+08:00</published><updated>2023-07-19T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/19/vofaplus</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/19/vofaplus.html"><![CDATA[<p>为了阐述清晰和 miniFOC 的开发进行的区分， 单独一章讲一讲这个上位机调试工具 <a href="https://www.vofa.plus/">Vofa+</a>， 当时是看到 B 站 Up <a href="https://space.bilibili.com/662875973">mandzy</a> 的视频以及 Vofa+ 精致的界面感觉这个工具能够帮上不少忙。 目前 Vofa+ 支持三种传输协， <em>FileWater</em>， <em>JustFloat</em>， <em>RawData</em>。 对于电机控制而言， 传输波形的数据需要用到浮点， 第二个传输浮点数据的协议就比较合适了， 具体选用哪种协议示情况而定。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_demo.png" alt="Vofa+ demo, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Vofa+ demo, HangX-Ma</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://www.vofa.plus/">Vofa plus</a></li>
  <li><a href="https://www.vofa.plus/downloads/?index=1&amp;plugin_index=2">Vofa plus - plugins</a></li>
  <li><a href="https://www.bilibili.com/video/BV1DP411C7Xe/?spm_id_from=333.999.0.0&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32使用HAL库生成USB虚拟串口连接VOFA+输出波形 - mandzy Bilibili</a> <a id="vofa_demo"></a></li>
  <li><a href="https://www.bilibili.com/video/BV15V411T7Gg/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">STM32F4使用DMA串口通信连接VOFA软件进行电机调试和波形显示 - mandzy Bilibili</a></li>
  <li><a href="https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">ST RM0008 Reference manual</a></li>
</ul>

<h2 id="1-stm32-virtual-serial-port">1. STM32 Virtual Serial Port</h2>

<p>本质上是用 USB 虚拟串口进行数据收发， 没想到 F103 系列也支持， 但是后来看了看 F103 虚拟串口没有 DMA 功能， 这个就比较致命了。 按照现有设计， 除了进行指令的交互， MCU 还需要通过串口向上位机传输数据， 如果直接交由 CPU 进行处理会极大浪费计算资源， 一般来说需要通过 DMA 规避 CPU 对这些数据的处理。 所以， 对于 F103 系列还是老老实实用 USARTx + DMA 的组合比较合适。</p>

<h2 id="2-vofa-justfloat-protocol">2. Vofa+: JustFloat Protocol</h2>

<p>具体的协议内容可以看官网的 <a href="https://www.vofa.plus/plugin_detail/?name=justfloat">JustFloat</a> 说明， 除了采样数据解析外， 该协议还能进行图像解析。 目前我只用到了数据采样解析部分， 搞懂这个也就一通百通了， 可以看到滚放定义的数据帧如下所示， 帧尾是一个 4 字节的特定数据 <code class="language-plaintext highlighter-rouge">0x00, 0x00, 0x80, 0x7f</code>， 这是小端的顺序， 大端需要调换一下数据的存储顺序。 也就是说， 我们在发送完希望传输的数据后， 需要紧跟在这些数据后面发送一个尾帧， 才能让 Vofa+ 识别数据帧的内容并进行可视化以及文本打印。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CH_COUNT 通道数量
</span><span class="k">struct</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">fdata</span><span class="p">[</span><span class="n">CH_COUNT</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tail</span><span class="p">[</span><span class="mi">4</span><span class="p">]{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>一般来说， 串口是无法接收 float 类型的数据的， 但 float 类型在 STM32 中占据 4 个字节， 因而我们可以定义这样一个 union 联合体结构解决 float 数据传输的问题。 <code class="language-plaintext highlighter-rouge">fdata</code> 和 <code class="language-plaintext highlighter-rouge">chars</code> 共用一块内存区域并且都占据 4 个字节， 这样在使用串口发送数据的时候就能将 <code class="language-plaintext highlighter-rouge">fdata</code> 拆分成 4 个 <code class="language-plaintext highlighter-rouge">chars</code> 进行发送。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @brief Use union to decompose the float_data into 4 bytes char.
 *        Because the USART only transfer bytes.
 */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">Format</span><span class="p">{</span>
    <span class="kt">float</span>    <span class="n">fdata</span><span class="p">;</span>    <span class="c1">// little-endian float</span>
    <span class="kt">uint8_t</span>  <span class="n">chars</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Format_Typedef</span><span class="p">;</span>

<span class="n">Format_Typedef</span> <span class="n">send_data</span><span class="p">[</span><span class="n">VOFA_SEND_CH_COUNT</span><span class="p">];</span>
<span class="n">Format_Typedef</span> <span class="n">recv_data</span><span class="p">[</span><span class="n">VOFA_RECV_CH_COUNT</span><span class="p">];</span>
</code></pre></div></div>

<p>这样， 根据这个协议， 我们仅需要定义两个数据就能完成 USART 的收发， 将这两个数组的地址分别配置为发送部分 DMA 的内存地址， 以及接收部分的内存地址。 当然， 在设置 DMA 的传输数据总量的时候也需要考虑到末尾 4 个字节的特定数据帧。</p>

<p>具体的配置可以查看 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Inc/vofa_usart.h">vofa_usart.h</a> 和 <a href="https://github.com/HangX-Ma/miniFOC/blob/main/Software/foc/Components/Src/vofa_usart.c">vofa_usart.c</a> 这两个文件。</p>
<blockquote>
  <p>特别感谢 B 站 mandzy Up 提供的代码参考！</p>
</blockquote>

<h2 id="3-vofa-components">3. Vofa+ Components</h2>

<p>Vofa+ 还提供了一系列控件方便我们进行对下位机的调试， 这里以这个 <code class="language-plaintext highlighter-rouge">ExtraButtonToggle</code> 控件为例。</p>

<p>将这个控件拖出到新的 Tab 中， 右击可以看到一个 <code class="language-plaintext highlighter-rouge">事件与参数</code> 的选项， 这是表示按钮在 <strong>激活</strong> 以及 <strong>关闭</strong> 的时候会发送的指令。 如果我们的下位机协议非常简单， 配置这个控件的这个选项的参数就能实现功能， 但我们经常会需要对指令包装一个帧头以区分不同功能的指令， 并在解析帧头后继续接收数据， Vofa+ 提供了一个 <code class="language-plaintext highlighter-rouge">命令</code> 区块方便我们发送 <strong>帧头+数据</strong> 这种组合。</p>

<div align="center">
    <img src="/norobots/images/2023-07-19-vofaplus/vofaplus_components.png" alt="Vofa+ components, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Vofa+ components, HangX-Ma</u></font>
</div>

<p>以上图为例， 我定义了一段命令的内容为 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">%% 00 00 00</code>， 前半部分是我定义的帧头数据， 只有识别到 <code class="language-plaintext highlighter-rouge">AA</code> 和 <code class="language-plaintext highlighter-rouge">FF</code> 我才会继续解析指令， 将末尾的 <code class="language-plaintext highlighter-rouge">01</code> 作为区分不同指令的具体标识。</p>

<p>而后半段则是我定义的数据帧， <code class="language-plaintext highlighter-rouge">%%</code> 标识占位符， 这样一组 <code class="language-plaintext highlighter-rouge">%%</code>占位一个字节， 我在这个按钮控件的 <code class="language-plaintext highlighter-rouge">事件与参数</code> 部分设置了激活态发送 <code class="language-plaintext highlighter-rouge">01</code>， 关闭态发送 <code class="language-plaintext highlighter-rouge">02</code>， 这样在我按下按钮后， 根据当前按钮的状态， <code class="language-plaintext highlighter-rouge">%%</code> 会被替换为 <code class="language-plaintext highlighter-rouge">01</code> 或者 <code class="language-plaintext highlighter-rouge">02</code>。 这样， 每次按下按钮后， Vofa+ 都会向 STM32 发送 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">01 00 00 00</code> 或者 <code class="language-plaintext highlighter-rouge">AA FF 00 01</code> <code class="language-plaintext highlighter-rouge">02 00 00 00</code>。</p>

<p>可以结合我在 USART 中 DMA 接收部分对数据的解析方式进行理解。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">USARTx_DMA_RX_IRQHandler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If data receiving complete, clear the TC5 flag</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LL_DMA_IsActiveFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LL_DMA_ClearFlag_TC5</span><span class="p">(</span><span class="n">DMA1</span><span class="p">);</span>
        <span class="c1">// receive frame header: 0xAA 0xFF</span>
        <span class="n">Format_Typedef</span> <span class="n">recv_header</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xAA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">recv_header</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="n">Format_Typedef</span> <span class="n">recv_data</span> <span class="o">=</span> <span class="n">recv_frame</span><span class="p">.</span><span class="n">data_group</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mh">0x01</span><span class="p">:</span>                         <span class="c1">// control motor start/stop</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// start</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">start_pwm</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recv_data</span><span class="p">.</span><span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// stop</span>
                    <span class="n">LED_STATE_TOGGLE</span><span class="p">();</span>
                    <span class="n">g_bldc</span><span class="p">.</span><span class="n">stop_pwm</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x02</span><span class="p">:</span> <span class="c1">// set velocity</span>
                <span class="n">g_target_motor_vel</span> <span class="o">=</span> <span class="n">recv_data</span><span class="p">.</span><span class="n">fdata</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x03</span><span class="p">:</span> <span class="c1">// set Speed Kp</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x04</span><span class="p">:</span> <span class="c1">// set Speed Ki</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x05</span><span class="p">:</span> <span class="c1">// set Current Kp</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x06</span><span class="p">:</span> <span class="c1">// set Current Ki</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x07</span><span class="p">:</span> <span class="c1">// set Current Kp</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mh">0x08</span><span class="p">:</span> <span class="c1">// set Current Ki</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// we need to disable dma rx channel and reset the transfer length</span>
        <span class="n">usart_rx_dma_reload</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>这里为什么设置的发送帧为 8 个字节？ 这是因为目前使用的是 <strong>JustFloat</strong> 协议， 协议发送和接收都是依据 float 的格式与大小进行的。 而我定义了接收帧为大小为 2 的 <code class="language-plaintext highlighter-rouge">Format_Typedef</code> 数组， 正好是 2 个 float， 8 个字节大小。 若是不理解可以看看 mandzy 的相关 <a href="#vofa_demo">视频</a>。</p>
</blockquote>

<h2 id="4-调试记录">4. 调试记录</h2>

<p>一个简单的 USART + DMA 配置， 结果配完 USART1 后发现没有数据发送出来， 也没有数据接收到。</p>

<ul>
  <li>将 USART1 更换为 USART2 以及 USART3 都是一样的情况。</li>
  <li>检查了 DMA 的配置， 发现 <code class="language-plaintext highlighter-rouge">recv_frame</code> 和 <code class="language-plaintext highlighter-rouge">send_frame</code> 的地址忘记写目标地址上了， 但是还是不行。</li>
  <li>单独测试收的过程， 在指令中加入一个翻转 LED 的命令， 无效， cortex-debug 也接收不到中断。</li>
  <li>主程序可以跑通， 加入 LED 翻转指令有效， 通过 cortex-debug 插件也没有发现数据有问题。</li>
  <li>用自己之前写的可以工作的 USART1 的程序进行回环测试， 无效， 基本确定 CH340 硬件坏了。</li>
  <li>用逻辑分析仪测了一下输出脚 <em><strong>PB6(Tx)</strong></em> 有不同的输出波形， 说明 DMA 通信不成问题了， 协议部分还不清楚， 但 CH340 肯定坏了。</li>
  <li><code class="language-plaintext highlighter-rouge">JustFloat</code> 协议测试可用。</li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="C" /><category term="STM32" /><summary type="html"><![CDATA[上位机调试工具 Vofa+ 食用指南， 结合电机调试进行说明， 感谢 Bilibili 大学。]]></summary></entry><entry><title type="html">OOP C Programming</title><link href="https://hangx-ma.github.io/2023/07/18/oopc.html" rel="alternate" type="text/html" title="OOP C Programming" /><published>2023-07-18T00:00:00+08:00</published><updated>2023-07-18T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/18/oopc</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/18/oopc.html"><![CDATA[<p>研究这部分内容的动机主要还是编写 STM32 的 C 代码的时候， 期望有一个固有的类能够管理其方法， 这样能够比较清晰的管理这些同属于一类的代码结构。 其实这里就涉及到了 <strong>面向对象</strong> 的编程思想， 将数据抽象为 <strong>类</strong> 和 <strong>方法</strong>， 类能表征数据的属性， 而方法则是数据属性及状态改变的一种行为。</p>

<p>之前在接触 Linux 驱动的时候其实就浅浅地接触到了 C 面向对象的思想， 例如 MTD 层抽象接口提供给 Block， 我们直接从顶层通过代码索引的方式是没办法找到具体的 Block 调用方法的。 我们只能看到 MTD 抽象出来的接口， 这一定程度上提供了数据的私有化的能力。</p>

<p>网上的相关文章众说纷纭， 但目前看来就是 <em><strong>C 现代编程</strong></em> 这本书讲的最清晰最明白， LW_OOPC 则是 高焕堂 以及其团队 MISOO 设计的方便 C 面向对象的宏定义模块， 能方便相关的开发。 其实这些文章读过来， 主要还是需要开发者用好 <code class="language-plaintext highlighter-rouge">struct</code>， <code class="language-plaintext highlighter-rouge">Macro</code>， <code class="language-plaintext highlighter-rouge">pointer</code>  这三类资源。 <code class="language-plaintext highlighter-rouge">struct</code> 可谓是重中之重， 可以看到在 C++ 中的 struct 和 class 仅在数据接口的私有性上存在差异， 而在 Rust 中则直接删除了 class 的定义， 转向了 struct + trait 的编程模式。</p>

<p>这篇文章不定期更新 OOP C 的一些想法， 其实读 <em><strong>C 现代编程</strong></em> 还是有很多疑惑的， 但是没用到就没太深刻的印象， 有问题再好好研究记录！</p>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><a href="https://pan.baidu.com/s/1qf2VAPh5zU8PAToU9RHbCg?pwd=l9ry">C 现代编程 - 百度网盘</a>
    <blockquote>
      <p>这本书最关键， 下面的感觉写的都不如这本书详细清晰。</p>
    </blockquote>
  </li>
  <li><a href="https://pan.baidu.com/s/1bda2tBK7KZxSOlMUcWMccQ?pwd=secu">UML+OOPC嵌入式C语言开发精讲 - 百度网盘</a></li>
  <li><a href="https://github.com/Akagi201/lw_oopc/tree/master">lw_oopc - Github</a></li>
  <li><a href="https://ooc-coding.sourceforge.net/">Object Oriented C - ooc</a></li>
  <li><a href="https://mp.weixin.qq.com/s/V8xil48IoQE6QB82_5o2_w">真的可以，用C语言实现面向对象编程OOP - 李肖遥 WeChat</a></li>
  <li><a href="https://www.cnblogs.com/kendoziyu/p/c_object-oriented_programming_example_by_struct.html">C语言使用结构体面向对象编程举例讲解 - 极客子羽 博客园</a></li>
</ul>

<h2 id="1-使用-struct-模块化编程">1. 使用 struct 模块化编程</h2>

<p>主要想法还是利用 struct 管理方法函数， 利用 <code class="language-plaintext highlighter-rouge">static</code> 对 <code class="language-plaintext highlighter-rouge">.c</code> 文件中的函数进行私有化处理防止命名冲突。</p>

<h2 id="2-跨文件的全局变量">2. 跨文件的全局变量</h2>

<p>另外在整个工程中会需要跨文件使用相关的变量， 例如我在 <code class="language-plaintext highlighter-rouge">encoder.h</code> 定义了一个 <code class="language-plaintext highlighter-rouge">struct Encoder</code> 作为编码器类， 而我希望通过一个 <code class="language-plaintext highlighter-rouge">g_encoder</code> 变量作为跨文件的全局变量被不同文件使用。 例如在 <code class="language-plaintext highlighter-rouge">encoder.c</code> 中初始化方法函数， 而在其他文件中调用这些方法， 此时通过一个全局的变量就非常方便了。 这里需要区分 <strong>声明</strong> 和 <strong>定义</strong> 这两个概念。</p>

<dl>
  <dt>声明</dt>
  <dd>向编译器说明一个变量或函数的信息，包括：名字、类型、初始值等，即声明变量、函数的属性细节， 包含该声明的模块在连接阶段从其它模块寻找外部函数和变量。</dd>
  <dt>定义</dt>
  <dd>指明变量、函数存储在哪里，当定义发生时，系统为变量或函数分配内存单元。</dd>
</dl>

<p>我在这里是这样构想的， 对于特定功能的类， 例如 <code class="language-plaintext highlighter-rouge">Encoder</code> 编码器类， 则直接在 <code class="language-plaintext highlighter-rouge">encoder.c</code> 中定义一个这个类型的变量 <code class="language-plaintext highlighter-rouge">g_encoder</code>， 在 <code class="language-plaintext highlighter-rouge">encoder.h</code> 中则通过 <code class="language-plaintext highlighter-rouge">extern</code> 声明 <code class="language-plaintext highlighter-rouge">g_encoder</code>。 这样， 任何包含 <code class="language-plaintext highlighter-rouge">encoder.h</code> 的文件都能直接使用这个变量。 而一些影响设备属性的 primitive 类型的变量则通过 <code class="language-plaintext highlighter-rouge">config.h</code> 以及 <code class="language-plaintext highlighter-rouge">config.c</code> 进行声明和定义。 这样能够分离文件的职能， 不会导致 <code class="language-plaintext highlighter-rouge">config.h</code> 这个管理全局变量的文件不断 include 各种子设备而导致文件管理过于繁杂和臃肿。 但我需要在 <code class="language-plaintext highlighter-rouge">config.h</code> 用注释说明这些全局变量的位置以及功能， 方便后续进行查阅检索。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// encoder.c</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Encoder</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">Encoder</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">Encoder</span> <span class="n">g_encoder</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://www.cnblogs.com/wangh0802PositiveANDupward/archive/2012/08/06/2624827.html">C语言：全局变量在多个c文件中公用的方法 - 奔流聚海 博客园</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="C" /><summary type="html"><![CDATA[结合 OOP 思想进行 C 语言编程， 这篇文章并不从头介绍相关的知识， 而是记录个人学习的疑难点以及参考资料等资源。]]></summary></entry><entry><title type="html">miniFOC Driver Development</title><link href="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html" rel="alternate" type="text/html" title="miniFOC Driver Development" /><published>2023-07-17T00:00:00+08:00</published><updated>2023-07-17T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/17/miniFOC-dev</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/17/miniFOC-dev.html"><![CDATA[<p>研 0 的时候不知好歹自己做了一块驱动板， 但是没有任何经验也不知道怎么开发， 结果上电就烧。 直到最近看到了 B 站 Up <a href="https://space.bilibili.com/382415040">热心市民翔先生</a> 发的 FOC 开发的系列视频感觉这个项目是有救了。 这也算是圆了自己 STM32 开发的愿望， 之前只学习做过一些 demo， 导师甚至把 MCU 称之为玩具（相对他高大上的嵌入式 Linux 而言确实如此）。 但无论如何， 学习的过程中总是会有收获的， 我不认为他们口中简单的东西在没有接触之前都是简单的， 至少我需要这个开发经历。</p>

<blockquote>
  <p>目前板子设计借鉴了 <a href="https://www.bilibili.com/video/BV1NW4y157Ls/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ff5c0e57e43050131aa7ad47bb0e83d9">小男孩gugugu</a> Up 的这部分内容（视频标题太长啦！）， 不想自己从头找元件然后再一个个建模搭了， 太费时间了这样就本末倒置了。</p>
</blockquote>

<ul>
  <li><strong>MCU:</strong> STM32F103C8T6</li>
  <li><strong>Programmer:</strong> CMake + OpenOCD + STLink-v2</li>
  <li><strong>Serial Communication:</strong> Vofa+</li>
  <li><strong>PCB Design:</strong> Altium Designer 23</li>
  <li><strong>Editor:</strong> VSCode</li>
  <li><strong>Third Party Library:</strong>
    <ul>
      <li>Float-point Calculation Optimization: Qfplib-M3</li>
      <li>OLED Display: u8g2</li>
    </ul>
  </li>
</ul>

<p>项目地址 <a href="https://github.com/HangX-Ma/miniFOC">HangX-Ma/miniFOC</a>， 项目将持续更新， 这次挺有信心的！</p>

<h2 id="1-sc60228-磁编码器">1. SC60228 磁编码器</h2>

<p>SC60228 是一款非接触式高精度磁编码器芯片， 芯片中心内置了霍尔感应点矩阵， 可用以测量无刷电机的转子角度。 通过 PWM 或 SPI 的方式输出 12 bit 绝对式位置信息， 检测速率可达 20K rpm， 不难得知该款芯片能检测一周最多 4096 个位置。 相较读取 PWM 输出计算角度而言， 使用 SPI 协议读取数据的精度会更高， 代码编写也比较方便且具备通用性。</p>

<blockquote>
  <p>用这款芯片也是历史遗留问题了， 当时做了这个板子不忍心浪费， 网上有 Simple FOC 提供的 <a href="https://github.com/simplefoc/Arduino-FOC-drivers/tree/master/src/encoders/sc60228">SC60228 SimpleFOC driver</a> 可参考代码部分， 虽然看起来事情不多， 但理解数据手册进行配置和代码编写也对学习很有帮助。</p>
</blockquote>

<h2 id="11-时序图与-spi-基本配置">1.1 时序图与 SPI 基本配置</h2>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/encoder-spi-time-diagram.png" alt="Encoder SPI time diagram, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI time diagram, HangX-Ma</u></font>
</div>

<p>这款芯片只需要配置 SPI 口在主机接收 <strong>(Receive Only Master)</strong> 数据即可， 不涉及双向数据传输。 我原来计划使用 DMA 传输 SPI 的数据， 但实际上 DMA 在小数据量以及高速读取的情况下并不合适， 这里的位置信息仅 16 位， 有些多此一举了。</p>

<p>可以看到上图数据手册提供的读取绝对式角度数据的时序表， 根据 SPI 协议 SCLK 空闲时低电平， 另外根据数据手册， 在 SCLK 上升沿之后需要保持 \(t_{DO}\) 时间以使得 MISO 数据有效， 那么只能在下降沿进行数据采样。 不难确定 SPI 协议的 <strong>CPOL(Clock Polarity)</strong> 为 <strong>Low</strong>， <strong>CPHA(Clock Phase)</strong> 为 <strong>Second Edge</strong>。</p>

<p>另外， 手册指出 <strong>\(t_{CLK}\)（SCLK 周期）</strong> 最小需要 100ns， 这里我查了一下 STM32CubeMX 配置中的 Baud Rate 的含义， 如果没理解错就相当于 SPI 中的 SCLK。 对于预设 72MHz 时钟频率的板子， 8 分频 9.0 MBits/s ≈ 111 ns， 另外 <strong>\(t_{DO}\)（SCLK 的上升沿到 MISO 数据有效之间的时间）</strong>_ 其值最大能达到 50 ns， 那么当前算是极限的速率配置了。 为了保险起见我选择设置 16 分频约 222 ns 周期， 防止数据出现丢失以及未定义的情况。</p>

<blockquote>
  <p>这里配置的是 SPI1 的， 我后面改成 SPI2 之后由于总线的时钟频率不一样， SPI2 只需要 8 分频。 改这个总线的原因还是因为 SPI2 的 DMA 通道给 USART1 给占了， 想玩玩 OLED 得用 SPI + DMA 的方式速率才能跟得上， 虽然最后可能会因为计算资源问题不上 OLED。</p>
</blockquote>

<p>除此之外数据手册中的 \(t_{L}\)， \(t_{H}\)， \(t_{CS}\) 这几个关键量需要在编程时在特定位置延时。 LL 库仅定义了毫秒级的延时， 一个简单的办法实现 us 级的延时就是通过 <code class="language-plaintext highlighter-rouge">__NOP</code> 指令， 这样至少不会浪费定时器资源而且目前也不需要这么高精度的延时（64 个 <code class="language-plaintext highlighter-rouge">__NOP</code> 就足够了。 72MHz 主频一个 <code class="language-plaintext highlighter-rouge">__NOP</code> 为 1/72 us）。</p>

<div align="center">
    <img src="/norobots/images/2023-07-17-miniFOC-dev/spi1-parameter-settings.png" alt="Encoder SPI1 parameter settings, HangX-Ma" width="400" />
    <br />
    <font size="2" color="#999"><u>Encoder SPI1 parameter settings, HangX-Ma</u></font>
</div>

<blockquote>
  <p>后续测试若有问题则可将分频倍数调得更高一些， 400 ns 应该也是能接受的， 手册说明最大转速可测 20K rpm， 小电机能有 5K rpm 也不得了了。</p>
</blockquote>

<p>另外 16-bits 的数据中， 除了 MSB 开始的 <code class="language-plaintext highlighter-rouge">[D11..D0]</code> 角度数据， 后续有用的还有 <code class="language-plaintext highlighter-rouge">ERR</code>， 能够识别磁铁安装位置是否合适， 在装机的时候非常有用。 <code class="language-plaintext highlighter-rouge">PARC</code> 用以进行奇偶校验， 该位需要和前 15 位数据保持奇数特性。</p>

<p>另外配置片选引脚的时候需要默认输出为高并且将其配置为上拉模式， 这是根据时序图所示， 芯片是在 CS 脚为低的时候工作的， 这样能保证在必要的时候选中相应的片选脚进行数据传输。</p>

<blockquote>
  <p><a href="https://www.cnblogs.com/blogernice/articles/12531133.html">详解SPI中的极性CPOL和相位CPHA - blogernice 博客园</a><br />
<a href="https://zhuanlan.zhihu.com/p/26509678">秒懂 奇偶校验码 - 车卡门 知乎</a><br />
<a href="https://blog.csdn.net/ftswsfb/article/details/104321901">奇偶校验原理及C实现 - ftswsfb CSND</a><br />
<a href="https://blog.csdn.net/weixin_43593122/article/details/119253544">硬件探索——STM32F4通过SPI总线读取GMR（磁编码器） - 123-wqy CSDN</a><br />
<a href="https://zhuanlan.zhihu.com/p/632955358">STM32——DMA数据转运 - 柯宝最帅 知乎</a><br />
<a href="https://blog.51cto.com/u_13682052/4990083">stm32利用通用定时器实现函数运行时间精确测量 - biao2488890051 51CTO</a></p>
</blockquote>

<h2 id="12-spi-片选的说明">1.2 SPI 片选的说明</h2>

<p>SPI 片选对 SPI 设备是通用的， 不管是从机还是主机， 都需要配置片选引脚。 我在 CubeMX 中看到 NSS 引脚分为硬件和软件两种， NSS 就是平常所说的片选脚， 对于主机而言片选脚需要拉高的， 这样才能保证主机 SPI 处于工作状态。 如果选择软件配置， 那么在我们选择 STM32 作为主机的时候， LL 库自动帮我们配置了 SSI 引脚作为主机的片选。 而硬件配置则会根据芯片特定的 NSS 引脚决定相应的状态。</p>

<p>而 SPI 主机硬件配置时可以将 Hardware NSS Signal 配置为 <strong>Hardware NSS Output Signal</strong>， 这样 NSS 脚就能自动输出低电平使能从设备。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_44509533/article/details/104110454">STM32 SPI的NSS引脚配置 - 星水天河 CSDN</a><br />
<a href="https://blog.csdn.net/m0_46272475/article/details/121152512">STM32 SPI 软件NSS和硬件NSS解读 - fanyuandrj CSND</a></p>
</blockquote>

<h2 id="2-cortex-m3-浮点计算优化">2. Cortex-M3 浮点计算优化</h2>

<p><strong><a href="https://www.quinapalus.com/qfplib.html">Qfplib: a family of floating-point libraries for ARM Cortex-M cores</a></strong></p>

<p>一年前就找到了这个库了， 一直没尝试用过。 在 miniFOC 的项目中我是将所有的外部库都放到了 <code class="language-plaintext highlighter-rouge">Driver</code> 这个文件夹下面， 我创建了一个 <code class="language-plaintext highlighter-rouge">Qfplib-M3</code> 的文件夹存储浮点计算的库文件， 只需要在 <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> 中添加这个库的路径就能使用了。 经过测试， 使用这个浮点库对计算性能有非常大的提升， 在单步调试的时候， 普通的浮点数除法比利用 qfplib 的浮点数除法有肉眼可见的差距。</p>

<h2 id="3-u8g2-库的使用">3. u8g2 库的使用</h2>

<p>u8g2 库的使用参考了两份代码（用的是 SSD1306 驱动芯片）， 但实际上这两篇文章都没有解决我使用 LL 库配置 SPI + DMA 进行数据传输的问题。 很遗憾我没解决这个问题， 最后使用了普通的 SPI 传输的办法， 这是因为我在几个论坛上发现很多人用了 SPI + DMA 就无法做到数据的正常传输， 必须等到 SPI + DMA 的数据传输完成后才能进行下一次传输， 而这需要通过 while 循环不断检查是否传输完毕。 既然需要 CPU 的参与， 不如直接用 SPI 还更省心。</p>

<ul>
  <li>SPI 发送数据， 需要通过 <code class="language-plaintext highlighter-rouge">LL_SPI_IsActiveFlag_TXE(SPI1)</code> 检查当前传输是否完成， 当前字节传输完成后才能开启下一次传输。</li>
  <li>除此之外， u8g2 将 CS 引脚拉高之前 （Deselect）， 需要确认 SPI 的传输已经结束， 否则会造成数据错误。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="nf">u8x8_byte_4wire_hw_spi</span><span class="p">(</span>
    <span class="n">U8X8_UNUSED</span> <span class="n">u8x8_t</span> <span class="o">*</span><span class="n">u8x8</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">msg</span><span class="p">,</span>
    <span class="kt">uint8_t</span> <span class="n">arg_int</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">arg_ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_SEND</span><span class="p">:</span> <span class="c1">// Use SPI to send 'arg_int' bytes</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arg_int</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LL_SPI_TransmitData8</span><span class="p">(</span><span class="n">SPI1</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_ptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">__NOP</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
        <span class="k">case</span> <span class="n">U8X8_MSG_BYTE_END_TRANSFER</span><span class="p">:</span>  <span class="c1">// Software CS is needed. (deselect)</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_BSY</span><span class="p">(</span><span class="n">SPI1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SET</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">__NOP</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">gpio_and_delay_cb</span><span class="p">(</span><span class="n">u8x8</span><span class="p">,</span> <span class="n">U8X8_MSG_DELAY_NANO</span><span class="p">,</span> <span class="n">u8x8</span><span class="o">-&gt;</span><span class="n">display_info</span><span class="o">-&gt;</span><span class="n">pre_chip_disable_wait_ns</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">LL_GPIO_SetOutputPin</span><span class="p">(</span><span class="n">OLED_CS_SCK_MOSI_GPIO_PORT</span><span class="p">,</span> <span class="n">OLED_CS_PIN</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/AagsAags/stm32f103c8t6_u8g2_hw_spi">AagsAags/stm32f103c8t6_u8g2_hw_spi - Github</a><br />
<a href="https://www.izilzty.com/?post=15">在STM32上使用U8g2图形库并配合DMA发送显示数据（LL库） - izilzty的小窝</a></p>
</blockquote>

<h2 id="4-ina199x1-电流采样配置">4. INA199x1 电流采样配置</h2>

<p>这个配置是真的痛苦啊， 前后加起来快有一天了， 主要是对通过 TIM 定时器对 ADC 触发多通道转换这部分的含义不了解。 关于电流采样， 我设想通过 ADC1 完成多通道采样， 并通过定时器定时出发采样， 使用 DMA 对转换结果进行传输。 依据这个思路需要配置 TIM 的 PWM 以及 ADC 的外部触发。</p>

<p>在 STM32CubeMX 对 ADC 的配置中会看到 <code class="language-plaintext highlighter-rouge">External Trigger Conversion Source</code>， 这个配置网上说啥的都有， 当时我参照 B 站 Up 在 FOC 的配置中选择的 <code class="language-plaintext highlighter-rouge">Timer 2 Capture Compare 2 event</code> 照猫画虎， 配置完后发现根本没办法采到数据。 我发觉这个 Capture Compare 有点像比较器的输出部分， 而 TIM 中配置的则是 <code class="language-plaintext highlighter-rouge">PWM Generation No Output</code>， 这显然对不上。</p>

<p>后续参考尝试了很多代码， 最后在 <a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a> 看到了对这几个参数的相关解释， 发现只有 ADC1 仅对 TIM3 有一个 <code class="language-plaintext highlighter-rouge">Timer 3 Trigger Out event</code> 的选项。</p>

<ul>
  <li><strong>Regular Conversion launched by software:</strong> 规则的软件触发， 调用函数触发即可</li>
  <li><strong>Timer X Capture Compare X event:</strong> 外部引脚触发</li>
  <li><strong>Timer X Trigger Out event:</strong> 定时器通道输出触发， 需要设置相应的定时器设置</li>
</ul>

<p>根据 ADC 中的选项的字面意思， TIM3 中的 <code class="language-plaintext highlighter-rouge">Trigger Event Selection</code> 配置为 <code class="language-plaintext highlighter-rouge">Update Event</code>， 最后终于能采到数据了。</p>

<p>另外需要注意配置中的几个点：</p>

<ul>
  <li>DMA 配置需要在 ADC 配置之前。</li>
  <li>ADC 的外部触发需要定义为上升沿触发， 这一点可以在数据手册的 ADC 章节看到。 LL 库需要调用 <code class="language-plaintext highlighter-rouge">LL_ADC_REG_StartConversionExtTrig</code> 函数。</li>
  <li>PWM 有 Mode 1 和 Mode 2 两种， 分别表示计数器在达到 ARR 值之有为有效电平， 以及在达到 ARR 后为有效电平。 因而对于上升沿触发的要求， 需要配置 PWM 的极性为 Mode 1 为 Low， Mode 2 为 High。 这样， Mode 1 有效电平为 Low， 而 Mode 2 有效电平为 High， 均能达到上升沿的效果。</li>
  <li>
    <p>ADC 校准的代码如下所示， 需要注意结合不同的型号进行差异化配置。 F103 要求在校准之前开启 ADC， 并且需要等待 ADC 的电压稳定。</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//* start ADC1</span>
  <span class="n">LL_ADC_Enable</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="c1">// wait until internal voltage reference stable</span>
  <span class="n">delay_nus_72MHz</span><span class="p">(</span><span class="n">LL_ADC_DELAY_TEMPSENSOR_STAB_US</span><span class="p">);</span>

  <span class="c1">// wait at least 2 ADC cycles after ADC power-on but before calibration</span>
  <span class="n">LL_mDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="c1">// wait until ADC calibration done</span>
  <span class="n">LL_ADC_StartCalibration</span><span class="p">(</span><span class="n">ADC1</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">LL_ADC_IsCalibrationOnGoing</span><span class="p">(</span><span class="n">ADC1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><a href="https://blog.51cto.com/u_520887/5290076">STM32F0使用LL库实现DMA方式AD采集</a><br />
<a href="https://codeantenna.com/a/1MnFm9oX2G">STM32L476多通道TIM+DMA+ADC采样（LL库）</a><br />
<a href="https://blog.51cto.com/u_15456236/4801335">STM32 定时器触发 ADC 多通道采集，DMA搬运至内存</a><br />
<a href="https://www.guyuehome.com/36010">【STM32】 HAL库 STM32CubeMX教程九—ADC</a></p>
</blockquote>

<h2 id="x-stm32-ll-库配置踩坑">X. STM32 LL 库配置踩坑</h2>

<p>在网上搜了一番发现 STM32 用 LL 库开发的效率和配置寄存器差不多， HAL 库的封装太多层了， 虽然移植性比较好但效率显著低于 LL 库。 但是， LL 库资源少而且有坑， 不过对于爱折腾的人以及从 51 那套开始习惯读寄存器的人而言， 倒也不是太大的问题。</p>

<h3 id="x1">X.1</h3>

<p>CubeMX 中的 <code class="language-plaintext highlighter-rouge">SYS</code> 需要配置 <strong>Serial Wire</strong> 才能用 stlink-v2 进行调试。 但是我实际测试用 vscode 的 cortex-debug 插件， 开启这个设置会导致调试偏移到很奇怪的地方， 反倒是不用开也能调试。</p>

<h3 id="x2-tim1-配置-pwm-输出">X.2 TIM1 配置 PWM 输出</h3>

<p>LL 库通过 STM32CubeMX 生成的 TIM1 基础配置存在一定的问题。 见 <code class="language-plaintext highlighter-rouge">Core/Src/tim.c</code> 中对 <code class="language-plaintext highlighter-rouge">Prescaler</code> 以及 <code class="language-plaintext highlighter-rouge">Autoreload</code> 的配置， 会把 <code class="language-plaintext highlighter-rouge">36 - 1</code> 配置成 <code class="language-plaintext highlighter-rouge">36 - LL_TIM_IC_FILTER_FDIV1_N2</code> 怀疑这个与 CubeMX 不支持配置中运算有关系。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Core/Src/tim.c</span>
<span class="kt">void</span> <span class="nf">MX_TIM1_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Prescaler</span> <span class="o">=</span> <span class="mi">36</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">TIM_InitStruct</span><span class="p">.</span><span class="n">Autoreload</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 要使能 TIM1 的输出， <code class="language-plaintext highlighter-rouge">LL_TIM_CC_EnableChannel</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableCounter</code>， <code class="language-plaintext highlighter-rouge">LL_TIM_EnableAllOutputs</code> 这几条函数必须逐个使用， 具体含义可以参考 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj4k_zr4ZWAAxUKAt4KHS_0D60QFnoECBwQAQ&amp;url=https%3A%2F%2Fwww.st.com%2Fresource%2Fen%2Fuser_manual%2Fum1850-description-of-stm32f1-hal-and-lowlayer-drivers-stmicroelectronics.pdf&amp;usg=AOvVaw1DzMCa42sT0JPpOP1EH-0j&amp;opi=89978449">ST - Description of STM32F1 HAL and low-layer drivers</a></p>

<blockquote>
  <p><a href="https://www.cnblogs.com/yhpbook/p/yhp_stm32_tim.html">关于STM32CubeMX使用LL库设置PWM输出</a></p>
</blockquote>

<h3 id="x3-spi">X.3 SPI</h3>

<p>需要增加 <code class="language-plaintext highlighter-rouge">LL_SPI_Enable</code> 函数使能相关的 SPIx 设备。</p>

<p>另外发现一个问题， SPI 的收发需要共用一个函数（纯发送不用， 我在 OLED 中测试过）， 这是因为 SPI 从机没有自己的 SCLK 时钟， 这就需要主机提供。 而双工 SPI 的接收和发送是用两套缓存空间的， 因而可以通过主机向从机发送相应的字节提供 SCLK 时钟， 才能进行同步进行数据接收。 因而， 磁编码器的 SPI 接收函数是这样的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">spi2_transmit_rw</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">outdata</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// wait until the SPI Tx buffer to be empty</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_TXE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">LL_SPI_TransmitData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">,</span> <span class="n">outdata</span><span class="p">);</span>
    <span class="c1">// wait for 16 bits data receiving complete</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LL_SPI_IsActiveFlag_RXNE</span><span class="p">(</span><span class="n">SPI2</span><span class="p">)</span> <span class="o">==</span> <span class="n">RESET</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">LL_SPI_ReceiveData16</span><span class="p">(</span><span class="n">SPI2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可算是懂了为什么磁编码器的数据手册里面 MOSI 是全 0 的数据了。 不过忘记买磁铁了， 调了半个晚上以为电机轴承那边是有磁性的， 结果一直读到 error 的数据， 后来问了好兄弟才知道那块地方是钢， 他推荐我实现 <strong>无感 FOC</strong>， 外贴磁铁会影响电机的磁场可能会有问题。</p>

<blockquote>
  <p><a href="https://blog.csdn.net/weixin_42832780/article/details/96424775">STM32 SPI发送与接收用一个函数实现的问题 - VX13260562029 CSDN</a></p>
</blockquote>

<h3 id="x4-dma">X.4 DMA</h3>

<p>DMA 的配置需要在任何主配置， 如 USART， SPI 这些配置之前完成， 当时 USART 接收有问题， 看网上资料把 DMA 的配置放到了 USART 配置之前就解决问题了。</p>

<h4 id="x41-usart-dma">X.4.1 USART DMA</h4>

<p>USART 的 DMA 开启有几个 LL 库的函数需要注意：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Enable DMA Mode for reception</span>
<span class="n">LL_USART_EnableDMAReq_RX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
<span class="c1">// Enable DMA Mode for transmission</span>
<span class="n">LL_USART_EnableDMAReq_TX</span><span class="p">(</span><span class="n">USARTx_INSTANCE</span><span class="p">);</span>
</code></pre></div></div>

<p>除此之外， 对于配置了 <code class="language-plaintext highlighter-rouge">NORMAL</code> 类型的 DMA 传输， 需要在下一次 DMA 传输开启之前重新配置 <strong>传输的内存地址</strong> 以及 <strong>传输的数据大小</strong>。 值得注意的是， 在配置之前需要 <strong>失能</strong> 相关的 DMA 通道， 另外 <strong>传输的数据大小</strong> 和该传输方向定义的数据宽度相关。 也就是说， 如果此时我定义了 DMA 从外设到内存的传输数据宽度为 <code class="language-plaintext highlighter-rouge">Byte</code>， 那么这个传输的数据大小若设置为 4 则表示传输 4 个字节。 若定义的数据宽度为 <code class="language-plaintext highlighter-rouge">HalfWord</code>， 则传输的数据大小为 4 表示传输 4 个半字 （2 个字节）。</p>]]></content><author><name>HangX-Ma</name></author><category term="FOC" /><category term="STM32" /><summary type="html"><![CDATA[miniFOC 驱动板开发的记录， 涉及 STM32 配置， 所用器件， 以及相关通信协议。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 8</title><link href="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 8" /><published>2023-07-15T00:00:00+08:00</published><updated>2023-07-15T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/15/rcore-note-ch8</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/15/rcore-note-ch8.html"><![CDATA[<blockquote>
  <p>这个章节整理完 Tutorial 还有一个与 I/O 设备管理相关的第九章， 准备之后慢慢琢磨然后不断扩展内核功能， 连续一个月高强度 rCore 的学习心理上有些浮躁了。 最近想把多年未竟的 FOC 项目捡起来好好研究一下， 顺带用上 FreeRTOS 用另一个角度看 OS。</p>
</blockquote>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第八章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/">[ch8]</a> <code class="language-plaintext highlighter-rouge">TODO</code></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-thread-coroutine-os">1. Thread Coroutine OS</h2>

<p>Thread Coroutine OS 增加了在用户态管理的用户态线程/用户态协程， 以及在内核态管理的用户态线程。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/thread-coroutine-os-detail.png" alt="Thread Coroutine OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Thread Coroutine OS details, rCore</u></font>
</div>

<h3 id="11-线程">1.1 线程</h3>

<p><strong>线程</strong> 能够将一个进程内多个可并行执行的任务通过能细粒度的方式被操作系统调度， 实现进程内的并发执行。 进程是线程的资源容器， 线程成为了程序的基本执行实体。 一个进程可以包含多个线程， 同属于一个进程的线程能够共享进程的资源， 如地址空间， 文件等。 线程基本上由线程ID、 执行状态、 当前指令指针(PC)、 寄存器集合和栈组成。</p>

<p>线程能被操作系统或用户态调度器独立调度（Scheduling）， 分派（Dispatch）， 执行（Perform）， 并且由于同一个进程下多个线程同属于一块地址空间并共享资源， 相比较进程之间的 IPC 机制通信， 线程可以通过 <strong>共享内存</strong> 进程数据交互， 之前在做 CUDA 课程的大作业的时候深有感触， 用好线程 <strong>归约</strong> 能让计算效率几何倍提升。</p>
<blockquote>
  <p>基于 CUDA 语言的热扩散仿真模型： <a href="https://github.com/HangX-Ma/CUDA-HeatTransfer-3D">CUDA-HeatTransfer-3D</a>， 有兴趣的同学可以看看 <em>CUDA By Example</em> 这本书了解 CUDA 并行计算。</p>
</blockquote>

<p>但线程最大的问题就是需要 <strong>保持共享资源数据一致性</strong>， 修改数据可能会因为多个线程执行顺序的不可预知而产生 <strong>竞态条件（Race Condition）</strong>， 这是调度的不可控导致的， 而进程独享一片地址空间而不会与其他进程产生数据的地址交叉， 虽然也会被操作系统调度， 但不会遇到这样的问题。</p>

<p>为了解决访问与改写共享资源带来的问题， 操作系统需要提供一些保障机制， 如 <strong>互斥锁（Mutex Lock）</strong>， <strong>信号量（Semaphore）</strong>， <strong>条件变量（Condition Variable）</strong> 等， 这也是这个章节 rCore 所需要解决的第二个问题 —— 为线程提供上述保障。</p>

<h3 id="12-用户态的线程管理">1.2 用户态的线程管理</h3>

<p>用户态的线程管理不受操作系统的约束， 这种线程一般被称为 <strong>Green Threads</strong>， 这与协作式调度非常类似， 线程的管理权限全都交由用户。 rCore 这样设计了线程的基本结构：</p>

<ul>
  <li><strong>线程 ID</strong>： 用以标识与区分不同的线程。</li>
  <li><strong>执行状态</strong>： 同样分为 <strong>空闲（Available）</strong>， <strong>Ready（就绪）</strong>， 以及 <strong>Running（正在执行）</strong>。</li>
  <li><strong>栈</strong>： 为分配每个线程的运行函数栈。</li>
  <li><strong>上下文</strong>： 根据 RISC-V 的函数调用约定需要保存 Callee 寄存器， 同时需要保存 PC 指针以保证执行地址的正常切换。</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="n">id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>            <span class="c1">// 线程ID</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>       <span class="c1">// 栈</span>
    <span class="n">ctx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>     <span class="c1">// 当前指令指针(PC)和通用寄存器集合</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span>         <span class="c1">// 执行状态</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">TaskContext</span> <span class="p">{</span>
    <span class="c1">// 15 u64</span>
    <span class="n">x1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//ra: return address，即当前正在执行线程的当前指令指针(PC)</span>
    <span class="n">x2</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//sp</span>
    <span class="n">x8</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s0,fp</span>
    <span class="n">x9</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>  <span class="c1">//s1</span>
    <span class="n">x18</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//x18-27: s2-11</span>
    <span class="n">x19</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">x27</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="n">nx1</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span> <span class="c1">//new return address, 即下一个要执行线程的当前指令指针(PC)</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span>
    <span class="n">Available</span><span class="p">,</span> <span class="c1">// 初始态：线程空闲，可被分配一个任务去执行</span>
    <span class="n">Running</span><span class="p">,</span>   <span class="c1">// 运行态：线程正在执行</span>
    <span class="n">Ready</span><span class="p">,</span>     <span class="c1">// 就绪态：线程已准备好，可恢复执行</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 对用户态的线程管理通过如下几个函数完成：</p>

<ul>
  <li><strong>线程初始化</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::new</code>： 创建当前处于 <code class="language-plaintext highlighter-rouge">Running</code> 的一个主线程， 并将剩余的线程资源初始化为 <code class="language-plaintext highlighter-rouge">Available</code> 以向量的形式存储在 <code class="language-plaintext highlighter-rouge">Runtime</code> 结构体中方便后续的资源线程创建和管理。</li>
      <li><code class="language-plaintext highlighter-rouge">Runtime::init</code>： 传递 Runtime 对象的地址至全局变量 <em>RUNTIME</em>， 方便其他函数获取相应的资源线程。</li>
    </ul>
  </li>
  <li><strong>线程创建</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::spawn</code>： 在存储线程资源的向量中查找一个状态为 <code class="language-plaintext highlighter-rouge">Available</code> 的空闲线程， 为调度准备 <em>old return address</em> 以及 <em>new return address</em> 并分配新的空间并设置栈顶的位置， 在返回前将该线程状态设置为 <code class="language-plaintext highlighter-rouge">Ready</code>。
        <blockquote>
          <p>实际上这里的 <em>old return address</em> 被设置为了 <code class="language-plaintext highlighter-rouge">guard</code> 函数的地址， 该函数内部调用了 <code class="language-plaintext highlighter-rouge">t_return</code> 将当线程的状态重新设置为 <code class="language-plaintext highlighter-rouge">Available</code> 后会调用 <code class="language-plaintext highlighter-rouge">t_yield</code> 进行线程的切换。 这种设计的作用在讲述 <strong>线程切换</strong> 后再详细说明。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>线程切换</strong>
  线程切换应当是调度中最重要的一个模块， 主要功能由 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 以及 <code class="language-plaintext highlighter-rouge">switch</code> 这两个函数提供。 之前提及的 <code class="language-plaintext highlighter-rouge">Runtime::t_return</code>， <code class="language-plaintext highlighter-rouge">Runtime::guard</code> 以及 <code class="language-plaintext highlighter-rouge">Runtime::yield_task</code> 都封装了 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 以完成相应的调度的功能。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::t_yield</code>： 从当前位置开始查找一个状态为 <code class="language-plaintext highlighter-rouge">Ready</code> 的线程， 没找到会返回 false。 如果当前的线程不是 <code class="language-plaintext highlighter-rouge">Available</code>（说明在 <code class="language-plaintext highlighter-rouge">Running</code>） 就将当前的线程重新放到 <code class="language-plaintext highlighter-rouge">Ready</code> 数组中， 另外就是将找到的 <code class="language-plaintext highlighter-rouge">Ready</code> 线程切换为 <code class="language-plaintext highlighter-rouge">Running</code>。 最后调用 <code class="language-plaintext highlighter-rouge">switch</code> 交换新旧线程的上下文。</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">switch</code>： 完成对 <code class="language-plaintext highlighter-rouge">Runtime::t_yield</code> 未进行切换的 <em>当前指令指针(PC)、 通用寄存器集合和栈</em> 的切换， 关键的任务切换在于如何对 PC 指针进行切换。 <code class="language-plaintext highlighter-rouge">x1(ra)</code> 寄存器保存着当前 <code class="language-plaintext highlighter-rouge">switch</code> 函数的返回地址， rCore 设计从 offset 为 0x00 到 0x68 的寄存器都按序存储， 其中也包括了 <code class="language-plaintext highlighter-rouge">ra</code>。 而在 offset 0x70 的位置又存储了一次 <code class="language-plaintext highlighter-rouge">ra</code>， 其作用也很明显， 后续 <code class="language-plaintext highlighter-rouge">ld t0, 0x70(a1)</code> 这句指令载入了新的 Context 中的 <code class="language-plaintext highlighter-rouge">ra</code>， 通过 <code class="language-plaintext highlighter-rouge">jr t0</code> 就能在 switch 之后直接跳转到新的指令运行的位置。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[naked]</span>
<span class="nd">#[no_mangle]</span>
<span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">switch</span><span class="p">(</span><span class="n">old</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// a0: _old, a1: _new</span>
    <span class="nd">asm!</span><span class="p">(</span>
        <span class="s">"
        sd x1, 0x00(a0)
        ...
        sd x1, 0x70(a0)

        ld x1, 0x00(a1)
        ...
        ld t0, 0x70(a1)

        jr t0
    "</span><span class="p">,</span>
        <span class="nf">options</span><span class="p">(</span><span class="n">noreturn</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>线程执行</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Runtime::run</code>： 用一个 while 循环调用 <code class="language-plaintext highlighter-rouge">t_yield</code> 进行调度， 所有线程执行完后会退出。</li>
    </ul>
  </li>
</ul>

<p>从整体的 rCore 线程设计可以看出， 线程的调度几乎就是按序执行， 所以 <code class="language-plaintext highlighter-rouge">Runtime::spawn</code> 会放入一个 <code class="language-plaintext highlighter-rouge">guard</code> 函数地址作为 <em>old return address</em> 以释放线程资源， 因为当下一次线程位置又切换到这个线程的时候， 实际上该线程已处理完了。 这个设计只能等当前运行的线程主动让出处理器使用权后， 线程管理运行时才能切换检查。</p>

<p>具体实现细节不表了， rCore 在 <code class="language-plaintext highlighter-rouge">user/src/bin/ch8b_stackful_coroutine.rs</code> 中实现了对用户态的线程管理。</p>

<h3 id="13-内核态的线程管理">1.3 内核态的线程管理</h3>

<p>内核态的线程管理扩展了时钟中断， 能基于时钟中断来直接打断当前用户态线程的运行， 实现对线程的调度和切换等。 rCore 在该章节对进程的结构进行了细化， 通过线程来表示对处理器的虚拟化， 使得进程成为了管理线程的容器。 虽然没有父子关系， 但多个线程中的第一个创建的线程一般被称为主线程， 并被分配 0 号进程标识符（TID）。</p>

<p>除了主线程仍然是从程序入口点开始执行， 其余的 <strong>线程的生命周期都与一个函数进行一次绑定</strong>， 从这个角度而言， 主线程其实和进程的声明周期绑定了。</p>

<p>除了具备前述用户态线程的基本特性， rCore 设计的线程模型额外具备如下功能：</p>

<ul>
  <li>线程有三种状态：就绪态、 运行态和阻塞态（阻塞这个知识点解答了我对 poll 函数的疑惑！）；</li>
  <li>线程可以被操作系统调度以分时占用 CPU；</li>
  <li>线程可动态创建与退出；</li>
  <li>线程能通过系统调用获得操作系统的服务， 但 <strong>进程系统调用</strong> 和 <strong>线程系统调用</strong> 不能混用。</li>
</ul>

<blockquote>
  <p>rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html">线程模型与重要系统调用</a> 章节对理解线程模型和设计非常关键。</p>
</blockquote>

<h4 id="131-线程系统调用">1.3.1 线程系统调用</h4>

<ul>
  <li>
    <p><strong>线程创建</strong> 的系统调用 <code class="language-plaintext highlighter-rouge">sys_thread_create</code> 通过 <strong>TID(Thread Identifier)</strong> 区分不同线程， 与进程的 PID 设计很类似， 内核会为每个线程分配专属资源： 用户栈、 Trap 上下文还有内核栈， 前两个在进程地址空间中， 内核栈在内核地址空间中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_thread_create</span><span class="p">(</span><span class="n">entry</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong>线程管理</strong> 通过 TID， <code class="language-plaintext highlighter-rouge">gettid</code> 系统调用能获取当前线程的 TID。</li>
  <li><strong>线程退出</strong> 通过 <code class="language-plaintext highlighter-rouge">exit</code> 系统调用完成， 约定线程从绑定的函数返回的时候都需要调用 <code class="language-plaintext highlighter-rouge">exit</code> 通知操作系统进行资源回收， 更细粒度的线程取代了进程的作为操作系统的调度单元。</li>
  <li><strong>线程资源回收</strong> 通过 <code class="language-plaintext highlighter-rouge">waittid</code> 回收收线程占用的用户态和内核态资源。 这个工作一般是进程/主线程完成， 但若是 <strong>主线程</strong> 调用了 <code class="language-plaintext highlighter-rouge">exit</code> <strong>其子线程</strong> 都会全部退出， 被 <strong>父进程</strong> 回收资源。</li>
</ul>

<p>rCore 之前描述的线程模型提到不能混用进程和线程的系统调用， 原因在于其设计对线程和进程进行了分离。 若是调用了 <code class="language-plaintext highlighter-rouge">sys_thread_create</code> 生成子线程就只考虑多个线程在一个进程内的交互， 如果涉及到父子进程的交互， 就等价为进程模型。</p>

<h4 id="132-软硬件资源管理">1.3.2 软硬件资源管理</h4>

<p>主要干了三件事儿。</p>

<ol>
  <li>
    <p>把原来分配 PID 的数据结构用更通用的 <code class="language-plaintext highlighter-rouge">RecycleAllocator</code> 描述， 能为 PID 以及 TID 分配提供描述结构。 PID 的分配还是延续之前章节， 使用 <code class="language-plaintext highlighter-rouge">PID_ALLOCATOR</code> 这个全局变量。 而线程归属于进程容器， 所以在每个进程控制块的内部可变结构 <code class="language-plaintext highlighter-rouge">ProcessControlBlockInner</code> 中占据一个变量位置， 由进程控制块 <code class="language-plaintext highlighter-rouge">ProcessControlBlock</code> 进行管理。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/process.rs</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
     <span class="c1">// immutable</span>
     <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
     <span class="c1">// mutable</span>
     <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="p">}</span>

 <span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除了 TID 之外， 每个线程都有自己独立的用户栈和 Trap 上下文， 且它们在所属进程的地址空间中的位置可由 TID 计算得到。 新的进程地址空间如下所示：</p>

    <div align="center">
     <img src="/norobots/images/2023-07-15-rcore-note-ch8/app-as-full-with-threads.png" alt="Process address space with threads, rCore" width="600" />
     <br />
     <font size="2" color="#999"><u>Process address space with threads, rCore</u></font>
 </div>

    <p>这个就和第三章的结构非常类似了， 为此 rCore 提供了 <code class="language-plaintext highlighter-rouge">trap_cx_bottom_from_tid</code> 以及 <code class="language-plaintext highlighter-rouge">ustack_bottom_from_tid</code> 这两个函数索引每个线程的用户栈以及 Trap 上下文的具体位置。</p>
  </li>
  <li>
    <p>线程资源整合 <code class="language-plaintext highlighter-rouge">TaskUserRes</code>， 将线程的 TID 、用户栈和 Trap 上下文与线程打包， 由于声明周期一致， 能够进行统一的资源分配和回收。</p>
  </li>
  <li>
    <p>内核栈不再与 PID 或 TID 挂钩， 而与 <code class="language-plaintext highlighter-rouge">kstack_id</code> 这个新的内核标识符相关。 需要增加一个 <code class="language-plaintext highlighter-rouge">KSTACK_ALLOCATOR</code> 的通用资源分配器对内核标识符进行分配。</p>
  </li>
</ol>

<h4 id="133-进程和线程控制块">1.3.3 进程和线程控制块</h4>

<p>对进程和线程两块资源进行分离， 线程已经成为了 CPU 资源的调度单位， 因而与代码执行相关的内容则分配至 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">process</span><span class="p">:</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kstack</span><span class="p">:</span> <span class="n">KernelStack</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">res</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TaskUserRes</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">trap_cx_ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>进程控制块中则保留进程内所有线程共享的资源：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/process.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">ProcessControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">ProcessControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">is_zombie</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">memory_set</span><span class="p">:</span> <span class="n">MemorySet</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ProcessControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">fd_table</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">File</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tasks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_res_allocator</span><span class="p">:</span> <span class="n">RecycleAllocator</span><span class="p">,</span>
    <span class="o">...</span> <span class="c1">// 其他同步互斥相关资源</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="134-结语">1.3.4 结语</h4>

<p>任务管理器 <code class="language-plaintext highlighter-rouge">TaskManager</code> 与处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 仅在接口上有所改变。 线程相关的数据结构的实现可以直接阅读 rCore <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/1thread-kernel.html#id19">线程管理机制的设计与实现</a> 章节因而不赘述了。</p>

<h2 id="2-sync-mutex-os">2. Sync Mutex OS</h2>

<p>Sync Mutex OS 增加了 <strong>互斥锁（Mutex）</strong>、 <strong>信号量（Semaphore）</strong> 和 <strong>条件变量（Condvar）</strong> 这三种资源， 并提供了与这三种同步互斥资源相关的系统调用。 这样多线程应用就可以使用这三种同步互斥机制来解决各种同步互斥问题， 如生产者消费者问题、 哲学家问题、 读者写者问题等。</p>

<div align="center">
    <img src="/norobots/images/2023-07-15-rcore-note-ch8/syncmutex-os-detail.png" alt="Sync Mutex OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Sync Mutex OS details, rCore</u></font>
</div>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第八章：并发， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 7</title><link href="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 7" /><published>2023-07-13T00:00:00+08:00</published><updated>2023-07-13T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/13/rcore-note-ch7</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/13/rcore-note-ch7.html"><![CDATA[<p>该章节尝试建立基于文件的统一I/O抽象， 将标准输入/标准输出的访问改造为基于文件描述符， 然后同样基于文件描述符实现一种父子进程之间的通信机制 —— <strong>管道</strong>， 从而实现灵活的进程间通信， 并基于文件抽象和管道支持不同的独立进程之间的动态组合来实现复杂功能。</p>

<dl>
  <dt>管道</dt>
  <dd>一种数据交换的机制， 管道可被视为一种特殊的内存文件， 在进程被打开的 <em><strong>fd_table</strong></em> 中被管理。 管道通过复用文件读写的系统函数调用可以方便地进行数据交换。</dd>
  <dt>信号</dt>
  <dd>进程间通信的一种异步通知机制， 可以看成是一个应用发出某种信号， 希望另外一个应用能及时响应。</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/ipc-os-detail-2.png" alt="IPC OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>IPC OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第七章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch7">[ch7]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件抽象">1. 文件抽象</h2>

<p><strong>文件</strong> 抽象统一了对 I/O 设备的管理， <strong>Everything is a file</strong> 的思想继承于 Multics OS 的 <strong>通用性</strong> 文件设计。 操作系统不关心文件的具体内容， 而只关心如何对文件按字节流进行读写。 rCore 对此进行了举例， 例如 <strong>键盘设备</strong> 对操作系统而言就是一个只读文件（读取键盘的输入数据）， <strong>屏幕设备</strong> 是只写文件（输出图片文字等信息） 等等。 在该章节基于文件的抽象， rCore 对标准输入和标准输出进行了重构， 为其实现了 <code class="language-plaintext highlighter-rouge">File Trait</code>， 使得进程能按照文件的接口与 I/O 外设交互。</p>

<p>一般来说， 文件的会涉及到， <code class="language-plaintext highlighter-rouge">open</code>， <code class="language-plaintext highlighter-rouge">close</code>， <code class="language-plaintext highlighter-rouge">read</code>， <code class="language-plaintext highlighter-rouge">write</code> 这些基本操作。</p>

<p>另外， 进程被创建的时候内核会默认打开三个缺省的文件， 这个设计对于后续的 I/O 重定向而言非常重要。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fd: 0</code> 标准输入</li>
  <li><code class="language-plaintext highlighter-rouge">fd: 1</code> 标准输出</li>
  <li><code class="language-plaintext highlighter-rouge">fd: 2</code> 标准错误输出</li>
</ul>

<p>需要注意的是， 子进程需要继承其父进程的所有的文件描述符与父进程共享所有文件， 基于这个设计， <code class="language-plaintext highlighter-rouge">pipe</code> 管道机制能够让父子进程共用一套标准输入和输出接口， 这样就构成了进程之间通信的基本桥梁。</p>

<h2 id="2-管道">2. 管道</h2>

<p>管道的设计就是基于以上文件抽象实现的几种机制， 其本质可被描述为一个 <strong>环形的缓冲队列</strong>， 具备 <strong>读端</strong> 和 <strong>写端</strong>， 读写两端通过不同的文件描述符进行访问。 通过文件抽象， 我们能对读写进行权限控制， 控制数据的流向。 另外， 只有读写两端都关闭后管道的资源才能被回收， 这要求除了实现 <code class="language-plaintext highlighter-rouge">sys_pipe</code> 系统调用， 还需要实现 <code class="language-plaintext highlighter-rouge">sys_close</code> 对文件的关闭进行控制。</p>

<p>rCore 对管道的设计分为端口设计与缓存设计。</p>

<ul>
  <li><strong>端口设计</strong> <code class="language-plaintext highlighter-rouge">struct Pipe</code>， 通过实现 <code class="language-plaintext highlighter-rouge">File Trait</code> 使得这两个端口能够通过文件描述符进行访问。</li>
  <li><strong>缓存设计</strong> <code class="language-plaintext highlighter-rouge">struct PipeRingBuffer</code>， 实际就是维护了一个环形的缓存队列。 值得注意的是 <code class="language-plaintext highlighter-rouge">struct Pipe</code> 用 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;PipeRingBuffer&gt;&gt;</code> 维护对 <code class="language-plaintext highlighter-rouge">PipeRingBuffer</code> 的强引用计数， 这能保证在读写两端都被关闭后 <code class="language-plaintext highlighter-rouge">PipeRingBuffer</code> 中的资源能够被自动回收， 而 <code class="language-plaintext highlighter-rouge">PipeRingBuffer::write_end</code> 维护了一个弱引用计数， 这是为了后续检查写端是否全部被关闭的依据。</li>
</ul>

<blockquote>
  <p>只有写端都被关闭后才能保证没有数据被遗漏， 此时读端的关闭才是安全的。 另外， 写端实际是对读端存在依赖的， 若仅有一个写端， pipe 的缓冲区一定会耗尽， 而只存在一个读端却没什么问题， 大不了每次读返回都是 0。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/fs/pipe.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Pipe</span> <span class="p">{</span>
    <span class="n">readable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">writable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">PipeRingBuffer</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PipeRingBuffer</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">RING_BUFFER_SIZE</span><span class="p">],</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">RingBufferStatus</span><span class="p">,</span>
    <span class="n">write_end</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">Pipe</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Copy,</span> <span class="nd">Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">enum</span> <span class="n">RingBufferStatus</span> <span class="p">{</span>
    <span class="n">FULL</span><span class="p">,</span>
    <span class="n">EMPTY</span><span class="p">,</span>
    <span class="n">NORMAL</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-标准-io-重定向">3. 标准 I/O 重定向</h2>

<p>重定向的想法在于对 <code class="language-plaintext highlighter-rouge">fd</code> 文件描述符进行替换。 由前述内容可知， 新建进程默认打开三个缺省的文件描述符分别描述标准输入(0)， 标准输出(1)， 标准错误输出(2)， 文件描述符分配有一条重要的性质： <em><strong>必定分配可用描述符中编号最小的一个</strong></em>， 而 <code class="language-plaintext highlighter-rouge">sys_dup</code> 做的工作就是将当前的文件拷贝到一个新的文件描述符。 所以， 例如我们先通过 <code class="language-plaintext highlighter-rouge">sys_close</code> 关闭标准输入， 那么再调用 <code class="language-plaintext highlighter-rouge">sys_dup(current_fd)</code> 就能让 <code class="language-plaintext highlighter-rouge">fd=1</code> 的位置的内容被替换为当前的目标文件。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/fs.rs</span>

<span class="cd">/// 功能：将进程中一个已经打开的文件复制一份并分配到一个新的文件描述符中。</span>
<span class="cd">/// 参数：fd 表示进程中一个已经打开的文件的文件描述符。</span>
<span class="cd">/// 返回值：如果出现了错误则返回 -1，否则能够访问已打开文件的新文件描述符。</span>
<span class="cd">/// 可能的错误原因是：传入的 fd 并不对应一个合法的已打开文件。</span>
<span class="cd">/// syscall ID：24</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_dup</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.acquire_inner_lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="o">&gt;=</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">new_fd</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.alloc_fd</span><span class="p">();</span>
    <span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">new_fd</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">inner</span><span class="py">.fd_table</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()));</span>
    <span class="n">new_fd</span> <span class="k">as</span> <span class="nb">isize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了能让用户端使用重定向， rCore 对 <code class="language-plaintext highlighter-rouge">user_shell</code> 进行了改进使其支持用户参数输入。 另外 <code class="language-plaintext highlighter-rouge">sys_exec</code> 需要取出这些传入的命令行参数， 放入 <code class="language-plaintext highlighter-rouge">args_vec: Vec&lt;String&gt;</code> 中作为参数传入 <code class="language-plaintext highlighter-rouge">TaskControlBlock::exec</code> 中， 这些参数会被压入用户栈中。 压栈的主体代码如下代码所示， 为了更清晰的表示压栈的过程， 我绘制了压栈的过程图， 假设压入了两个命令行参数 <code class="language-plaintext highlighter-rouge">aa</code> 和 <code class="language-plaintext highlighter-rouge">bb</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">impl</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">exec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">elf_data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// push arguments on user stack</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">argv_base</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">argv</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">args</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">arg</span><span class="p">|</span> <span class="p">{</span>
                <span class="nf">translated_refmut</span><span class="p">(</span>
                    <span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span>
                    <span class="p">(</span><span class="n">argv_base</span> <span class="o">+</span> <span class="n">arg</span> <span class="o">*</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">())</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">usize</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">args</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">args</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.as_bytes</span><span class="p">()</span> <span class="p">{</span>
                <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">memory_set</span><span class="nf">.token</span><span class="p">(),</span> <span class="n">p</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// make the user_sp aligned to 8B for k210 platform</span>
        <span class="n">user_sp</span> <span class="o">-=</span> <span class="n">user_sp</span> <span class="o">%</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="o">...</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="nf">.len</span><span class="p">();</span>
        <span class="n">trap_cx</span><span class="py">.x</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv_base</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack1.png" alt="Push stack process 1, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 1, HangX-Ma</u></font>
</div>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/push_stack2.png" alt="Push stack process 2, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Push stack process 2, HangX-Ma</u></font>
</div>

<p>压栈完成后 rCore 将 <code class="language-plaintext highlighter-rouge">TrapContext</code>中的 <code class="language-plaintext highlighter-rouge">a0</code> 和 <code class="language-plaintext highlighter-rouge">a1</code> 两个寄存器的值分别设置为输入参数的数量以及前述的 <code class="language-plaintext highlighter-rouge">argv_base</code>。 这样， 在应用第一次进入用户态的时候， 放在 Trap 上下文 <code class="language-plaintext highlighter-rouge">a0</code> 和 <code class="language-plaintext highlighter-rouge">a1</code> 两个寄存器中的内容可以被用户库中的入口函数以参数的形式接收。 rCore 在 <code class="language-plaintext highlighter-rouge">_start</code> 入口函数对这些起始地址做了转化， 将其转化为编写应用的时候看到的 <code class="language-plaintext highlighter-rouge">&amp;[&amp;str]</code> 的形式。</p>

<h2 id="4-信号">4. 信号</h2>

<p>信号机制补足了单向事件通知的机制， 这是一种类似于硬件中断的软件级异步通知机制， 使得进程在接收到特定事件的时候能够暂停当前的工作并及时响应事件， 并在响应事件之后可以恢复当前工作继续执行。 如果进程没有接收到任何事件， 它可以执行自己的任务。 这里的暂停与恢复的工作， 都由操作系统来完成， 应用程序只需设置好响应某事件的事件处理例程就够了。</p>

<p>信号的 <strong>接收方</strong> 是一个进程。 当某进程或操作系统发出信号时，会指定信号响应的对象， 即某个进程的 <code class="language-plaintext highlighter-rouge">pid</code>， 并由该进程预设的信号处理例程来进行具体的信号响应。 接收到信号有多种处理方式， 最常见的三种如下：</p>

<ul>
  <li>
    <p><strong>忽略</strong>：就像信号没有发生过一样。</p>
  </li>
  <li>
    <p><strong>捕获</strong>：进程会调用相应的处理函数进行处理。</p>
  </li>
  <li>
    <p><strong>终止</strong>：终止进程。</p>
  </li>
</ul>

<p>而信号的 <strong>发送方</strong> 有两个：</p>

<ul>
  <li><strong>异步信号</strong>： 进程在正常执行， 此时可能内核或者其他进程给它发送了一个信号， 这些就属于异步信号。</li>
  <li><strong>同步信号</strong>： 由进程自身的执行触发， 在处理 Trap 的时候内核会将相应的信号直接附加到进程控制块中， 这种属于同步信号。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-13-rcore-note-ch7/signal.png" alt="Signal process, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Signal process, rCore</u></font>
</div>

<p>内核会在 Trap 处理完成即将返回用户态之前检查要返回到的进程是否还有信号待处理。 如果需要处理的话，取决于进程是否提供该种信号的处理函数， 若没有提供该函数内核会接管进行默认处理， 整体流程如上图所示。</p>

<h3 id="41-信号相关的数据结构">4.1 信号相关的数据结构</h3>

<p>进程间发送的信号是某种事件， UNIX 采用了整数来对信号进行编号， 这些整数编号都定义了对应的信号的宏名， 宏名都是以 SIG 开头， 比如 SIGABRT, SIGKILL, SIGSTOP, SIGCONT。 rCore 定义了一个 <code class="language-plaintext highlighter-rouge">SignalFlags</code> 类型用以描述这些信号量的集合， 这个数据结构会大量应用到信号处理相关的功能上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">bitflags!</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalFlags</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">SIGDEF</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Default signal handling</span>
        <span class="k">const</span> <span class="n">SIGHUP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">SIGINT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="o">...</span>
        <span class="k">const</span> <span class="n">SIGSYS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外为了处理收到的信号， rCore 定义了 <code class="language-plaintext highlighter-rouge">SignalAction</code> 结构， 其中 <code class="language-plaintext highlighter-rouge">handler</code> 记录了信号处理的回调函数的入口地址， <code class="language-plaintext highlighter-rouge">mask</code> 则表示在处理该函数时需要屏蔽的其他信号的掩码， 这样内核就不会对这些信号进行处理而是直接回到用户态继续执行回调函数， 但这些被屏蔽的信号会被记录在 TCB 中延后处理。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Action for a signal</span>
<span class="nd">#[repr(C,</span> <span class="nd">align(</span><span class="mi">16</span><span class="nd">))]</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalAction</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">handler</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="42-信号的产生">4.2 信号的产生</h3>

<p>如前所述， 信号产生有异步信号和同步信号， rCore 将其分作三类， 前两类是异步信号， 最后一类是同步信号。</p>

<ol>
  <li>进程通过 <code class="language-plaintext highlighter-rouge">kill</code> 系统调用给自己或者其他进程发送信号。</li>
  <li>内核检测到某些事件给某个进程发送信号， 但这个事件与接收信号的进程的执行无关。</li>
  <li>进程执行的时候触发了某些条件， 于是在 Trap 到内核处理的时候， 内核给该进程发送相应的信号。 典型的就是 <code class="language-plaintext highlighter-rouge">SIGSEGV</code> 段错误和 <code class="language-plaintext highlighter-rouge">SIGILL</code> 非法指令。</li>
</ol>

<h4 id="kill-系统调用">kill 系统调用</h4>

<p>实现 <code class="language-plaintext highlighter-rouge">kill</code> 系统调用发送信号， 需要现在 TCB 中加入 <code class="language-plaintext highlighter-rouge">SignalFlags</code> 用以记录当前进程收到了哪些信号还未处理。 该系统调用的实现不算复杂， 我们需要给 <code class="language-plaintext highlighter-rouge">manager.rs</code> 中增添 <code class="language-plaintext highlighter-rouge">PID2TCB</code> 全局变量， 这个全局变量是一个 <strong>BtreeMap</strong> 数据结构， 在每次 <code class="language-plaintext highlighter-rouge">add_task</code> 的时候建立当前进程 pid 与当前进程的 TCB 的映射。 这样在实现 <code class="language-plaintext highlighter-rouge">sys_kill</code> 的时候能通过 <code class="language-plaintext highlighter-rouge">pid2task</code> 获取到对应的 TCB。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signals</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_kill</span><span class="p">(</span><span class="n">pid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">pid2task</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// insert the signal if legal</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task_ref</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.contains</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">task_ref</span><span class="py">.signals</span><span class="nf">.insert</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是， 如果 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 中已经记录了未处理的信号， 在这个信号被处理之前不能加入同一个信号的待处理量。</p>

<h4 id="内核信号生成">内核信号生成</h4>

<p>就是将之前说的 <code class="language-plaintext highlighter-rouge">SIGSEGV</code> 以及 <code class="language-plaintext highlighter-rouge">SIGILL</code>， 在捕获到相应的 trap 之后， 内核主动对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 进行修改补充。</p>

<h3 id="43-信号的处理">4.3 信号的处理</h3>

<p>与信号处理相关的系统调用则有三个：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sys_sigaction</code>：设置信号处理例程</li>
  <li><code class="language-plaintext highlighter-rouge">sys_procmask</code>： 设置进程的信号屏蔽掩码</li>
  <li><code class="language-plaintext highlighter-rouge">sys_sigreturn</code>： 清除栈帧，从信号处理例程返回</li>
</ul>

<p>需要在 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中增加 <code class="language-plaintext highlighter-rouge">signal_mask</code> 以及 <code class="language-plaintext highlighter-rouge">signal_actions</code> 这两个变量用以屏蔽其他信号量以及记录如何对前述 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signals</code> 记录的信号进行响应。 因而可以看到， <code class="language-plaintext highlighter-rouge">SignalActions</code> 实际上是个信号数量匹配的数组， 数组类型是 <code class="language-plaintext highlighter-rouge">SignalAction</code> 这样就能将信号量与待处理函数进行一一对应。 需要说明的是 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::signal_mask</code> 声明了在该进程内会屏蔽的信号， 而 <code class="language-plaintext highlighter-rouge">SignalAction::mask</code> 是该回调函数会屏蔽的信号， 二者需要做 <strong>或</strong> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">signal_mask</span><span class="p">:</span> <span class="n">SignalFlags</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">signal_actions</span><span class="p">:</span> <span class="n">SignalActions</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1">// os/src/task/action.rs</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SignalActions</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">table</span><span class="p">:</span> <span class="p">[</span><span class="n">SignalAction</span><span class="p">;</span> <span class="n">MAX_SIG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>进程可以通过 <code class="language-plaintext highlighter-rouge">sys_sigaction</code> 系统调用捕获某种信号， 暂停进程当前的执行， 调用进程为该种信号提供的函数对信号进行处理， 处理完成之后再恢复进程原先的执行。 可以看到 <code class="language-plaintext highlighter-rouge">prev_action</code> 中存储着之前的处理例程（回调函数）， 需要将这部分内容存放在 <code class="language-plaintext highlighter-rouge">old_action</code> 中， 而将 <code class="language-plaintext highlighter-rouge">action</code> 中的内容替换进 table 中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigaction</span><span class="p">(</span>
      <span class="n">signum</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
      <span class="n">action</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">SignalAction</span><span class="p">,</span>
      <span class="n">old_action</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">SignalAction</span><span class="p">,</span>
  <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="o">...</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">=</span> <span class="nn">SignalFlags</span><span class="p">::</span><span class="nf">from_bits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nf">check_sigaction_error</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">old_action</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">let</span> <span class="n">prev_action</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
          <span class="o">*</span><span class="nf">translated_refmut</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">old_action</span><span class="p">)</span> <span class="o">=</span> <span class="n">prev_action</span><span class="p">;</span>
          <span class="n">inner</span><span class="py">.signal_actions.table</span><span class="p">[</span><span class="n">signum</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="nf">translated_ref</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
          <span class="mi">0</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sys_procmask</code> 就没啥好说的， 把传入进来的 flags 设置好就行。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sys_sigreturn</code> 的实现在逻辑上也不复杂， 更新 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner::handling_sig</code> 并恢复保存在 <code class="language-plaintext highlighter-rouge">trap_ctx_backup</code> 中的上下文， 需要注意的是返回的时候是 <code class="language-plaintext highlighter-rouge">trap_ctx.x[10]</code>， 这是为了避免上下文返回时原来的 <code class="language-plaintext highlighter-rouge">a0</code> 返回值被覆盖而出现返回值变更的问题。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/syscall/process.rs</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_sigreturn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
      <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
          <span class="n">inner</span><span class="py">.handling_sig</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
          <span class="c1">// restore the trap context</span>
          <span class="k">let</span> <span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="nf">.get_trap_cx</span><span class="p">();</span>
          <span class="o">*</span><span class="n">trap_ctx</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.trap_ctx_backup</span><span class="nf">.unwrap</span><span class="p">();</span>
          <span class="n">trap_ctx</span><span class="py">.x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="k">as</span> <span class="nb">isize</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>关于 <code class="language-plaintext highlighter-rouge">handle_signals</code> 包括的一系列内容详见 rCore 的指导书， 并没有太多疑问。</p>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="进程通信邮箱">进程通信：邮箱</h4>

<p>没有测例也不知道写的对不对， 基本上就是魔改一下 Pipe 的环形缓冲队列就整完了。</p>

<blockquote>
  <p>具体可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/e9b19e5f19851f12bcae83531a050d60230abd08">commit#e9b19e5</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第七章：进程间通信与 I/O 重定向， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 6</title><link href="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 6" /><published>2023-07-10T00:00:00+08:00</published><updated>2023-07-10T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/10/rcore-note-ch6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/10/rcore-note-ch6.html"><![CDATA[<blockquote>
  <p>文件系统这块的内容还是相当复杂的， 当时学 xv6 就是一知半解把 lab 草草做完了事儿了， 结果这几个月调设备的时候遇到用 SPI Nand Flash 的设备， 文件系统挂载不上等问题。 自己对 Block Device， VFS， 以及 inode 这些概念的理解都不是很到位， 调试非常痛苦到最后陷入了死胡同， 借着学习 rCore 的机会争取把这块搞懂， 毕竟从头搭一个 OS 要对细节有更好的把握。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">easy-fs</code> 自下而上大致可以分成五个不同的层次：</p>

<dl>
  <dt>磁盘块设备接口层</dt>
  <dd>定义了以块大小为单位对磁盘块设备进行读写的 trait 接口</dd>
  <dt>块缓存层</dt>
  <dd>在内存中缓存磁盘块的数据， 避免频繁读写磁盘</dd>
  <dt>磁盘数据结构层</dt>
  <dd>磁盘上的超级块、 位图、 索引节点、 数据块、 目录项等核心数据结构和相关处理</dd>
  <dt>磁盘块管理器层</dt>
  <dd>合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构， 以及基于这些结构进行文件系统的创建等操作， 以及对磁盘块进行分配和回收处理</dd>
  <dt>索引节点层</dt>
  <dd>管理索引节点（即文件控制块）数据结构， 并实现文件创建/文件打开/文件读写等成员函数， 以向上支持文件操作相关的系统调用</dd>
</dl>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/fsos-fsdisk.png" alt="Filesystem OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Filesystem OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第六章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch6">[ch6]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-文件系统">1. 文件系统</h2>

<p>文件系统交互的主要对象是磁盘这类的存储器， 这类存储器和 RAM 的管理方式不同， 这类存储器以扇区 （一般为 512 bytes） 进行读写， 以块为单位进行存储 （一个块为由多个扇区组成）。 文件系统的职责就是将逻辑上的目录树结构映射存储到这类存储器中并进行管理。 另外， 为了适配管理多个文件系统， 在此基础上抽象出一层 <strong>虚拟文件系统（VFS, Virtual File System）</strong> 提供统一的接口和目录树的通用格式方便进行管理。</p>

<h2 id="2-块设备接口层">2. 块设备接口层</h2>

<p>文件系统以块为单位进行数据管理， 一般我们会通过 <strong>块设备驱动</strong> 完成对磁盘的数据的存取， 这需要文件系统提供接口对接驱动， 这种方式以二者职能为分界进行了层次化处理。 在 rCore 中提供 <code class="language-plaintext highlighter-rouge">BlockDevice</code> 抽象接口， 不过需要注意的是， 这个接口实现了 <code class="language-plaintext highlighter-rouge">Send</code>， <code class="language-plaintext highlighter-rouge">Sync</code>， <code class="language-plaintext highlighter-rouge">Any</code> 这几个 trait。 前两个见过面， 用以保证数据的线程安全， 但我目前还是不太理解下面这两句：</p>

<ul>
  <li><em>A type is Send if it is safe to send it to another thread.</em></li>
  <li><em>A type is Sync if it is safe to share between threads (<code class="language-plaintext highlighter-rouge">T</code> is Sync if and only if <code class="language-plaintext highlighter-rouge">&amp;T</code> is Send).</em></li>
</ul>

<p>由于 Rust 编译器需要知道 trait 实现时的具体大小， 因而 rCore 后续使用的时候都是以 <code class="language-plaintext highlighter-rouge">Arc&lt;dyn BlockDevice&gt;</code> 表明该 trait 类型， 被 <code class="language-plaintext highlighter-rouge">Arc</code> 引用包裹的静态大小是已知的， 这样编译器可以保证引用指向已分配堆的 <code class="language-plaintext highlighter-rouge">BlockDevice</code>， 同时还需要使用 <code class="language-plaintext highlighter-rouge">dyn</code> 关键字。</p>

<p>用到 <code class="language-plaintext highlighter-rouge">Any</code> 与 <code class="language-plaintext highlighter-rouge">BlockDevice</code> 是一个 trait 类型相关。 <code class="language-plaintext highlighter-rouge">Any</code> 的存在实现了 Rust 语言的部分的反射功能， 获得变量的类型 <code class="language-plaintext highlighter-rouge">TypeId</code>， 判断变量是否是指定类型， 转换该类型， 获取类型名称等， 具体的作用后续阅读代码再补充。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_dev.rs</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">BlockDevice</span> <span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="n">Any</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
    <span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">The Rustonomicon - 8.2. Send and Sync</a><br />
<a href="https://rustwiki.org/zh-CN/rust-by-example/trait/dyn.html">通过例子学 Rust 中文版 - 16.2. 使用 dyn 返回 trait</a><br />
<a href="https://www.jianshu.com/p/28386b52c607">Rust std-any 模块详解</a></p>
</blockquote>

<h2 id="3-块缓存层">3. 块缓存层</h2>

<p>块缓存层的存在是为了减少块设备频繁读写的开销， 相较于直接从 RAM 中获取数据， 读写磁盘的速度还是太慢了， 因而我们在软件层面实现块的缓存以加快数据的读写。 但缓存还得解决缓存一致性以及同步性等问题， rCore 使用块缓存全局管理器解决这些问题， 并通过该管理器一次性让更多的块合并操作， 这是因为连续的块的操作能够加速存取速度。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">],</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">modified</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每个 BlockCache 缓存一个磁盘块， 这是一个最小单位， rCore 提供了一些对缓存管理的方法：</p>

<ul>
  <li><strong>new</strong>： <code class="language-plaintext highlighter-rouge">BlockCache</code> 实现了 <code class="language-plaintext highlighter-rouge">new</code> 方法创建从磁盘读取一个 Block 到缓冲区。 前述所言， Block 大小和 Sector 大小一致均为 512 bytes， 这也是缓冲区 <code class="language-plaintext highlighter-rouge">cache</code> 被设置为 <code class="language-plaintext highlighter-rouge">BLOCK_SZ</code> 大小的原因。</li>
  <li><strong>addr_of_offset</strong>： 获取 <code class="language-plaintext highlighter-rouge">cache</code> 数组偏移 <code class="language-plaintext highlighter-rouge">offset</code> 大小的字节地址。</li>
  <li><strong>get_ref， get_mut</strong>： 通过调用 <code class="language-plaintext highlighter-rouge">addr_of_offset</code> 获取地址后， 将该地址声明为不可变或可变引用。</li>
</ul>

<p>rCore 将 <code class="language-plaintext highlighter-rouge">BlockCache::get_ref</code> 和 <code class="language-plaintext highlighter-rouge">BlockCache::get_mut</code> 封装成了 <code class="language-plaintext highlighter-rouge">BlockCache::read</code> 以及 <code class="language-plaintext highlighter-rouge">BlockCache::modify</code> 这两个泛型， 这两个函数后续用到非常多， 后面结合具体代码进行解释。 但从代码的构成而言， <code class="language-plaintext highlighter-rouge">read/modify</code> 构成了传入闭包 f 的一层执行环境，让它能够绑定到一个缓冲区上执行。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">read</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_ref</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>rCore 实现了很多与 <code class="language-plaintext highlighter-rouge">BlockCache</code> 相关的操作方法详见 Tutorial， 这里仅对个人疑难点做记录以及梳理思路。</p>
</blockquote>

<p>rCore 用 FIFO 作为简单的缓存替换策略并限定了缓存区的大小， <strong>块缓存全局管理器</strong> 完成了上述所说的缓存管理的功能。 值得注意的是缓存队列中存储的是 <strong>块编号</strong> 和 <strong>块缓存</strong> 组。 块缓存类型是 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</code>， 共享引用保证在当前 <strong>块缓存全局管理器</strong> 中保留一个引用外（FIFO 剔除缓存的依据）， 缓存请求者能够对缓存进行访问， 而 Mutex 则避免在后续多核拓展时的访存冲突。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">BlockCacheManager</span> <span class="p">{</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">struct BlockCacheManager</code> 实现了一个 <code class="language-plaintext highlighter-rouge">get_block_cache</code> 的方法， 通过将全局实例 <code class="language-plaintext highlighter-rouge">BLOCK_CACHE_MANAGER</code> 封装， 其他模块能够方便地调用 <code class="language-plaintext highlighter-rouge">get_block_cache</code> 获取 <code class="language-plaintext highlighter-rouge">block_id</code> 对应的缓存块， 但需要注意的是返回类型是 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</code> 调用者还需要通过 <code class="language-plaintext highlighter-rouge">.lock()</code> 方法获取互斥锁才能对 <code class="language-plaintext highlighter-rouge">BlockCache</code> 进行操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="n">BLOCK_CACHE_MANAGER</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.get_block_cache</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">block_device</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="4-磁盘布局及磁盘上数据结构">4. 磁盘布局及磁盘上数据结构</h2>

<p>前面几个部分比较好理解， 个人认为这个小节和 inode 小节最为关键且复杂。 要理解磁盘布局先得理解几个概念：</p>

<dl>
  <dt>索引节点(Inode, Index Node)</dt>
  <dd>Inode 编码了文件/目录的底层编号， 这个数据结构包含文件大小， 访问权限， 文件类型等信息， 还包含对数据的索引信息， 通过这些索引信息就能够找到数据块存储在磁盘上的位置。</dd>
  <dt>位图(Bitmap)</dt>
  <dd>位图用以标注索引节点以及数据块的分配情况， 通过位图能够方便分配和回收在磁盘上的存储资源。</dd>
</dl>

<p>rCore 中的磁盘布局如下图所示， 他们是以 Block ID 顺序排布的， 后续根据这个顺序对关键数据结构进行阐述。 这里需要注意的是， rCore 的假定内核仅管理一个块设备， 否则仅以 Block ID 作为标识， 在访问多个不同的块设备的时候会引起歧义。</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/layouts.png" alt="Disk Layouts, HangX-Ma" width="800" /><a id="disk-layouts"></a>
    <br />
    <font size="2" color="#999"><u>Disk Layouts, HangX-Ma</u></font>
</div>

<h3 id="41-super-block">4.1 Super Block</h3>

<p>一句话可以概括， Super Block 存储了后续四个分区占用的 <strong>块数量</strong>， 并利用 <strong>MAGIC</strong> 验证文件系统的合法性。</p>

<h3 id="42-inodedata-bitmap">4.2 Inode/Data Bitmap</h3>

<p>从磁盘布局可以看出， rCore 通过 <strong>Inode Bitmap</strong> 和 <strong>Data Bitmap</strong> 分别管理索引节点和数据块。 每个 Bitmap 可以占据多个块， 在 rCore 中一个块的大小和一个扇区的大小一致都是 512 bytes， 相当于每个 Bitmap 实际上可以管理 \(4096 \times n\) 个索引节点或数据块。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="n">start_block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">blocks</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">BitmapBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u64</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
</code></pre></div></div>

<p>rCore 教程中的 <code class="language-plaintext highlighter-rouge">struct Bitmap</code> 存储的是 <strong>Inode Bitmap</strong> 或 <strong>Data Bitmap</strong> 在磁盘中的位置和大小的信息， 而这个数据结构本身则是存储在 RAM 中的。 rCore 另外用 <code class="language-plaintext highlighter-rouge">BitmapBlock</code> 数组表示每个 4096-bit 大小的数据块。 理解这个数据结构的设计原理， <code class="language-plaintext highlighter-rouge">struct Bitmap</code> 中的 <code class="language-plaintext highlighter-rouge">alloc</code> 和 <code class="language-plaintext highlighter-rouge">dealloc</code> 两个方法的实现就容易理解了。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            start_block_id(Start ID)
                  v
        ----------+---------------------+--------
                  |//// Bitmap Area ////|
        ----------+---------------------+--------
                                        ^
                             start_block_id + blocks(End ID)
        Block ID =&gt; 
        (increase)
</code></pre></div></div>

<p>这里结合 <code class="language-plaintext highlighter-rouge">alloc</code> 函数阐明 <code class="language-plaintext highlighter-rouge">BlockCache</code> 提供的 <code class="language-plaintext highlighter-rouge">read/modify</code> 方法。 注意 <code class="language-plaintext highlighter-rouge">modify</code> 函数中的闭包， 它显式声明了传入闭包的参数的类型是 <code class="language-plaintext highlighter-rouge">&amp;mut BitmapBlock</code> 这样 <code class="language-plaintext highlighter-rouge">modify</code> 中才能将泛型 <code class="language-plaintext highlighter-rouge">T</code> 实例化为具体的类型 <code class="language-plaintext highlighter-rouge">BitmapBlock</code>。 这样通过声明的 <code class="language-plaintext highlighter-rouge">bitmap_block</code>， 我们实际上能对缓冲区的数据进行更改操作。 如果没有理解 <code class="language-plaintext highlighter-rouge">read/modify</code> 泛型的作用， 闭包中捕获的参数的数据来源就会混淆， 对后续的实验理解造成较大的阻碍。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span> <span class="n">BlockCache</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="k">self</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">const</span> <span class="n">BLOCK_BITS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">BLOCK_SZ</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Bitmap</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">block_id</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.blocks</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="nf">get_block_cache</span><span class="p">(</span>
                <span class="n">block_id</span> <span class="o">+</span> <span class="k">self</span><span class="py">.start_block_id</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
                <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nf">.lock</span><span class="p">()</span>
            <span class="nf">.modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> 
            <span class="p">|</span><span class="n">bitmap_block</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BitmapBlock</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">inner_pos</span><span class="p">))</span> <span class="o">=</span> <span class="n">bitmap_block</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.enumerate</span><span class="p">()</span>
                    <span class="nf">.find</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="o">**</span><span class="n">bits64</span> <span class="o">!=</span> <span class="nn">u64</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="p">)|</span> <span class="p">{</span>
                        <span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span> <span class="n">bits64</span><span class="nf">.trailing_ones</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                    <span class="p">})</span> <span class="p">{</span>
                    <span class="c1">// modify cache</span>
                    <span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="n">inner_pos</span><span class="p">;</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">block_id</span> <span class="o">*</span> <span class="n">BLOCK_BITS</span> <span class="o">+</span> <span class="n">bits64_pos</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">inner_pos</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="k">if</span> <span class="n">pos</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="43-inode-blocks">4.3 Inode Blocks</h3>

<p>Inode 存储着每个文件/目录的元数据： 文件/目录大小 <code class="language-plaintext highlighter-rouge">size</code>， 索引节点类型 <code class="language-plaintext highlighter-rouge">type_</code>， 以及对数据块的索引 <code class="language-plaintext highlighter-rouge">direct/indirect1/indirect2</code>。 在虚拟内存映射的章节 rCore 通过三级页表进行索引， 这里的 Inode 索引方式也很类似。 rCore 设计的单个 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的大小是 128 bytes， 也就是 <strong>Inode Blocks</strong> 中每个块能够存储 4 个 <code class="language-plaintext highlighter-rouge">DiskInode</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">const</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">direct</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">INODE_DIRECT_COUNT</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">indirect1</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">indirect2</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">type_</span><span class="p">:</span> <span class="n">DiskInodeType</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">DiskInodeType</span> <span class="p">{</span>
    <span class="n">File</span><span class="p">,</span>
    <span class="n">Directory</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的多级索引是这样理解的， 分为直接索引 (direct) 和 间接索引 (indirect1/indirect2)。</p>

<ul>
  <li><strong>直接索引</strong> <code class="language-plaintext highlighter-rouge">direct</code> 数组的每一个元素都保存着一个数据块的 Block ID， 这在文件尺寸不大于 <code class="language-plaintext highlighter-rouge">28 * 512 bytes = 14 KiB</code> 时使用。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/direct-index.png" alt="Direct Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Direct Index, HangX-Ma</u></font>
</div>

<ul>
  <li><strong>间接索引</strong>
    <ul>
      <li>装满 <code class="language-plaintext highlighter-rouge">direct</code> 这部分内容后需要用间接索引扩大索引范围。 可以使用 <code class="language-plaintext highlighter-rouge">indirect1</code> 存储一个数据块的 Block ID 获取到这个数据块的内容， 而这个数据块我们不直接保存数据， 而是将其当作一个跳板用来存储其他数据块的 Block ID。 512 bytes 的数据块以 <code class="language-plaintext highlighter-rouge">u32(4 bytes)</code> 为单位， 这个数据块最大能存储 128 个 Block ID， 这样我们还能额外索引到 <code class="language-plaintext highlighter-rouge">128 * 512 bytes = 64 KiB</code> 的数据。</li>
      <li>相同的道理， 一级间接索引和直接索引总共 78 KiB 空间都不够用， 就可以再加上二级间接索引， 通过二级索引先找到一级索引块的 Block ID， 这些一级间接索引指向的每个数据块都不直接保存数据， 而是存储其他数据块的 Block ID， 这样再通过一级索引就能确定最终的数据块， 这种设计能额外索引 8 MiB 的额外内容。</li>
    </ul>
  </li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/indirect-index.png" alt="Indirect Index, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Indirect Index, HangX-Ma</u></font>
</div>

<p><code class="language-plaintext success highlighter-rouge">NOTE: 关于 get_block_id 的一些疑惑和相关解释</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">DiskInode</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_block_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">inner_id</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">block_device</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基于直接索引和间接索引， <code class="language-plaintext highlighter-rouge">DiskInode</code> 提供了获取数据块索引的功能的 <code class="language-plaintext highlighter-rouge">get_block_id</code> 函数。 这个函数的接口需要读入一个 <code class="language-plaintext highlighter-rouge">inner_id</code>， 这个并不是对应实际的磁盘的 Block ID 的， 而是根据这个 <code class="language-plaintext highlighter-rouge">inner_id</code> 的大小结合我们存储在 <code class="language-plaintext highlighter-rouge">Inode</code> 中的 <code class="language-plaintext highlighter-rouge">direct</code>， <code class="language-plaintext highlighter-rouge">indirect1</code> 以及 <code class="language-plaintext highlighter-rouge">indirect2</code> 可以获取到对应的数据块所在的 Block ID。</p>
<blockquote>
  <p>那这些数据又是怎么来的？ 通过 <a href="#6-索引节点">6. 索引节点</a>， 中 <code class="language-plaintext highlighter-rouge">struct Inode</code> 提供了 <code class="language-plaintext highlighter-rouge">create</code> 方法。</p>
</blockquote>

<p>对于 <code class="language-plaintext highlighter-rouge">inner_id</code> 可以确定是使用直接索引还是间接索引， 直接索引 <code class="language-plaintext highlighter-rouge">direct</code> 范围是 \([0;27]\)，  <code class="language-plaintext highlighter-rouge">indirect1</code> 的范围是 \([28;127]\)， <code class="language-plaintext highlighter-rouge">indirect2</code> 的范围是 \([128;128*128-1]\)。 实际的 <code class="language-plaintext highlighter-rouge">inner_id</code> 和索引方式的分布值如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-07-10-rcore-note-ch6/inner-id.png" alt="Inner ID, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Inner ID, HangX-Ma</u></font>
</div>

<p>后续关于 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的各种辅助方法就不展开了。</p>

<h3 id="44-data-block--directory">4.4 Data Block / Directory</h3>

<p>对 <strong>文件</strong> 而言其内容就是字节序列， 保存文件内容的数据块可以用字节数组表示。 前述的 Inode 相关的 <code class="language-plaintext highlighter-rouge">read_at</code> 和 <code class="language-plaintext highlighter-rouge">write_at</code> 方法中就是对这些字节数组进行操作。 这里我对 <code class="language-plaintext highlighter-rouge">read_at</code> 以及 <code class="language-plaintext highlighter-rouge">write_at</code> 操作的数据的位置是有疑惑的， 因为 rCore 自下而上编写的这个教学手册， 底层的内容很可能是有上层的包装的 （突然就想起李雅普诺夫判定式了）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">type</span> <span class="n">DataBlock</span> <span class="o">=</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">BLOCK_SZ</span><span class="p">];</span>
</code></pre></div></div>

<p>对 <strong>目录</strong> 而言情况则有所不同， 我们需要建立一种树的结构进行逐级访问。 rCore 设计了 <code class="language-plaintext highlighter-rouge">struct DirEntry</code> 用以存储目录项结构， 其大小为 32 bytes， 这意味着每个 Data Block 可以最多存储 16 个目录项结构。 <code class="language-plaintext highlighter-rouge">name</code> 表示该目录下的一个文件名或子目录目录名， <code class="language-plaintext highlighter-rouge">inode_number</code> 则是这个文件或子目录所对应的 Inode 的节点编号。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/layout.rs</span>
<span class="k">const</span> <span class="n">NAME_LENGTH_LIMIT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>

<span class="nd">#[repr(C)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DirEntry</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">NAME_LENGTH_LIMIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">inode_number</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">const</span> <span class="n">DIRENT_SZ</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="5-磁盘块管理器">5. 磁盘块管理器</h2>

<p>在前面我们描述了磁盘的布局及其相应的数据结构， 这里就是将这些这些细节进行统筹管理， <code class="language-plaintext highlighter-rouge">struct EasyFileSystem</code> 中所保留的信息正好是 <a href="#disk-layouts">Disk Layouts</a> 中描述的几个部分。 另外， 保留 <code class="language-plaintext highlighter-rouge">block_device</code> 指针引用是方便下层数据结构访问块设备。 可以看到这个数据结构中是不包含 superblock 的， 但是在后续计算的时候需要考虑进去。 从这里开始， 所有的数据结构都存储在内存上。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/efs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">EasyFileSystem</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">inode_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">data_bitmap</span><span class="p">:</span> <span class="n">Bitmap</span><span class="p">,</span>
    <span class="n">inode_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// inode 区域的起始 block id</span>
    <span class="n">data_area_start_block</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// data 区域的起始 block id</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="6-索引节点">6. 索引节点</h2>

<p>服务于文件相关系统调用的索引节点层的代码在 <code class="language-plaintext highlighter-rouge">vfs.rs</code> 中， rCore 抽象了一层 Virtual Filesystem 方便使用者管理文件系统的文件与目录。</p>

<p><code class="language-plaintext highlighter-rouge">Inode</code> 和 <code class="language-plaintext highlighter-rouge">DiskInode</code> 的区别从它们的名字中就可以看出： <code class="language-plaintext highlighter-rouge">DiskInode</code> 放在磁盘块中比较固定的位置，而 <code class="language-plaintext highlighter-rouge">Inode</code> 是放在内存中的记录文件索引节点信息的数据结构。 <code class="language-plaintext highlighter-rouge">Inode</code> 数据结构给使用者直接管理目录树结构中逻辑上的文件和目录的接口。 这个 <code class="language-plaintext highlighter-rouge">Inode</code> 在磁盘上所处的位置用 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 即可表示， <code class="language-plaintext highlighter-rouge">fs</code> 则给 Inode 提供了访问底层文件系统的接口。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Inode</span> <span class="p">{</span>
    <span class="n">block_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">block_offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">block_device</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 后续还介绍了获取根目录 Inode, 文件索引， 文件列举， 文件创建， 文件清空， 文件读写的方式。 一直到这里把这几个函数读完， 以及将前述的所有内容再细读之后， 我才理清了 <code class="language-plaintext highlighter-rouge">DiskInode</code> 中的数据是如何被创建以及如何被索引管理的， 之前一直没搞懂究竟数据是如何被定位到 Data Block 的， 实际上就是 root_node 创建新的 child node 的时候 (Inode::create) 就通过 <code class="language-plaintext highlighter-rouge">EasyFileSystem::alloc_inode</code> 在 Inode Area 创建了一个新的 Inode， 最开始这个 Inode 是不存在任何数据的(<code class="language-plaintext highlighter-rouge">DiskInode::initialize</code> 返回的是个空的 <code class="language-plaintext highlighter-rouge">DiskInode</code>)， 只有在调用 <code class="language-plaintext highlighter-rouge">Inode::increase_size</code> 之后， 通过 <code class="language-plaintext highlighter-rouge">EasyFileSystem::alloc_data</code> 申请数据块后， 利用 <code class="language-plaintext highlighter-rouge">DiskInode::increase_size</code> 函数将这些数据块和 <code class="language-plaintext highlighter-rouge">direct</code>， <code class="language-plaintext highlighter-rouge">indirect1</code>， 以及 <code class="language-plaintext highlighter-rouge">indirect2</code> 填充并联系起来的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="cd">/// Increase the size of a disk inode</span>
<span class="k">fn</span> <span class="nf">increase_size</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">new_size</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">disk_inode</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">DiskInode</span><span class="p">,</span>
    <span class="n">fs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">MutexGuard</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">disk_inode</span><span class="py">.size</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">blocks_needed</span> <span class="o">=</span> <span class="n">disk_inode</span><span class="nf">.blocks_num_needed</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">blocks_needed</span> <span class="p">{</span>
        <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">fs</span><span class="nf">.alloc_data</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">disk_inode</span><span class="nf">.increase_size</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.block_device</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="7-课后练习">7. 课后练习</h2>

<h3 id="71-编程练习">7.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="72-实验练习">7.2 实验练习</h3>

<h4 id="硬链接">硬链接</h4>

<p>硬链接要求两个不同的目录项指向同一个文件， 在 easy-fs 中就是两个不同名称目录项指向同一个磁盘块。 需要实现三个系统调用 <code class="language-plaintext highlighter-rouge">sys_linkat</code>， <code class="language-plaintext highlighter-rouge">sys_unlinkat</code>， 以及 <code class="language-plaintext highlighter-rouge">sys_stat</code>。</p>

<p>硬链接需要新的 Inode 的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 与被链接的对象是一致的， 这样才能保证链接到同一个文件数据， 而这两个数据则是通过 <code class="language-plaintext highlighter-rouge">get_disk_inode_pos</code> 函数获取到的， 依据是 <code class="language-plaintext highlighter-rouge">DirEntry</code> 中的 <code class="language-plaintext highlighter-rouge">inode_id</code> 这个数据。 所以 <code class="language-plaintext highlighter-rouge">sys_linkat</code> 的实现和 <code class="language-plaintext highlighter-rouge">Inode::create</code> 非常类似， 唯一不同的是 <code class="language-plaintext highlighter-rouge">new_inode_id</code> 不再是通过 <code class="language-plaintext highlighter-rouge">fs.alloc_inode</code> 获取一个新的 <code class="language-plaintext highlighter-rouge">inode_id</code>， 而是和需要链接的对象的完全一致。</p>

<p>对于 <code class="language-plaintext highlighter-rouge">sys_unlinkat</code> 就是和上述实现相反， 通过输入的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 这两个参数， 遍历 <code class="language-plaintext highlighter-rouge">file_count</code> 数量的 <code class="language-plaintext highlighter-rouge">DirEntry</code> 并将数据读取到 <code class="language-plaintext highlighter-rouge">buf</code> 中查看 <code class="language-plaintext highlighter-rouge">buf</code> 对应的 <code class="language-plaintext highlighter-rouge">block_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_offset</code> 是否和所给的参数一致， 另外实验不要求删除这个被分配的 inode。</p>

<p><code class="language-plaintext highlighter-rouge">sys_stat</code> 这部分遇到的比较大的问题是如何将 <code class="language-plaintext highlighter-rouge">fd_table</code> 获取的到的 <code class="language-plaintext highlighter-rouge">OSInode</code> 从一个 trait 转换成实际的数据类型。 参考了 <a href="https://github.com/yao-jz/rCore-lab/commit/5bdaac804d7ab042f337261ecefa50bda72c0896">yao-jz/rCore-lab - ch6</a> 中的实现， 需要给 File Trait 增加一个自己实现的 AnyConvertor Trait， 能够将任意类型转为 <code class="language-plaintext highlighter-rouge">&amp;dyn Any</code> 再通过 <code class="language-plaintext highlighter-rouge">downcast_ref::&lt;OSInode&gt;()</code> 强制转换为 <code class="language-plaintext highlighter-rouge">OSInode</code> 数据类型。 这样我们再给 <code class="language-plaintext highlighter-rouge">OSInode</code> 增加 <code class="language-plaintext highlighter-rouge">get_inode_id</code> 以及 <code class="language-plaintext highlighter-rouge">get_inode_pos</code> 获取 <code class="language-plaintext highlighter-rouge">inode_id</code> 以及 <code class="language-plaintext highlighter-rouge">block_id</code> 和 <code class="language-plaintext highlighter-rouge">block_offset</code> 即可。 另外需要一个 <code class="language-plaintext highlighter-rouge">get_nlink_num</code> 函数获取 <code class="language-plaintext highlighter-rouge">nlink</code> 硬链接的数量， 思路和 unlink 的实现很类似， 也是遍历 <code class="language-plaintext highlighter-rouge">file_count</code> 数量的 <code class="language-plaintext highlighter-rouge">DirEntry</code> 只不过我们只计数。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="n">Any</span><span class="p">;</span>

<span class="cd">/// convert current type to &amp;dyn Any</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">AnyConvertor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="k">'static</span><span class="o">&gt;</span> <span class="n">AnyConvertor</span> <span class="k">for</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_any</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Any</span> <span class="p">{</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/1b6c70b223719a7207a786fdc49e09eccce51480">commit#1b6c70b</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第六章：文件系统， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 5</title><link href="https://hangx-ma.github.io/2023/07/07/rcore-note-ch5.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 5" /><published>2023-07-07T00:00:00+08:00</published><updated>2023-07-07T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/07/rcore-note-ch5</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/07/rcore-note-ch5.html"><![CDATA[<p>Process OS 强化了以往用以调度应用的 task 的概念， 在这一层抽象的基础上发展出 process， 弱化了 CPU 与任务之间的耦合关系， 所以单从操作系统结构的角度分析其实并没有太大的变化。</p>

<div align="center">
    <img src="/norobots/images/2023-07-07-rcore-note-ch5/process-os-detail.png" alt="Process OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Process OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第五章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch5">[ch5]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-进程概念">1. 进程概念</h2>

<p><strong>进程</strong> 就是操作系统选取某个可执行文件并对其进行一次动态执行的过程， 对于可执行文件中给出的需求能相应对 <strong>硬件/虚拟资源</strong> 进行 <strong>动态绑定和解绑</strong>。 进程的引入让开发者能够控制程序的运行， 操作系统能够面向用户进行交互。 rCore 增添了操作系统中最为关键的几个系统调用： <code class="language-plaintext highlighter-rouge">sys_fork</code>， <code class="language-plaintext highlighter-rouge">sys_waitpid</code>， <code class="language-plaintext highlighter-rouge">sys_exec</code>， 以及 <code class="language-plaintext highlighter-rouge">sys_read</code>。 同样的， 通过引入 <code class="language-plaintext highlighter-rouge">buddy_system_allocator</code> 提供动态内存分配支持， 结合这些系统调用， 在用户态 rCore 提供了一个用户初始程序 <strong>initproc</strong>， 这让 rCore 具备了与应用层的交互能力， 但其背后则需依托 rCore 的进程管理。</p>

<h2 id="2-进程管理的组成结构">2. 进程管理的组成结构</h2>

<p>rCore 为增添了 <code class="language-plaintext highlighter-rouge">struct PidHandle</code> 作为每个进程的标识， 其实现与上一章的 Physical Frame 非常类似。 另外 rCore 改造了 <code class="language-plaintext highlighter-rouge">build.rs</code> 和 <code class="language-plaintext highlighter-rouge">loader.rs</code> 以使 rCore 能够支持应用名而非 task id 加载应用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/pid.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">PidHandle</span><span class="p">(</span><span class="k">pub</span> <span class="nb">usize</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="21-应用的内核栈">2.1 应用的内核栈</h3>

<p>由于引入了进程标识 PID， 之前用 task id 进行应用区分的方式需要用 PID 替代， 所有应用的内核栈的创建就与以往有所不同。 rCore 从 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中分离了 <code class="language-plaintext highlighter-rouge">KernelStack</code> 用以初始化与管理每个应用的内核栈。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/pid.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">KernelStack</span> <span class="p">{</span>
    <span class="n">pid</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="22-进程控制块">2.2 进程控制块</h3>

<p>在内核中，每个进程的执行状态、资源控制等元数据均保存在一个被称为 <strong>进程控制块 (PCB, Process Control Block)</strong> 的结构中，它是内核对进程进行管理的单位。 对于 rCore 而言， PCB 其实是对原来的 TCB 的扩展， 并区分 immutable 与 mutable 两类数据 （ Inner 块使用 <code class="language-plaintext highlighter-rouge">UPSafeCell&lt;T&gt;</code> 管理可变数据）。 第五章新增的是 <code class="language-plaintext highlighter-rouge">parent</code>， <code class="language-plaintext highlighter-rouge">children</code>， 以及 <code class="language-plaintext highlighter-rouge">exit_code</code> 这几个可变量， 使用 <code class="language-plaintext highlighter-rouge">Weak</code> 智能指针能确保不影响父进程的引用计数， 而 <code class="language-plaintext highlighter-rouge">Arc</code> 则提供了对子进程的引用计数， 这两者的配合可以保证父子进程的双向关系以及控制子进程的资源回收了。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="c1">// immutable</span>
    <span class="k">pub</span> <span class="n">pid</span><span class="p">:</span> <span class="n">PidHandle</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_stack</span><span class="p">:</span> <span class="n">KernelStack</span><span class="p">,</span>
    <span class="c1">// mutable</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskControlBlockInner</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">pub</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外我认为解决了上一章痛点问题的是关于任务控制模块的访问方式， rCore 的第五章提供了 <code class="language-plaintext highlighter-rouge">inner_exclusive_access</code> 方法， 此前我也尝试过类似的返回引用的方式避免直接拷贝一整个 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 以避免巨大的开销， 但当时没有考虑到可以在外层包裹一层 <code class="language-plaintext highlighter-rouge">UPSafeCell&lt;T&gt;</code>。 另外相应的， 增加了外增 Wrapper 以及 PID 后， 原来的 <strong>任务控制块创建</strong> 也要转变为 <strong>进程控制块创建</strong>， 其实主要差异就是 Kernel Stack 的创建以及新增的变量的初始化。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">impl</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">inner_exclusive_access</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RefMut</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">TaskControlBlockInner</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>除此之外就是在 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中实现几个关键的系统调用了。</p>

<blockquote>
  <p>需要一提的是， 由于增添了 <code class="language-plaintext highlighter-rouge">wrapper</code>， <code class="language-plaintext highlighter-rouge">os/src/task/mod.rs</code> 中的代码对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 中数据访问发生了变化， 这一块需要大改。</p>
</blockquote>

<h3 id="23-进程管理器">2.3 进程管理器</h3>

<p><strong>任务管理器</strong> 或称 <strong>进程管理器</strong> <code class="language-plaintext highlighter-rouge">TaskManager</code> 将 CPU 的监控职能拆分到处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 中， 其自身仅负责管理所有进程， 这种分离有助于后续实现多核环境的拓展。 这里比较关键的设计是将 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 用 <code class="language-plaintext highlighter-rouge">Arc</code> 智能指针管理， 并将其存储在堆上， 不仅减少开销也方便维护。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/manager.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskManager</span> <span class="p">{</span>
    <span class="n">ready_queue</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="24-cpu-管理器">2.4 CPU 管理器</h3>

<p>处理器管理结构 <code class="language-plaintext highlighter-rouge">Processor</code> 负责维护 CPU 相关的状态。 其中 <code class="language-plaintext highlighter-rouge">current</code> 表示当前处理器上执行的进程任务， 而 <code class="language-plaintext highlighter-rouge">idle_task_cx</code> 则是 idle 控制流的任务上下文。 这个 idle 控制流运行在 CPU 启动栈上， 它会从 <code class="language-plaintext highlighter-rouge">TaskManager</code> 中选择一个进程任务放在当前的 CPU 核上运行。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/processor.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Processor</span> <span class="p">{</span>
    <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">idle_task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>idle 控制流的设计目的在于分离进程调度与 Trap， 换入/换出进程仅需要调用 <code class="language-plaintext highlighter-rouge">schedule</code> 函数， 通过 <code class="language-plaintext highlighter-rouge">__switch</code> 保存自身进程的上下文， 之后程序流会换回 <code class="language-plaintext highlighter-rouge">idle_task_cx_ptr</code> 中的内容重新回到 <code class="language-plaintext highlighter-rouge">run_tasks</code> 的 loop 循环中查找下一个待运行的进程。 这点设计和 xv6 如出一辙， 在 rCore 中则是会持续运行 <code class="language-plaintext highlighter-rouge">run_tasks</code> 用以进程的调度。 引用我自己在 rCore 留言板上的 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/47#issuecomment-1625393985">回答</a> 能帮助理解它的作用：</p>

<blockquote>
  <p>idle 控制流的设计和 xv6 的很像， rCore 让 <code class="language-plaintext highlighter-rouge">run_tasks</code> 始终保持运行， 可以把这个函数想象成一个游戏机，它的作用就是不断挑选可运行的游戏卡（进程）， 然后放到 CPU 这个卡槽中。 一定时间后这个 CPU 卡槽要给别的游戏卡（进程）用了就把这个当前的卡弹出来（这里就用了 <code class="language-plaintext highlighter-rouge">schedule</code> 函数弹出）， 然后游戏机又开始选下一张能用的游戏卡（进程）了。</p>

  <p>游戏卡（进程）只知道自己被插上要运行， 以及到某个点自己要弹出来， 它不知道游戏机的存在， 这样就做到了任务调度的透明。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/processor.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">run_tasks</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">PROCESSOR</span><span class="nf">.exclusive_access</span><span class="p">();</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="nf">fetch_task</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idle_task_cx_ptr</span> <span class="o">=</span> <span class="n">processor</span><span class="nf">.get_idle_task_cx_ptr</span><span class="p">();</span>
            <span class="c1">// access coming task TCB exclusively</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">task_inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">next_task_cx_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task_inner</span><span class="py">.task_cx</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">;</span>
            <span class="n">task_inner</span><span class="py">.task_status</span> <span class="o">=</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Running</span><span class="p">;</span>
            <span class="c1">// stop exclusively accessing coming task TCB manually</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">task_inner</span><span class="p">);</span>
            <span class="n">processor</span><span class="py">.current</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
            <span class="c1">// stop exclusively accessing processor manually</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">processor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="nf">__switch</span><span class="p">(</span>
                    <span class="n">idle_task_cx_ptr</span><span class="p">,</span>
                    <span class="n">next_task_cx_ptr</span><span class="p">,</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">switched_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">PROCESSOR</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">idle_task_cx_ptr</span> <span class="o">=</span> <span class="n">processor</span><span class="nf">.get_idle_task_cx_ptr</span><span class="p">();</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">processor</span><span class="p">);</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">__switch</span><span class="p">(</span>
            <span class="n">switched_task_cx_ptr</span><span class="p">,</span>
            <span class="n">idle_task_cx_ptr</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-进程管理的实现机制">3. 进程管理的实现机制</h2>

<h3 id="31-初始进程创建">3.1 初始进程创建</h3>

<p>可以先看一下 rCore 在第五章的 <code class="language-plaintext highlighter-rouge">main.rs</code> 做的事情， 可以看到在内存管理模块初始化完成后， 会调用 <code class="language-plaintext highlighter-rouge">task</code> 子模块提供的 <code class="language-plaintext highlighter-rouge">add_initproc</code> 将初始进程 <code class="language-plaintext highlighter-rouge">ch5b_initproc</code> 加入进程任务管理器。 因而在 task 子模块中需要初始化进程控制块 <code class="language-plaintext highlighter-rouge">INITPROC</code>。 另外， <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 相较之前有所变更。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/main.rs</span>
<span class="nd">#[no_mangle]</span> <span class="c1">// avoid compiler confusion</span>
<span class="k">fn</span> <span class="nf">rust_main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">clear_bss</span><span class="p">();</span>
    <span class="nf">kernel_log_info</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] Hello, world!"</span><span class="p">);</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] back to world!"</span><span class="p">);</span>
    <span class="c1">// mm tests</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">heap_test</span><span class="p">();</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">frame_allocator_test</span><span class="p">();</span>
    <span class="nn">mm</span><span class="p">::</span><span class="nf">remap_test</span><span class="p">();</span>

    <span class="nn">task</span><span class="p">::</span><span class="nf">add_initproc</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"after initproc!"</span><span class="p">);</span>

    <span class="nn">trap</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>
    <span class="nn">trap</span><span class="p">::</span><span class="nf">enable_timer_interrupt</span><span class="p">();</span>
    <span class="nn">timer</span><span class="p">::</span><span class="nf">set_next_trigger</span><span class="p">();</span>
    <span class="nn">loader</span><span class="p">::</span><span class="nf">list_apps</span><span class="p">();</span>
    <span class="nn">task</span><span class="p">::</span><span class="nf">run_tasks</span><span class="p">();</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Unreachable in rust_main!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="32-进程调度机制">3.2 进程调度机制</h3>

<p>进程调度一方面是 CPU 分给当前进程的时间片用尽触发 <code class="language-plaintext highlighter-rouge">SupervisorTimer</code> 中断需要调度， 另一方面是进程主动让出 CPU 的占用权， 都需要用到 <code class="language-plaintext highlighter-rouge">suspend_current_and_run_next</code> 这个函数。 在引入进程的抽象之后， 调度不需要进程本身更新关于 <code class="language-plaintext highlighter-rouge">__switch</code> 函数相关的内容， 只需要获取当前进程的控制块 TCB 并将其加入 task 队列中后使用 <code class="language-plaintext highlighter-rouge">schedule</code> 即可。 这也是前述引入 idle 控制流的好处之一， 对进程调度的解耦让整个代码流都干净了很多。</p>

<h3 id="33-进程的生成机制">3.3 进程的生成机制</h3>

<p>这块相较而言就会显得复杂一些， 在内核中唯一的初始化进程是 <code class="language-plaintext highlighter-rouge">initproc</code>， 后续的进程都需要通过 <code class="language-plaintext highlighter-rouge">fork/exec</code> 这两个系统调用提供的进程生成机制实现。</p>

<ul>
  <li>
    <p><strong>fork</strong></p>

    <p><code class="language-plaintext highlighter-rouge">fork</code> 需要对除了返回值外的父进程所有信息的完全复制， 这甚至要求地址空间的映射方式， 映射页的权限， 映射范围， 以及数据都需要与父进程一致， 不同的是最终映射到的具体的物理地址页 PPN。 在 rCore 中管理这部分信息的是 <code class="language-plaintext highlighter-rouge">memory_set.rs</code>， 为了复制这些信息新增了 <code class="language-plaintext highlighter-rouge">from_another</code> 函数拷贝一个 <strong>逻辑段</strong> 的上述数据。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>
  <span class="k">impl</span> <span class="n">MapArea</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_another</span><span class="p">(</span><span class="n">another</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MapArea</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="o">...</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>这之后真正对整个地址空间进行完全复制的是， <code class="language-plaintext highlighter-rouge">MemorySet</code> 中新增的 <code class="language-plaintext highlighter-rouge">from_existed_user</code> 函数。 该函数将生成一个新的 tranmpoline 并遍历当前用户态虚拟地址空间中所有的逻辑段并拷贝这些数据到目标地址空间。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>
  <span class="k">impl</span> <span class="n">MemorySet</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_existed_user</span><span class="p">(</span><span class="n">user_space</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MemorySet</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MemorySet</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
      <span class="o">...</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>可以看到 <code class="language-plaintext highlighter-rouge">TaskControlBlock::fork</code> 的代码和 <code class="language-plaintext highlighter-rouge">new</code> 基本一致， 只是它的数据来源于它的父进程， 子进程的地址空间通过 <code class="language-plaintext highlighter-rouge">MemorySet::from_existed_user</code> 建立。 另外， <code class="language-plaintext highlighter-rouge">sys_fork</code> 的实现中需要更改 <code class="language-plaintext highlighter-rouge">TrapContext</code> 中的 <code class="language-plaintext highlighter-rouge">a0</code> 寄存器， <code class="language-plaintext highlighter-rouge">trap_handler</code> 部分需要配合做出微调， 以保证能够通过返回值区分子进程和父进程。</p>
  </li>
  <li>
    <p><strong>exec</strong></p>

    <p><code class="language-plaintext highlighter-rouge">exec</code> 系统调用是载入一个新的 ELF 的代码和数据替换当前进程的应用地址空间中的内容并执行。 它要做的事情其实和 <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 也很像， 但我们不需要重新生成进程的 PID 以及分配新的 KernelStack， 这些信息原有的进程已经提供了， 仅需要将我们所需要的 <code class="language-plaintext highlighter-rouge">memory_set</code>， <code class="language-plaintext highlighter-rouge">user_sp</code>， <code class="language-plaintext highlighter-rouge">entry_point</code> 这些信息进行更新即可， 之后我们仅需要完善 <code class="language-plaintext highlighter-rouge">sys_exec</code> 系统调用的实现。</p>

    <p>最为关键的还是 <code class="language-plaintext highlighter-rouge">translated_str</code> 这个函数， <code class="language-plaintext highlighter-rouge">sys_exec</code> 需要对输入的 <code class="language-plaintext highlighter-rouge">path</code> 参数进行解析， 这个 <code class="language-plaintext highlighter-rouge">path</code> 的内容来自应用的虚拟地址空间。 因而 <code class="language-plaintext highlighter-rouge">translated_str</code> 就需要在该应用空间中通过查找 Page Table 的方式逐个拷贝字符串信息到当前 kernel 中的 <code class="language-plaintext highlighter-rouge">string</code> 变量中。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/page_table.rs</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">translated_str</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">page_table</span> <span class="o">=</span> <span class="nn">PageTable</span><span class="p">::</span><span class="nf">from_token</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">va</span> <span class="o">=</span> <span class="n">ptr</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
      <span class="k">loop</span> <span class="p">{</span>
          <span class="k">let</span> <span class="n">ch</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">page_table</span>
              <span class="nf">.translate_va</span><span class="p">(</span><span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">va</span><span class="p">))</span>
              <span class="nf">.unwrap</span><span class="p">()</span>
              <span class="nf">.get_mut</span><span class="p">());</span>
          <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">string</span><span class="nf">.push</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">char</span><span class="p">);</span>
              <span class="n">va</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">string</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p>在 kernel 中获取到了这个应用信息后就能通过 <code class="language-plaintext highlighter-rouge">loader.rs</code> 提供的 <code class="language-plaintext highlighter-rouge">get_app_data_by_name</code> 在指定的内存地址空间加载应用了。</p>
  </li>
  <li>
    <p><strong>read</strong></p>

    <p>最后的 <code class="language-plaintext highlighter-rouge">sys_read</code> 实现还没有涉及到文件系统， 因而需要调用 SBI 提供的接口以获取用户的键盘输入。</p>
  </li>
</ul>

<h3 id="34-进程资源回收机制">3.4 进程资源回收机制</h3>

<p>资源回收涉及到进程的退出， 在此之前 task 中实现此功能的是 <code class="language-plaintext highlighter-rouge">exit_current_and_run_next</code>  函数， 但相比之前的章节， ch5 需要该函数传入一个退出码， 这个退出码会写入到当前进程的进程控制块 TCB 中。 这里比较关键的一步操作是将当前进程的所有子进程的父进程更改为 <code class="language-plaintext highlighter-rouge">INITPROC</code>， 这样当前进程被回收后其子进程仍能被管理而不至于进入一种无法定义的状态。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">exit_current_and_run_next</span><span class="p">(</span><span class="n">exit_code</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// ++++++ access initproc TCB exclusively</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initproc_inner</span> <span class="o">=</span> <span class="n">INITPROC</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">inner</span><span class="py">.children</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">child</span><span class="nf">.inner_exclusive_access</span><span class="p">()</span><span class="py">.parent</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">INITPROC</span><span class="p">));</span>
            <span class="n">initproc_inner</span><span class="py">.children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ++++++ stop exclusively accessing parent PCB</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>父进程的资源回收操作详见 <code class="language-plaintext highlighter-rouge">sys_waitpid</code> 系统调用。</p>

<h2 id="4-修复-syscall">4. 修复 syscall</h2>

<h3 id="41-sys_task_info">4.1 sys_task_info</h3>

<p>该系统调用主要是这几个 <code class="language-plaintext highlighter-rouge">get_*</code> 函数需要对应新的 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 的获取方式， 关键需要注意要用 <code class="language-plaintext highlighter-rouge">current_task</code> 获取当前的进程的 TCB 以免获取进程信息时所有权转移。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">task_info</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
        <span class="n">status</span><span class="p">:</span> <span class="nf">get_current_task_status</span><span class="p">(),</span>
        <span class="n">syscall_times</span><span class="p">:</span> <span class="nf">get_current_task_syscall_times</span><span class="p">(),</span>
        <span class="n">time</span><span class="p">:</span> <span class="nf">get_current_task_time_cost</span><span class="p">(),</span>
    <span class="p">};</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外， 记录内核态和用户态的进程开销需要用到一个 <code class="language-plaintext highlighter-rouge">checkpoint</code> 记录时刻点， 这个变量也要放入 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code>， 通过 <code class="language-plaintext highlighter-rouge">update_checkpoint</code> 函数更新时刻点并获取时间变化量。 不过在 <code class="language-plaintext highlighter-rouge">TaskControlBlock::fork</code> 函数中的初始化和 <code class="language-plaintext highlighter-rouge">TaskControlBlock::new</code> 有所不同， 前者需要将 <code class="language-plaintext highlighter-rouge">checkpoint</code> 的值通过 <code class="language-plaintext highlighter-rouge">get_time_ms</code> 更新为进程创建的时刻点， 否则新的子进程的计时仍会以 OS 运行的第一个程序为起始时刻点， 这样我们无法通过 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 时间相关的测试。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// record time point</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TaskControlBlockInner</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="cd">/// update checkpoint and return the diff time</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_checkpoint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">prev_point</span> <span class="o">=</span> <span class="k">self</span><span class="py">.checkpoint</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.checkpoint</span> <span class="o">=</span> <span class="nf">get_time_ms</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">self</span><span class="py">.checkpoint</span> <span class="o">-</span> <span class="n">prev_point</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 修改就是将其放入了子进程， 不做这个更改应该也不影响最终的结果。 另外 <code class="language-plaintext highlighter-rouge">user_time_start</code> 和 <code class="language-plaintext highlighter-rouge">user_time_end</code> 这一对记录用户态时间开销的函数接口和位置都没有变， <code class="language-plaintext highlighter-rouge">update_task_syscall_times</code> 亦是如此。 更新内核时间开销同样只用在 <code class="language-plaintext highlighter-rouge">exit_current_and_run_next</code> 以及 <code class="language-plaintext highlighter-rouge">suspend_current_and_run_next</code> 这两个临界态函数中调用 <code class="language-plaintext highlighter-rouge">update_checkpoint</code> 更新即可。</p>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/e887b13ad109771da03f97c25b2723425cd9b37f">commit#e887b13</a></p>
</blockquote>

<h3 id="42-sys_mmap-与-sys_munmap">4.2 sys_mmap 与 sys_munmap</h3>

<p>这个比较简单， 只用根据 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 变更后对 <code class="language-plaintext highlighter-rouge">TaskControlBlockInner</code> 的获取方式修改 <code class="language-plaintext highlighter-rouge">get_current_task_page_table</code>， <code class="language-plaintext highlighter-rouge">create_new_map_area</code>， <code class="language-plaintext highlighter-rouge">unmap_consecutive_area</code> 即可。</p>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d8e4b55f2243fe3c5808d23b41a8eccaf28edfe7">commit#d8e4b55</a></p>
</blockquote>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="实现-spawn-系统调用">实现 spawn 系统调用</h4>

<p>这部分实验要求使用 <code class="language-plaintext highlighter-rouge">fork</code> 和 <code class="language-plaintext highlighter-rouge">exec</code>， 但是可以借鉴这二者的写法， <code class="language-plaintext highlighter-rouge">path</code> 部分获取就是模仿 <code class="language-plaintext highlighter-rouge">exec</code> 写的。 实现该系统调用的主要想法是给新的应用数据 <code class="language-plaintext highlighter-rouge">elf_data</code> 建立一个新的进程模块， 这意味着我们需要以 <code class="language-plaintext highlighter-rouge">exec</code> 的角度去改编 <code class="language-plaintext highlighter-rouge">fork</code>。 一直到 <code class="language-plaintext highlighter-rouge">TrapContext</code> 这部分， 前面的内容和 <code class="language-plaintext highlighter-rouge">fork</code> 基本一致， 但是我们需要运行一个新的应用， 因而不能像 <code class="language-plaintext highlighter-rouge">fork</code> 那样沿用与其父进程一致的配置， 而需要创建一个全新的 <code class="language-plaintext highlighter-rouge">TrapContext</code> 以容纳 <code class="language-plaintext highlighter-rouge">entry_point</code>， <code class="language-plaintext highlighter-rouge">user_sp</code>， <code class="language-plaintext highlighter-rouge">kernel_stack_top</code> 这几个依托当前应用数据生成的信息。 最后也是最关键的， 我们需要返回子进程的 pid， 并且将这个子进程的进程控制模块加入到 task 队列中， 以使得操作系统能够分配资源执行该应用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// HINT: fork + exec =/= spawn</span>
<span class="cd">/// ALERT: Don't fork parent process address space</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_spawn</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nf">current_task</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">parent_inner</span> <span class="o">=</span> <span class="n">task</span><span class="nf">.inner_exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">parent_inner</span><span class="py">.memory_set</span><span class="nf">.token</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nf">translated_str</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">elf_data</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_app_data_by_name</span><span class="p">(</span><span class="n">path</span><span class="nf">.as_str</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">memory_set</span><span class="p">,</span> <span class="n">user_sp</span><span class="p">,</span> <span class="n">entry_point</span><span class="p">)</span> <span class="o">=</span> <span class="nn">MemorySet</span><span class="p">::</span><span class="nf">from_elf</span><span class="p">(</span><span class="n">elf_data</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">trap_cx_ppn</span> <span class="o">=</span> <span class="n">memory_set</span>
            <span class="nf">.translate</span><span class="p">(</span><span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">TRAP_CONTEXT_BASE</span><span class="p">)</span><span class="nf">.into</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.ppn</span><span class="p">();</span>
        <span class="c1">// alloc a pid and a kernel stack in kernel space</span>
        <span class="k">let</span> <span class="n">pid_handle</span> <span class="o">=</span> <span class="nf">pid_alloc</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">kernel_stack</span> <span class="o">=</span> <span class="nn">KernelStack</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid_handle</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">kernel_stack_top</span> <span class="o">=</span> <span class="n">kernel_stack</span><span class="nf">.get_top</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task_control_block</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">TaskControlBlock</span> <span class="p">{</span>
            <span class="n">pid</span><span class="p">:</span> <span class="n">pid_handle</span><span class="p">,</span>
            <span class="n">kernel_stack</span><span class="p">,</span>
            <span class="n">inner</span><span class="p">:</span> <span class="k">unsafe</span> <span class="p">{</span>
                <span class="nn">UPSafeCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">TaskControlBlockInner</span> <span class="p">{</span>
                    <span class="n">task_status</span><span class="p">:</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span><span class="p">,</span>
                    <span class="n">task_cx</span><span class="p">:</span> <span class="nn">TaskContext</span><span class="p">::</span><span class="nf">goto_trap_return</span><span class="p">(</span><span class="n">kernel_stack_top</span><span class="p">),</span>
                    <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
                    <span class="n">user_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">kernel_time</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">checkpoint</span><span class="p">:</span> <span class="nf">get_time_ms</span><span class="p">(),</span> <span class="c1">// give the new process a new start point</span>
                    <span class="n">memory_set</span><span class="p">,</span>
                    <span class="n">trap_cx_ppn</span><span class="p">,</span>
                    <span class="n">base_size</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.base_size</span><span class="p">,</span>
                    <span class="n">heap_bottom</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.heap_bottom</span><span class="p">,</span>
                    <span class="n">program_brk</span><span class="p">:</span> <span class="n">parent_inner</span><span class="py">.program_brk</span><span class="p">,</span>
                    <span class="n">parent</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="p">)),</span>
                    <span class="n">children</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                    <span class="n">exit_code</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">})</span>
            <span class="p">},</span>
        <span class="p">});</span>
        <span class="c1">// add child</span>
        <span class="n">parent_inner</span><span class="py">.children</span><span class="nf">.push</span><span class="p">(</span><span class="n">task_control_block</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="c1">// prepare TrapContext in user space</span>
        <span class="k">let</span> <span class="n">trap_cx</span> <span class="o">=</span> <span class="n">task_control_block</span><span class="nf">.inner_exclusive_access</span><span class="p">()</span><span class="nf">.get_trap_cx</span><span class="p">();</span>
        <span class="o">*</span><span class="n">trap_cx</span> <span class="o">=</span> <span class="nn">TrapContext</span><span class="p">::</span><span class="nf">app_init_context</span><span class="p">(</span>
            <span class="n">entry_point</span><span class="p">,</span>
            <span class="n">user_sp</span><span class="p">,</span>
            <span class="n">KERNEL_SPACE</span><span class="nf">.exclusive_access</span><span class="p">()</span><span class="nf">.token</span><span class="p">(),</span>
            <span class="n">kernel_stack_top</span><span class="p">,</span>
            <span class="n">trap_handler</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">task_control_block</span><span class="py">.pid</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
        <span class="nf">add_task</span><span class="p">(</span><span class="n">task_control_block</span><span class="p">);</span>
        <span class="n">pid</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/74015ec9fd1e41526fe855d4d9744f59657d9d85">commit#74015ec</a></p>
</blockquote>

<h4 id="stride-调度算法">stride 调度算法</h4>

<p>stride 调度需要存储两个变量， 一个是 <code class="language-plaintext highlighter-rouge">stride</code>， 表示当前的进程已经运行的 “长度”， 这个长度是以 <code class="language-plaintext highlighter-rouge">pass</code> 为单位进行更新的。 那么第二个变量就是 <code class="language-plaintext highlighter-rouge">priority</code>， 表示调度的优先级， 于是有公式成立：</p>

\[pass = BIG\_STRIDE/priority\]

<p>其中 <code class="language-plaintext highlighter-rouge">BIG_STRIDE</code> 被定义为一个预定义的极大常数， 则该调度方案为每个进程分配的时间将与其优先级成正比。 实验中对这些变量还有以下的规约：</p>

<ul>
  <li>stride 调度要求进程优先级 \(\ge{2}\) ，所以设定进程优先级 \(\le{1}\) 会导致错误。</li>
  <li>进程初始 stride 设置为 0。</li>
  <li>进程初始优先级设置为 16。</li>
</ul>

<p>由于 priority \(\ge\) 2， 因而 pass \(\le\) BIG_STRIDE/2， 在不考虑溢出的情况下，  <code class="language-plaintext highlighter-rouge">STRIDE_MAX – STRIDE_MIN ≤ BigStride / 2</code>， 始终成立， 这一点用反证法可以证明。 但现实中必然需要考虑溢出， 那么这里可以利用符号整数的特性， 避免在溢出后某些本应延后调度的进程因为 <code class="language-plaintext highlighter-rouge">stride</code> 值溢出后从小值开始的缘故被优先调度。 所以， 可以将 <code class="language-plaintext highlighter-rouge">BIG_STRIDE</code> 设置为 <code class="language-plaintext highlighter-rouge">u64</code> 类型最大值， 结合 <code class="language-plaintext highlighter-rouge">STRIDE_MAX – STRIDE_MIN ≤ BigStride / 2</code> 亦会有 <code class="language-plaintext highlighter-rouge">STRIDE_MIN – STRIDE_STRIDE &gt;= -BigStride / 2</code>， 这个与 <code class="language-plaintext highlighter-rouge">i64</code> 的表示方式非常相似， 因而可以这样设计 stride 的比较方式：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>

<span class="k">struct</span> <span class="nf">Stride</span><span class="p">(</span><span class="nb">u64</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">Stride</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">i64</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">other</span><span class="na">.0</span> <span class="k">as</span> <span class="nb">i64</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Stride</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我自己尝试了去实现 BinaryHeap 进行调度， 但是程序会卡死在 initproc 中， 作为一个 Rust 新手以及确实很久没接触算法了， 不知道什么地方除了问题， 于是就用了最简单的思路， 在每次 <code class="language-plaintext highlighter-rouge">fetch</code> 下一个 task 之前对这个队列中的 task 做检查， 找到最小的 stride。 这里每次将初始最小值设定为 <code class="language-plaintext highlighter-rouge">0x7FFF_FFFF</code> 是为了解决前述的溢出问题， 本质上利用有符号整数的思想就是把大于 <code class="language-plaintext highlighter-rouge">MAX/2</code> 等价为负数。 这样 TIPs 中说明的 <em>使用 8 bits 存储 stride, BIG_STRIDE = 255, 则: <code class="language-plaintext highlighter-rouge">(125 &lt; 255) == false</code>, <code class="language-plaintext highlighter-rouge">(129 &lt; 255) == true</code></em> 就好理解了。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/manager.rs</span>
<span class="cd">/// A simple FIFO scheduler.</span>
<span class="k">impl</span> <span class="n">TaskManager</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="cd">/// Take a process out of the ready queue</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">TaskControlBlock</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">min_stride</span> <span class="o">=</span> <span class="mi">0x7FFF_FFFF</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">inner</span><span class="nf">.get_status</span><span class="p">()</span> <span class="o">==</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">inner</span><span class="py">.stride</span> <span class="o">&lt;</span> <span class="n">min_stride</span> <span class="p">{</span>
                    <span class="n">min_stride</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.stride</span><span class="p">;</span>
                    <span class="n">min_index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.get</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">task</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
            <span class="n">inner</span><span class="py">.stride</span> <span class="o">+=</span> <span class="n">BIG_STRIDE</span> <span class="o">/</span> <span class="n">inner</span><span class="py">.priority</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.ready_queue</span><span class="nf">.remove</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5abe01a7d69f4f0486888c78acf065e4ee296989">commit#5abe01a</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第五章：进程， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 4</title><link href="https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 4" /><published>2023-07-04T00:00:00+08:00</published><updated>2023-07-04T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/04/rcore-note-ch4</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html"><![CDATA[<p>该章节是目前最复杂的一个章节， 涉及到操作系统的内存管理的策略和方法。 在 <code class="language-plaintext highlighter-rouge">no_std</code> 裸机环境下， rCore 使用 <code class="language-plaintext highlighter-rouge">buddy_system_allocator</code> 为需要动态内存分配的数据结构提供 <code class="language-plaintext highlighter-rouge">Global Allocator</code>。 该章节的主要目的就是实现一个 <strong>地址空间（Address Space）</strong> 抽象， 并在内核中建立虚实地址空间的映射机制， 给应用程序提供一个基于地址空间的安全虚拟内存环境并灵活使用内存。</p>

<p>现代计算机基本使用 <strong>分页内存管理</strong>， 以使得内核始终以一个固定的极小单位管理应用数据， 这既能利用插槽式的简单的内存分配算法避免生成 <strong>内存外碎片</strong>， 又能使未使用的 <strong>内存内碎片</strong> 尽可能小以提高内存的使用率。 关于内存地址映射个人觉得 rCore 讲的比较啰嗦， MIT 的 xv6 的教材很简略但很容易理解可以先阅读 <a href="https://pdos.csail.mit.edu/6.1810/2022/xv6/book-riscv-rev3.pdf">xv6 book - Page tables</a> 建立相关概念再阅读 rCore 的教材。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/addr-space-os-detail.png" alt="Address Space OS details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Address Space OS Details, rCore</u></font>
</div>

<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第四章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch4">[ch4]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<h2 id="1-sv39-多级页表的机制">1. Sv39 多级页表的机制</h2>

<div align="center">
    <a id="translation-details"></a>
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/address-translation.png" alt="RISC-V address translation details, MIT xv6" width="600" />
    <br />
    <font size="2" color="#999"><u>RISC-V address translation details, MIT xv6</u></font>
</div>

<p>rCore 和 xv6 都使用了 Sv39 模式， 这意味着 64-bit 的 <strong>VA (Virtual Address)</strong> 仅有低端的 39 bits 是被使用的。 而这 39 位又被划分为两部分， 被称为 <strong>VPN (Virtual Page Number)</strong> 的高 27 位用于索引 <strong>PTE (Page Table Entry)</strong>， PTE 是存放在每个应用的 Page Table 中， 由 44 位的 <strong>PPN (Physical Page Number)</strong>  与 10 位标志位组成， 这 PTE 实际构成了虚拟地址与物理地址的索引关系。 另外低 12 位是表示页内的偏移量， 这是因为我们使用 <strong>分页内存管理</strong>， 最小的内存单位是 <em>页</em>， 这低 12 位最终会与 PPN 组合成为实际的 56 位物理地址。</p>

<blockquote>
  <p>需要明确的是 \(One Page: 2^{12} = 4096\)， 因而虚拟地址的低 12 位才被称作是页内的偏移量， 因为 12 位正好构成了一个页的大小。</p>
</blockquote>

<p>上图描述了三级页表的查询方式， Sv48 可以使用四级页表， 具体的设计依具体情况而定。 多级页表的构建是为了节省内存开销， 我们只需要按需增添 PTE。 我们可以通过三级页表进行逐级索引， 依据上图由 <em>L2</em> 的 512 个一级页表可以索引， <em>L1</em> 的 \(512\times{512}\) 个二级页表， 这样的开销会比直接映射的页表小得多。 例如我们当前仅需要建立一个地址映射， 那么只需要各使用 <em>L2</em>， <em>L1</em>， <em>L0</em> 三级页表中的一个 PTE， 我们节省了 511 个 <em>L1</em> PTE， \(511\times{512}\) 个 <em>L0</em> PTE。</p>

<p>如果每个地址映射都需要经历三级查表效率肯定会低， 因而 MMU 会提供 <strong>TLB (Translation Look-Aside Buffer)</strong> 缓存来加快映射查询， 但需要注意的是， 映射关系发生改变后缓存就失效了， 我们需要通过 <code class="language-plaintext highlighter-rouge">sfence.vma</code> 指令刷新 TLB。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/page-table.png" alt="Translation process, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Translation process, rCore</u></font>
</div>

<p>在 rCore 中， 虚拟地址 <strong>(VA, Virtual Address)</strong> 中的最小单位被称为 <em>Page</em>， 其对应的物理地址 <strong>(PA, Physical Address)</strong> 中的最小单位被称为 <em>Frame</em>， 这二者的关系可以从上图可以窥见一斑， 二者大小一样都是 4096 Bytes。</p>

<h2 id="2-sv39-分页管理设计">2. Sv39 分页管理设计</h2>

<h3 id="21-frame-allocator---物理页帧管理">2.1 frame allocator - 物理页帧管理</h3>

<p>rCore 中内核直接管理了虚拟内存和物理内存。 <em>Frame</em> 所在的空间位于 <code class="language-plaintext highlighter-rouge">ekernel</code> 与 <code class="language-plaintext highlighter-rouge">MEMORY_END</code> 之间。 rCore 使用 <code class="language-plaintext highlighter-rouge">struct StackFrameAllocator</code> 实现 <strong>FRAME_ALLOCATOR</strong>， 并开放给其他内核模块两个用以分配和回收物理地址 <em>frame</em> 的接口： <code class="language-plaintext highlighter-rouge">frame_alloc</code> 以及 <code class="language-plaintext highlighter-rouge">frame_dealloc</code>。 值得注意的是 <code class="language-plaintext highlighter-rouge">frame_alloc</code> 返回的类型是封装 <code class="language-plaintext highlighter-rouge">PhysPageNum</code> 的 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 类型， 该类型实现了 <code class="language-plaintext highlighter-rouge">Drop</code> Trait， 这是一种 RAII 的思想， 当 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 的声明周期结束， 其包裹的 <code class="language-plaintext highlighter-rouge">PhysPageNum</code> 能通过编译器自动回收到 <code class="language-plaintext highlighter-rouge">FRAME_ALLOCATOR</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/frame_allocator.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FrameTracker</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FrameTracker</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">frame_dealloc</span><span class="p">(</span><span class="k">self</span><span class="py">.ppn</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><b>内核访问物理页帧</b></p>

<p>为了让内核能访问实际的物理地址， rCore 设计了三种粒度的访问方式： 基于 PTE， 基于 Bytes， 基于变量类型。 至此， 物理地址空间的分配以及访问的框架已经建成， 后续需要做的就是构建虚拟地址与物理地址映射的 <strong>页表(Page Table)</strong>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/address.rs</span>

<span class="k">impl</span> <span class="n">PhysPageNum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_pte_array</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="n">PageTableEntry</span><span class="p">];</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_bytes_array</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">];</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="22-page-table---映射表构建">2.2 Page Table - 映射表构建</h3>

<p>构建页表的基本单元就是 <strong>PTE(Page Table Entry)</strong>， 这里有个关键概念需要澄清， 页表的存储位置。 其实从 xv6 的那张 <a href="#translation-details"><em>RISC-V address translation details, MIT xv6</em></a> 也可以看出， 通过索引从 <em>Lx</em> 定位到的 PPN 会指向下一级 Page Table， 这意味着 Page Table 实际上也是存储在具体的物理页帧上的， 并且每个 PTE 对应唯一的一个 PPN。 因而 rCore 对 Page Table 的数据结构的设计就包括了定位 Page Table 的 <code class="language-plaintext highlighter-rouge">root_ppn</code> 以及 Page Table 中包含的各个 PTE 项 <code class="language-plaintext highlighter-rouge">frames</code>。</p>

<blockquote>
  <p>估计是为了让 <code class="language-plaintext highlighter-rouge">root_ppn</code> 和 <code class="language-plaintext highlighter-rouge">frames</code> 的指向和含义统一才把 PTE 命名为 frame， 个人感觉直接用 PTE 会清晰很多。 这里 rCore 又提及 RAII 的思想， <code class="language-plaintext highlighter-rouge">frames</code> 内部变量通过 <code class="language-plaintext highlighter-rouge">Vec</code> 数据结构绑定 <code class="language-plaintext highlighter-rouge">FrameTracker</code>， 可以保证声明周期结束后对 <code class="language-plaintext highlighter-rouge">FrameTracker</code> 的内存自动回收。</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="n">root_ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span>
    <span class="n">frames</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">FrameTracker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就不难理解 <code class="language-plaintext highlighter-rouge">struct PageTable</code> 初始化的流程了， 每个 Page Table 都需要向 frame allocator 先申请一个物理页帧将其 PPN 作为 <code class="language-plaintext highlighter-rouge">root_ppn</code> 唯一标识。</p>

<h3 id="23-建立-va-与-pa-的映射关系">2.3 建立 VA 与 PA 的映射关系</h3>

<p>Page Table 必然是动态变化的， 程序运行的时候会通过 <code class="language-plaintext highlighter-rouge">Page Fault</code> Trap 来实现对内存页的按需分配。 当我们知道虚拟地址空间的某个 VA 的时候， 需要通过前述的 Page Table 找到或建立一个关于物理页帧映射。 Xv6 中是通过 <code class="language-plaintext highlighter-rouge">walk</code> 函数实现的， rCore 提供了两个基础函数 <code class="language-plaintext highlighter-rouge">find_pte_create</code> 以及 <code class="language-plaintext highlighter-rouge">find_pte</code>， 区别就在于是否在某一级页表的 PTE 未创建时创建一个新的 PTE。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/address.rs</span>

<span class="k">impl</span> <span class="n">VirtPageNum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">indexes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">vpn</span> <span class="o">=</span> <span class="k">self</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0usize</span><span class="p">;</span> <span class="mi">3</span><span class="p">];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vpn</span> <span class="o">&amp;</span> <span class="mi">511</span><span class="p">;</span>
            <span class="n">vpn</span> <span class="o">&gt;&gt;=</span> <span class="mi">9</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">idx</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">find_pte_create</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">find_pte</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">PageTableEntry</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>rCore 通过 <code class="language-plaintext highlighter-rouge">indexes</code> 解析 VPN (Virtual Page Number)， 找到三级页表每一级中的 leaf PTE 的索引号。 这里会用到 PTE 中的 Flags 部分的信息。 标志位 <code class="language-plaintext highlighter-rouge">V</code> 表示当前的 PTE 为合法有效的， 在建立新的 PTE 的时候需要更新该标志位， 否则会引起 Page Fault。 基于这几个函数， rCore 封装了两个更便利的函数方便 Page Table 的维护， 用 <code class="language-plaintext highlighter-rouge">map/unmap</code> 为当前的 Page Table 增加或删除 PTE。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/page_table.rs</span>

<span class="k">impl</span> <span class="n">PageTable</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">,</span> <span class="n">ppn</span><span class="p">:</span> <span class="n">PhysPageNum</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="n">PTEFlags</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pte</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_pte_create</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">(),</span> <span class="s">"vpn {:?} is mapped before mapping"</span><span class="p">,</span> <span class="n">vpn</span><span class="p">);</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nn">PageTableEntry</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ppn</span><span class="p">,</span> <span class="n">flags</span> <span class="p">|</span> <span class="nn">PTEFlags</span><span class="p">::</span><span class="n">V</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unmap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pte</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_pte</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">(),</span> <span class="s">"vpn {:?} is invalid before unmapping"</span><span class="p">,</span> <span class="n">vpn</span><span class="p">);</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nn">PageTableEntry</span><span class="p">::</span><span class="nf">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>手动页表查询</strong>： Page Table 还实现了两个特殊的函数模仿 MMU 获取 Page Table。 <code class="language-plaintext highlighter-rouge">from_token</code> 直接读取 <code class="language-plaintext highlighter-rouge">satp</code> 寄存器中的 PPN 段获取一个 Page Table， 之后就能直接通过 <code class="language-plaintext highlighter-rouge">translate</code> 函数得到 VPN 对应的第三级的 PTE。</p>
</blockquote>

<h2 id="3-地址空间与抽象">3. 地址空间与抽象</h2>

<p>rCore 抽象了两种概念来管理整个虚拟内存及其映射的物理内存。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/addr-space-abstract.png" alt="Address space abstraction, HangX-Ma" width="600" />
    <br />
    <font size="2" color="#999"><u>Address space abstraction, HangX-Ma</u></font>
</div>

<ul>
  <li>
    <p><strong>逻辑段： 一段连续地址的虚拟内存</strong></p>

    <p>rCore 使用 <code class="language-plaintext highlighter-rouge">sruct MapArea</code> 表示逻辑段。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">vpn_range</code> 表明该逻辑段的在虚拟地址的范围以及长度；</li>
      <li><code class="language-plaintext highlighter-rouge">map_type</code> 则表示了虚拟地址和物理地址的映射办法， 直接映射 （<code class="language-plaintext highlighter-rouge">MapType::Identical</code>） 又或是通过 <strong>FRAME_ALLOCATOR</strong> 随机分配物理帧 （<code class="language-plaintext highlighter-rouge">MapType::Framed</code>） （外设地址都是直接映射的， 这样区分有助于后续的应用拓展）；</li>
      <li>既然区分了映射方式， 存储映射关系的数据结构也会不同， <code class="language-plaintext highlighter-rouge">data_frames</code> 用于存储 leaf PTE 的 PPN 与其对应的 VPN 之间的关系， 仅用在 <code class="language-plaintext highlighter-rouge">Framed</code> 映射办法。</li>
      <li>
        <p>最后的 <code class="language-plaintext highlighter-rouge">map_perm</code> 其实就和 Linux 系统的 RWXU 的含义基本接近了。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/mm/memory_set.rs</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">MapArea</span> <span class="p">{</span>
    <span class="n">vpn_range</span><span class="p">:</span> <span class="n">VPNRange</span><span class="p">,</span>
    <span class="n">data_frames</span><span class="p">:</span> <span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">VirtPageNum</span><span class="p">,</span> <span class="n">FrameTracker</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">map_type</span><span class="p">:</span> <span class="n">MapType</span><span class="p">,</span>
    <span class="n">map_perm</span><span class="p">:</span> <span class="n">MapPermission</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>地址空间：一系列有关联的逻辑段</strong></p>

    <p>rCore 通过 <code class="language-plaintext highlighter-rouge">struct MemorySet</code> 封装这些逻辑段， 这是因为虽然逻辑段本身是连续的一段虚拟地址， 但多个逻辑段之间可能并不是连续的。 注意这里的 <code class="language-plaintext highlighter-rouge">page_table</code> 是一个 <em>Root Page Table</em>， 包含了该所有的 PTE 的物理页帧， 而 <code class="language-plaintext highlighter-rouge">areas</code> 则包含了数据所在的物理页帧， 这样的的设计构成了一个地址空间所需的所有的物理页帧。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/mm/memory_set.rs</span>

  <span class="k">pub</span> <span class="k">struct</span> <span class="n">MemorySet</span> <span class="p">{</span>
      <span class="n">page_table</span><span class="p">:</span> <span class="n">PageTable</span><span class="p">,</span>
      <span class="n">areas</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">MapArea</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="31-内核地址空间">3.1 内核地址空间</h3>

<p>Sv39 规定 64 位虚拟地址的 [63:39] 这 25 位必须和第 38 位相同， 否则 MMU 会直接认定它是一个不合法的虚拟地址。 因而虚拟地址空间可以被划分为低地址的 \(2^{39}\) bytes (512 GB)， 以及当第 38 位为 1 时的 512 GB， 分别称为 <em>High Half</em> 以及 <em>Low Half</em>。 rCore 设计的内核空间如下图所示。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/kernel-as-high.png" alt="Kernel address space high half, rCore" width="400" />
    <br />
    <font size="2" color="#999"><u>Kernel address space high half, rCore</u></font>
</div>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/kernel-as-low.png" alt="Kernel address space low half, rCore" width="300" />
    <br />
    <font size="2" color="#999"><u>Kernel address space low half, rCore</u></font>
</div>

<h3 id="32-应用地址空间">3.2 应用地址空间</h3>

<p>rCore 设计的内核空间如下图所示， 具体含义和解释见 rCore Tutorial 相关章节的内容。 需要注意的是， 几个具有不同访问权限的逻辑段之间需要通过页面对齐进行限制与区分。</p>

<div align="center">
    <img src="/norobots/images/2023-07-04-rcore-note-ch4/app-as-full.png" alt="Application address space, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Application address space, rCore</u></font>
</div>

<h2 id="4-基于地址空间的分时多任务">4. 基于地址空间的分时多任务</h2>

<h3 id="41-trampoline">4.1 Trampoline</h3>

<p><strong>Trampoline</strong> 部分的代码是由原来的 <code class="language-plaintext highlighter-rouge">trap.S</code> 更改得到的， 其特殊之处在于 Kernel 以及 App 的地址空间的同一位置都有这一段数据， 并且被映射到同一个存放该段代码的物理页帧。 这种设计保证内核态和用户态的虚拟地址空间的切换使用的映射方式相同， 保证这段切换地址空间的指令控制流可以平滑执行。 为方便实现， rCore 直接在多级页表中插入了对 trampoline 的映射而不是新增一个逻辑段。</p>

<p>另外这里提到了虚拟地址空间的切换， 这是 trampoline 命名的由来以及其需要解决的问题。 由于 RISC-V 仅提供了一个 <code class="language-plaintext highlighter-rouge">sscratch</code> 寄存器用以周转数据， 但开启虚拟映射后， 应用地址空间切换到内核应用空间需要用到 <code class="language-plaintext highlighter-rouge">satp</code> 寄存器， 我们无法通过一个寄存器完成 <code class="language-plaintext highlighter-rouge">satp</code> 与 <code class="language-plaintext highlighter-rouge">sp</code> 两个寄存器信息的流转。 因而， 比较合适的办法就是将应用的 <code class="language-plaintext highlighter-rouge">Trap Context</code> 保存在每个应用的用户态虚拟地址空间的 High Half， 紧贴着 Trampoline。</p>

<h3 id="42-改进-syscall">4.2 改进 syscall</h3>

<p>rCore 的手册更改了 <code class="language-plaintext highlighter-rouge">sys_write</code> 系统调用， 通过 <code class="language-plaintext highlighter-rouge">translated_byte_buffer</code> 在内核空间中开辟了一个可以访问应用数据的区域（实际上是将应用数据从用户态虚拟地址空间拷贝到了内核态虚拟地址空间以供内核访问）。 相应的， 前述章节需要访问应用态数据的系统调用均需要通过这种间接的方式进行数据的访问与更改。 这也就是 <code class="language-plaintext highlighter-rouge">sys_get_time</code> 以及 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 在第四章失效的原因。</p>

<h2 id="5-课后练习">5. 课后练习</h2>

<h3 id="51-编程练习">5.1 编程练习</h3>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TODO: 这部分回头再说</li>
</ul>

<h3 id="52-实验练习">5.2 实验练习</h3>

<h4 id="重写-sys_get_time-和-sys_task_info">重写 <em>sys_get_time</em> 和 <em>sys_task_info</em></h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_get_time</span><span class="p">(</span><span class="n">ts</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TimeVal</span><span class="p">,</span> <span class="n">_tz</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">us</span> <span class="o">=</span> <span class="nf">get_time_us</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">dst_vec</span> <span class="o">=</span> <span class="nf">translated_byte_buffer</span><span class="p">(</span>
        <span class="nf">current_user_token</span><span class="p">(),</span>
        <span class="n">ts</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TimeVal</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">time_val</span> <span class="o">=</span> <span class="n">TimeVal</span> <span class="p">{</span>
            <span class="n">sec</span><span class="p">:</span> <span class="n">us</span> <span class="o">/</span> <span class="mi">1_000_000</span><span class="p">,</span>
            <span class="n">usec</span><span class="p">:</span> <span class="n">us</span> <span class="o">%</span> <span class="mi">1_000_000</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">src_ptr</span> <span class="o">=</span> <span class="n">time_val</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TimeVal</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">in</span> <span class="n">dst_vec</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit_len</span> <span class="o">=</span> <span class="n">dst</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">dst</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="nn">core</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span>
                <span class="n">src_ptr</span><span class="nf">.wrapping_byte_add</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">unit_len</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span>
                <span class="n">unit_len</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">dst_vec</span> <span class="o">=</span> <span class="nf">translated_byte_buffer</span><span class="p">(</span>
        <span class="nf">current_user_token</span><span class="p">(),</span>
        <span class="n">ti</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nn">core</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="k">ref</span> <span class="n">task_info</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
        <span class="n">status</span><span class="p">:</span> <span class="nf">get_current_task_status</span><span class="p">(),</span>
        <span class="n">syscall_times</span><span class="p">:</span> <span class="nf">get_current_task_syscall_times</span><span class="p">(),</span>
        <span class="n">time</span><span class="p">:</span> <span class="nf">get_current_task_time_cost</span><span class="p">(),</span>
    <span class="p">};</span>
    <span class="c1">// println!("[kernel]: time {} syscall_time {}", task_info.time, task_info.syscall_times[super::SYSCALL_GET_TIME]);</span>
    <span class="k">let</span> <span class="n">src_ptr</span> <span class="o">=</span> <span class="n">task_info</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskInfo</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span> <span class="k">in</span> <span class="n">dst_vec</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit_len</span> <span class="o">=</span> <span class="n">dst</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="n">dst</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="nn">core</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_raw_parts</span><span class="p">(</span>
                <span class="n">src_ptr</span><span class="nf">.wrapping_byte_add</span><span class="p">(</span><span class="n">idx</span> <span class="o">*</span> <span class="n">unit_len</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span>
                <span class="n">unit_len</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/b1ac23ab6103d75398e859fe68df01789950cf0e">commit#b1ac23a</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/db314555940997712b4afba2c19ce41c5c8c26ed">commit#db31455</a></p>
</blockquote>

<h4 id="mmap-和-munmap-匿名映射"><em>mmap</em> 和 <em>munmap</em> 匿名映射</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>

<span class="cd">/// port: page permission [2:0] X|W|R</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_mmap</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span> <span class="cm">/* start need to be page aligned */</span> <span class="p">||</span> 
        <span class="n">port</span> <span class="o">&amp;</span> <span class="o">!</span><span class="mi">0x7</span> <span class="o">!=</span> <span class="mi">0</span> <span class="cm">/* other bits of port needs to be zero */</span> <span class="p">||</span>
        <span class="n">port</span> <span class="o">&amp;</span> <span class="mi">0x7</span> <span class="o">==</span><span class="mi">0</span> <span class="cm">/* No permission set, meaningless */</span> <span class="p">||</span>
        <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span> <span class="cm">/* mapping range should be an legal address */</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// check the range [start, start + len)</span>
    <span class="k">let</span> <span class="n">start_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="nf">.floor</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">end_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">vpns</span> <span class="o">=</span> <span class="nn">VPNRange</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start_vpn</span><span class="p">,</span> <span class="n">end_vpn</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">vpn</span> <span class="k">in</span> <span class="n">vpns</span> <span class="p">{</span>
       <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_current_task_page_table</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// we find a pte that has been mapped</span>
            <span class="k">if</span> <span class="n">pte</span><span class="nf">.is_valid</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// all ptes in range has pass the test</span>
    <span class="nf">create_new_map_area</span><span class="p">(</span>
        <span class="n">start_vpn</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="n">end_vpn</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="nn">MapPermission</span><span class="p">::</span><span class="nf">from_bits_truncate</span><span class="p">((</span><span class="n">port</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">|</span> <span class="nn">MapPermission</span><span class="p">::</span><span class="n">U</span>
    <span class="p">);</span>
    <span class="mi">0</span>
<span class="p">}</span>


<span class="cd">/// munmap the mapped virtual addresses</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_munmap</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">MAXVA</span> <span class="p">||</span> <span class="n">start</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// avoid undefined situation</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">MAXVA</span> <span class="o">-</span> <span class="n">len</span> <span class="p">{</span>
        <span class="n">mlen</span> <span class="o">=</span> <span class="n">MAXVA</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">unmap_consecutive_area</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">mlen</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>

<span class="c1">//* ch4-lab2, mmap, munmap</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_current_task_page_table</span><span class="p">(</span><span class="n">vpn</span><span class="p">:</span> <span class="n">VirtPageNum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PageTableEntry</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.translate</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_new_map_area</span><span class="p">(</span><span class="n">start_va</span><span class="p">:</span> <span class="n">VirtAddr</span><span class="p">,</span> <span class="n">end_va</span><span class="p">:</span> <span class="n">VirtAddr</span><span class="p">,</span> <span class="n">perm</span><span class="p">:</span> <span class="n">MapPermission</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.insert_framed_area</span><span class="p">(</span><span class="n">start_va</span><span class="p">,</span> <span class="n">end_va</span><span class="p">,</span> <span class="n">perm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">unmap_consecutive_area</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">start_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="nf">.floor</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">end_vpn</span> <span class="o">=</span> <span class="nn">VirtAddr</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">vpns</span> <span class="o">=</span> <span class="nn">VPNRange</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start_vpn</span><span class="p">,</span> <span class="n">end_vpn</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">vpn</span> <span class="k">in</span> <span class="n">vpns</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.translate</span><span class="p">(</span><span class="n">vpn</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">pte</span><span class="nf">.is_valid</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.memory_set</span><span class="nf">.get_page_table</span><span class="p">()</span><span class="nf">.unmap</span><span class="p">(</span><span class="n">vpn</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Also unmapped if no PTE found</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5e57b472225f7d037535038ba6c037e9566cfeb3">commit#5e57b47</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/165bda860fb29ab4c3af68e308b3f82080825031">commit#165bda8</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第四章：地址空间， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">rCore OS Note - Chapter 3</title><link href="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html" rel="alternate" type="text/html" title="rCore OS Note - Chapter 3" /><published>2023-07-01T00:00:00+08:00</published><updated>2023-07-01T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/07/01/rcore-note-ch3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/07/01/rcore-note-ch3.html"><![CDATA[<h2 id="0-资料汇总">0. 资料汇总</h2>

<ul>
  <li><strong>RISC-V</strong>
    <ul>
      <li><a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">RISC-V ELF psABI</a>: Processor-specific application binary interface document.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-sbi-doc">RISC-V Supervisor Binary Interface</a>: Spec for SBI.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-c-api-doc">RISC-V C API</a>: RISC-V-specific predefined macros, function attributes and language extensions.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual">RISC-V Assembly Programmer’s Manual</a>: Document for pseudoinstructions and assembly directives.</li>
      <li><a href="https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications">RISC-V Specifications</a>:
        <ul>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">Unprivileged Specification version 20191213</a></li>
          <li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">Privileged Specification version 20211203</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/riscv/riscv-aclint">RISC-V ACLINT specification</a>: ACLINT (Advanced Core Local Interruptor) specification defines a set of memory mapped devices which provide inter-processor interrupt and timer functionality for each HART of a multi-HART (or multi-processor) RISC-V platform.</li>
      <li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a>: Provide guidance to assembly programmers targeting the standard RISC-V assembly language.</li>
    </ul>
  </li>
  <li><strong>rCore</strong>
    <ul>
      <li>rCore 第三章相关内容的实现记录在 Github Tag: <a href="https://github.com/HangX-Ma/rCore-sp23/tree/ch3">[ch3]</a></li>
      <li>rCore source code of labs for spring 2023: <a href="https://github.com/LearningOS/rCore-Tutorial-Guide-2023S">rCore-Tutorial-Guide-2023S Source Code</a></li>
      <li>rCore Concise Manual: <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/">rCore-Tutorial-Guide-2023S</a></li>
      <li>rCore Detail Book: <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/">rCore-Tutorial-Book-v3</a></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>隔了这么就才整到第三章， 毕竟最近杂活儿有点多， 另外第二章的编程题也是安排很不合理， 把后面的内容提前扔给读者结果第三章实验部分要推倒重来太浪费时间了。 更新这章的 OS 框架的时候变动的地方有些多， 尤其是 <code class="language-plaintext highlighter-rouge">Makefile</code> 部分以及 <code class="language-plaintext highlighter-rouge">build.rs</code> 部分和 <em>rCore-Tutorial-Guide-2023S</em> 中进行了同步以及微调。</p>
</blockquote>

<h2 id="1-multi-program-os">1. Multi-program OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/multiprog-os-detail.png" alt="Multi-program OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Multi-program OS Details, rCore</u></font>
</div>

<p>要满足 <strong>任务切换</strong> 的要求， 所以程序需要预先被加载到一个固定的内存地址， 而不是所有程序共用一个入口地址。 rCore 添加了 <code class="language-plaintext highlighter-rouge">user/build.py</code> 读取 <code class="language-plaintext highlighter-rouge">os/src/link_app.S</code> 并对每个程序的地址空间进行更改以适应前述要求。</p>

<p>与 Trap 不同， Mult-program OS 中的任务切换发生在内核态 （S Mode） 且不涉及特权级切换， 通过 <code class="language-plaintext highlighter-rouge">__switch</code> 函数实现两个不同的 <code class="language-plaintext highlighter-rouge">Task Context</code> 的切换。</p>

<blockquote>
  <p><strong>为什么 <code class="language-plaintext highlighter-rouge">__switch</code> 需要通过汇编的完成主要功能？</strong><br />
由于任务切换不涉及特权级的改变， 因而需要保存的上下文就比较少， 仅需要保存 <code class="language-plaintext highlighter-rouge">ra</code> 入口地址， <code class="language-plaintext highlighter-rouge">sp</code> 栈指针， 以及 Callee 负责寄存器 <code class="language-plaintext highlighter-rouge">s0~s11</code> 即可。 高级程序语言会在函数中自己使用一些通用的寄存器， 可能会发生意料之外的控制流， 另外 <code class="language-plaintext highlighter-rouge">__switch</code> 函数仅作为 label 存在不会被 Rust/C 编译器处理， 这些都是使用汇编完成 <code class="language-plaintext highlighter-rouge">__switch</code> 主体功能的原因。</p>
</blockquote>

<h2 id="2-cooperative-os">2. Cooperative OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/more-task-multiprog-os-detail.png" alt="Cooperative OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Cooperative OS Details, rCore</u></font>
</div>

<p>Multi-program OS 仅仅介绍了任务切换中的 <strong>换栈</strong> 需求， 任务切换还需要指示任务的状态， 维护这一信息。 这里我仅记录初始化流程中的几个自己困惑的细节。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">in</span> <span class="n">tasks</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">task</span><span class="py">.task_cx</span> <span class="o">=</span> <span class="nn">TaskContext</span><span class="p">::</span><span class="nf">goto_restore</span><span class="p">(</span><span class="nf">init_app_cx</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">task</span><span class="py">.task_status</span> <span class="o">=</span> <span class="nn">TaskStatus</span><span class="p">::</span><span class="n">Ready</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/task/context.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">goto_restore</span><span class="p">(</span><span class="n">kstack_ptr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">__restore</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">ra</span><span class="p">:</span> <span class="n">__restore</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sp</span><span class="p">:</span> <span class="n">kstack_ptr</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">TASK_MANAGER</code> 通过 <code class="language-plaintext highlighter-rouge">init_app_cx</code> 函数初始化了每个 task 的内核栈， 而 <code class="language-plaintext highlighter-rouge">goto_restore</code> 的设计就非常巧妙， 这里并没有进入 <code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 标签处， 而是将任务栈的 <code class="language-plaintext highlighter-rouge">ra</code> 初始化为 <code class="language-plaintext highlighter-rouge">__restore</code> 地址， 这样当 <code class="language-plaintext highlighter-rouge">__switch</code> 完成后 <code class="language-plaintext highlighter-rouge">ret</code> 就能直接进入<code class="language-plaintext highlighter-rouge">trap.S</code> 的 <code class="language-plaintext highlighter-rouge">__restore</code> 恢复到用户态继续执行任务。 相应的其中的 <code class="language-plaintext highlighter-rouge">sp</code> 指针被初始化为内核栈指针。</p>

<blockquote>
  <p><strong>丢失的 <code class="language-plaintext highlighter-rouge">mv sp, a0</code></strong></p>

  <ul>
    <li>
      <p>可以顺着控制流梳理一遍， 第一次用到 <code class="language-plaintext highlighter-rouge">__switch</code> 是初始化时运行 <code class="language-plaintext highlighter-rouge">run_first_task</code> 函数。 <code class="language-plaintext highlighter-rouge">__switch</code> 将 <code class="language-plaintext highlighter-rouge">unused</code> 中的垃圾数据保存在了程序栈后切换到了第一个 task （此后就是内核栈和用户栈之间的切换了）， 通过 <code class="language-plaintext highlighter-rouge">ra</code> 指向的 <code class="language-plaintext highlighter-rouge">__restore</code> 进行上下文恢复， 对于 task 而并不需要再次更新 <code class="language-plaintext highlighter-rouge">sp</code>， 该值已经在 <code class="language-plaintext highlighter-rouge">__switch</code> 中被恢复成该任务对应的内核指针了。</p>
    </li>
    <li>
      <p>另一个就是进入 trap 之后， <code class="language-plaintext highlighter-rouge">__alltrap</code> 最后进入 <code class="language-plaintext highlighter-rouge">trap_handler</code> 函数， 该函数最后会在返回参数的 <code class="language-plaintext highlighter-rouge">a0</code> 中保存之前存入的 <code class="language-plaintext highlighter-rouge">TrapContext</code>， 而在此之前有这么两句指令说明了 <code class="language-plaintext highlighter-rouge">sp</code> 就是这个 <code class="language-plaintext highlighter-rouge">TrapContext</code>。 因而无需再进行重复保存。</p>

      <div class="language-s highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="c1"># set input argument of trap_handler(cx: &amp;mut TrapContext)</span><span class="w">
 </span><span class="n">mv</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w">
 </span><span class="n">call</span><span class="w"> </span><span class="n">trap_handler</span><span class="w">
</span></code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<h2 id="3-timesharing-os">3. Timesharing OS</h2>

<div align="center">
    <img src="/norobots/images/2023-07-01-rcore-note-ch3/time-task-multiprog-os-detail.png" alt="Timesharing OS Details, rCore" width="600" />
    <br />
    <font size="2" color="#999"><u>Timesharing OS Details, rCore</u></font>
</div>

<h2 id="4-课后练习">4. 课后练习</h2>

<p>这章的编程题还是有必要提前做一下的， 汲取了上一章的教训这次先看了 lab 部分， 发现 lab 有个要求是记录当前的正在运行的 task 的运行总时长， 这部分时间既包括内核态与用户态两部分的运行时间， 正好编程题包括了。 这部分可以选择性的完成几个基础练习， 难的部分再好好研究一下。</p>

<h3 id="41-编程题">4.1 编程题</h3>

<ol>
  <li>
    <p><em><strong>扩展内核， 能够显示操作系统切换任务的过程。</strong></em></p>

    <p>只用在 <code class="language-plaintext highlighter-rouge">os/src/task/mod.rs</code> 的 <code class="language-plaintext highlighter-rouge">run_next_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 加入打印就行， 另外在这里我对任务切换的流程进行了优化， 仅在当前 <code class="language-plaintext highlighter-rouge">current != next</code> 时才进行 <code class="language-plaintext highlighter-rouge">Task Context</code> 交换以及打印相关的信息， 这样能减少内核开销。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// os/src/task/mod.rs</span>
 <span class="k">fn</span> <span class="nf">run_next_task</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find_next_task</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">self</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
         <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
         <span class="o">...</span>
         <span class="c1">// ch3-pro1</span>
         <span class="k">if</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">next</span> <span class="p">{</span>
             <span class="nd">println!</span><span class="p">(</span><span class="s">"[kernel] task switch from {} to {}"</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
             <span class="k">unsafe</span> <span class="p">{</span>
                 <span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">);</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span>
     <span class="o">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>除此之外 <code class="language-plaintext highlighter-rouge">struct TaskManagerInner</code> 中我添加了 <code class="language-plaintext highlighter-rouge">alive_task_num</code> 用以记录仍在 <code class="language-plaintext highlighter-rouge">Ready</code> 以及 <code class="language-plaintext highlighter-rouge">Running</code> 的 task 的数量， 仅在 <code class="language-plaintext highlighter-rouge">alive_task_num &gt; 1</code> 的时候才在 <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中添加打印以保持输出面板整洁以及系统开销最小。</p>

    <blockquote>
      <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/4f1dd08bae3e884a06e2a8141bf0fa4d6909310a">commit#4f1dd08</a> 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/208d86306ee7bba5149fbd38acfb62f6d08e9d84">commit#208d863</a></p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核， 能够统计每个应用执行后的完成时间： 用户态完成时间和内核态完成时间。</strong></em></p>

    <p>lab 相关的重点， <code class="language-plaintext highlighter-rouge">sys_task_info</code> 大部分信息其实都需要 task module 的支持。 另外， 每个 task 都是独立的， 因而需要在 <code class="language-plaintext highlighter-rouge">struct TaskControlBlock</code> 中增加记录 task 运行时间的变量。</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
 <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
     <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>之后比较关键的是如何记录这个时间， 这个我在之前 chapter2 实现了类似的函数， 基本思路就是利用 riscv 的 mtime 寄存器， 需要有个特定的变量存储 mtime 寄存器的值并在每次进入该 task 时计算与现在的 mtime 的插值获取时间信息的变更。</p>
    <blockquote>
      <p>lab 中要求时间单位为 ms， 可以使用 <code class="language-plaintext highlighter-rouge">timer.rs</code> 的 <code class="language-plaintext highlighter-rouge">get_time_ms</code> 函数。</p>
    </blockquote>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskManagerInner</span> <span class="p">{</span>
     <span class="cd">/// task list</span>
     <span class="n">tasks</span><span class="p">:</span> <span class="p">[</span><span class="n">TaskControlBlock</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">],</span>
     <span class="cd">/// id of current `Running` task</span>
     <span class="n">current_task</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// the number of tasks that have not exit</span>
     <span class="n">alive_task_num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
     <span class="cd">/// record time point</span>
     <span class="n">checkpoint</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <dl>
      <dt>内核态时间</dt>
      <dd>在 <code class="language-plaintext highlighter-rouge">run_first_task</code> 以及 <code class="language-plaintext highlighter-rouge">mark_current_exited</code>， <code class="language-plaintext highlighter-rouge">mark_current_suspend</code> 中更新信息， 另外需要在 task 退出时打印耗时。</dd>
      <dt>用户态时间</dt>
      <dd>用户态和内核态的分界处就是 trap， 因而在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的起始位置和末尾位置可分别作为 user time 的开始以及 user time 的结束。</dd>
    </dl>

    <blockquote>
      <p>具体实现可以参考课后参考答案部分 以及 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/5904c2fcb253a5bfa694ab94e0c7e3006f510238">commit#5904c2f</a>， :sob: <strong>我把 <code class="language-plaintext highlighter-rouge">user_time_start</code> 和 <code class="language-plaintext highlighter-rouge">user_time_end</code></strong> 的位置搞反了， 后续所有的版本都要更改。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>编写浮点应用程序A， 并扩展内核， 支持面向浮点应用的正常切换与抢占。</strong></em></p>

    <p>这块没怎么搞懂， 看起来要加很多东西。</p>
  </li>
  <li>
    <p><em><strong>编写应用程序或扩展内核， 能够统计任务切换的大致开销。</strong></em></p>

    <p>这里的参考答案是有问题的， <code class="language-plaintext highlighter-rouge">__switch</code> 之后会跳转到 <code class="language-plaintext highlighter-rouge">__restore</code> 恢复到用户态，后面那句只有下一次用户态 trap 后才会执行。 虽然不对我还是测试了一下， 发现 context switch 要花费几百毫秒， 这肯定是不可能的。 可行的办法是更改 <code class="language-plaintext highlighter-rouge">goto_restore</code> 函数， 将每个 <code class="language-plaintext highlighter-rouge">__switch</code> 调用的返回地址更改为 <code class="language-plaintext highlighter-rouge">__pre_restore</code> 并在这里插入一个更新 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 中的 <code class="language-plaintext highlighter-rouge">switch_time</code> 的值， 这样才能统计不同的 task 的 switch context 开销。</p>

    <ul>
      <li>
        <p>首先需要在 <code class="language-plaintext highlighter-rouge">os/src/task/task.rs</code> 的 <code class="language-plaintext highlighter-rouge">struct TaskControlBlock</code> 中插入统计每个 task 任务切换上下文开销的变量。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/task/task/rs</span>
  <span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
  <span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
      <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
      <span class="k">pub</span> <span class="n">switch_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
      <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>更新 <code class="language-plaintext highlighter-rouge">trap.S</code> 并在尾部插入如下代码， 相应的需要更改 <code class="language-plaintext highlighter-rouge">goto_restore</code> 中 <code class="language-plaintext highlighter-rouge">ra</code> 地址为 <code class="language-plaintext highlighter-rouge">__pre_restore</code>。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">__pre_restore</span><span class="p">:</span>
      <span class="n">mv</span> <span class="n">a0</span><span class="p">,</span> <span class="n">sp</span>
      <span class="n">call</span> <span class="n">switch_cost</span>
      <span class="n">mv</span> <span class="n">sp</span><span class="p">,</span> <span class="n">a0</span>
      <span class="n">j</span> <span class="n">__restore</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>context switch 的开销统计的相关函数如下。</p>

        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// os/src/task/mod.rs</span>
  <span class="k">pub</span> <span class="k">static</span> <span class="k">mut</span> <span class="n">SWITCH_TASK_START</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskContext</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">TaskContext</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SWITCH_TASK_START</span> <span class="o">=</span> <span class="nf">get_time_us</span><span class="p">();</span>
      <span class="nn">switch</span><span class="p">::</span><span class="nf">__switch</span><span class="p">(</span><span class="n">current_task_cx_ptr</span><span class="p">,</span> <span class="n">next_task_cx_ptr</span><span class="p">);</span>
      <span class="c1">// 记录除了第一次运行外的 switch cost</span>
      <span class="k">crate</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">update_switch_cost</span><span class="p">(</span><span class="nf">get_time_us</span><span class="p">()</span> <span class="o">-</span> <span class="n">SWITCH_TASK_START</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_switch_cost</span><span class="p">(</span><span class="n">cost</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
      <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
      <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.switch_time</span> <span class="o">+=</span> <span class="n">cost</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// os/src/trap/mod.rs</span>
  <span class="nd">#[no_mangle]</span>
  <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">switch_cost</span> <span class="p">(</span><span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TrapContext</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TrapContext</span> <span class="p">{</span>
      <span class="k">crate</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">update_switch_cost</span><span class="p">(</span><span class="nf">get_time_us</span><span class="p">()</span> <span class="o">-</span> <span class="n">SWITCH_TASK_START</span><span class="p">);</span>
      <span class="n">cx</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>

    <blockquote>
      <p>具体的实现和细节可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/4e9425855a85e601fa02070c41da72b5a4f1b7c1">commit#4e9425</a>， 但当时做的时候遗漏了 <code class="language-plaintext highlighter-rouge">__switch</code> 计时函数中的 <code class="language-plaintext highlighter-rouge">crate::task::update_switch_cost(get_time_us() - SWITCH_TASK_START);</code> 导致内核只能记载程序 <strong>switch to not running</strong> 即程序开始第一次运行前的开销。 具体可以参考 <a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3/issues/141#issuecomment-1637146452">Mars</a> 在 rCore 相关章节的留言。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>扩展内核，支持在内核态响应中断。</strong></em></p>
  </li>
  <li>
    <p><em><strong>扩展内核，支持在内核运行的任务（简称内核任务），并支持内核任务的抢占式切换。</strong></em></p>
  </li>
</ol>

<h3 id="42-实验练习">4.2 实验练习</h3>

<h4 id="获取任务信息">获取任务信息</h4>

<p>做完编程题的第二个就跑来做 lab 了， 事情比我想得要复杂一些。 这里需要声明一下 <a href="https://learningos.github.io/rCore-Tutorial-Guide-2023S/index.html">rCore-Tutorial-Guide 2023</a> 实验指导书对应的 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2023S">test repo</a> 和当前的 <a href="http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</a> 是有差异的， 如果你和我一样是按照 tutorial 一步步搭起来的 OS 请注意以下这些细节。</p>

<p>Guide 2023S 中提供的接口函数是如下形式， 在具体实现的时候由于 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 中存在一个数组结构， 需要添加 <code class="language-plaintext highlighter-rouge">#[derive(Clone, Copy)]</code>， 如果添加了 <code class="language-plaintext highlighter-rouge">#[repr(C)]</code> 修饰， 后续在 user 目录下的 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 需要保持声明的一致性， 否则 os 部分的 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 将无法正确赋值。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/syscall/process.rs</span>
<span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span>

<span class="k">struct</span> <span class="n">TaskInfo</span> <span class="p">{</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我最开始设想在 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 外在包裹一个 <code class="language-plaintext highlighter-rouge">TaskInfoWrapper</code>， 并将其声明为如下 case1 形式， 但问题也随之而来， 程序运行会出现 <em><strong>PageFault</strong></em> 错误。 而 case2 这样试图将 <code class="language-plaintext highlighter-rouge">TaskInfo</code> 作为可变量用 <code class="language-plaintext highlighter-rouge">UPSafeCell</code> 保护， 之后再通过 <code class="language-plaintext highlighter-rouge">lazy_static!</code> 宏声明一个 <code class="language-plaintext highlighter-rouge">[TaskInfoWrapper;MAX_APP_NUM]</code> 全局数组变量则会遇到 Copy Trait 未实现的问题。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// case1</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="n">TaskInfo</span><span class="p">;</span> <span class="n">MAX_APP_NUM</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// case2</span>
<span class="k">struct</span> <span class="n">TaskInfoWrapper</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="n">UPSafeCell</span><span class="o">&lt;</span><span class="n">TaskInfo</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因而我想现阶段我没办法找到一种合适的办法构造一个全局数组变量去存储每个 task info， 那不如利用现有的资源， 每个 task 都维护了一个 <code class="language-plaintext highlighter-rouge">TaskControlBlock</code> 变量， 此前的编程题作业在这里面添加了 <code class="language-plaintext highlighter-rouge">kernel_time</code> 以及 <code class="language-plaintext highlighter-rouge">user_time</code>， 不如再增加一个 <code class="language-plaintext highlighter-rouge">syscall_times</code> 数组变量（与所给测例一致）。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/task.rs</span>
<span class="nd">#[derive(Copy,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_status</span><span class="p">:</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_cx</span><span class="p">:</span> <span class="n">TaskContext</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">syscall_times</span><span class="p">:</span> <span class="p">[</span><span class="nb">u32</span><span class="p">;</span> <span class="n">MAX_SYSCALL_NUM</span><span class="p">],</span>
    <span class="k">pub</span> <span class="n">user_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kernel_time</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>剩下的事情就比较简单了， 给 <code class="language-plaintext highlighter-rouge">sys_task_info</code> 提供一个可以获取当前 task 的 <code class="language-plaintext highlighter-rouge">TaskCOntrolBlock</code> 的函数， 以及一个可以在 <code class="language-plaintext highlighter-rouge">trap_handler</code> 的 syscall 之前调用的增加 <code class="language-plaintext highlighter-rouge">syscall_times</code> 值的函数就能基本满足题干的要求， 我是这么实现的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// os/src/task/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_current_task_block</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">TaskControlBlock</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update_task_syscall_times</span><span class="p">(</span><span class="n">syscall_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">TASK_MANAGER</span><span class="py">.inner</span><span class="nf">.exclusive_access</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">inner</span><span class="py">.current_task</span><span class="p">;</span>
    <span class="n">inner</span><span class="py">.tasks</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="py">.syscall_times</span><span class="p">[</span><span class="n">syscall_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// os/src/syscall/process.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sys_task_info</span><span class="p">(</span><span class="n">ti</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">TaskInfo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">task_block</span> <span class="o">=</span> <span class="nf">get_current_task_block</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">TaskInfo</span> <span class="p">{</span>
            <span class="n">status</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.task_status</span><span class="p">,</span>
            <span class="n">syscall_times</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.syscall_times</span><span class="p">,</span>
            <span class="n">time</span><span class="p">:</span> <span class="n">task_block</span><span class="py">.kernel_time</span> <span class="o">+</span> <span class="n">task_block</span><span class="py">.user_time</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>具体实现可以参考 <a href="https://github.com/HangX-Ma/rCore-sp23/commit/d5f55551e5e3428ca7c17026329c2d84fe9bde4f">commit#d5f5555</a>, 但该 commit 中我还对之前的 <code class="language-plaintext highlighter-rouge">sys_write</code> 的 checker 函数进行了更新。</p>
</blockquote>

<p class="error">需要注意 <code class="language-plaintext highlighter-rouge">ch3_taskinfo.rs</code> 需要单独运行测试， 否则 <code class="language-plaintext highlighter-rouge">get_time</code> 函数获取的几个时间点的差值会受到其他程序影响而产生很大偏差。 另外测例中的 <code class="language-plaintext highlighter-rouge">println!</code> 是调用了 flush 函数的， 因而在 rCore 2023S 提供的测试环境中确实会有两次 write 系统调用， 但是按照 tutorial 搭的 OS 现阶段仅有一次 write 系统调用， 若这个测试没通过可以自行修改一下。</p>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><category term="rCore" /><summary type="html"><![CDATA[第三章：多道程序与分时多任务， 阅读 rCore tutorial book v3 的笔记以及实践部分的实现与记录。]]></summary></entry><entry><title type="html">Start from scratch: Neovim for Rust</title><link href="https://hangx-ma.github.io/2023/06/23/neovim-config.html" rel="alternate" type="text/html" title="Start from scratch: Neovim for Rust" /><published>2023-06-23T00:00:00+08:00</published><updated>2023-06-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/23/neovim-config</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/23/neovim-config.html"><![CDATA[<blockquote>
  <p>配置文件可以在 <a href="https://github.com/HangX-Ma/dotfiles/tree/main/nvim">nvim-config</a> repo 下查看， 配完后感觉没有汇编支持不适合 OS 底层开发， 到时候再看看吧， 先用回 vscode。</p>
</blockquote>

<h2 id="0-安装-neovim">0. 安装 Neovim</h2>

<p>使用 <a href="https://github.com/neovim/neovim/releases/tag/stable">Nvim release build</a> 的方式， 省心省力。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://github.com/neovim/neovim/releases/download/stable/nvim-linux64.tar.gz
<span class="nb">tar</span> <span class="nt">-xvf</span> nvim-linux64.tar.gz
vim ~/.bashrc
<span class="c"># .bashrc</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/nvim-linux64/bin:<span class="nv">$PATH</span>
<span class="c"># back to cli</span>
<span class="nb">source</span> ~/.bashrc
</code></pre></div></div>

<h2 id="1-vim-选项配置">1. vim 选项配置</h2>

<blockquote>
  <p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门 - 阮一峰</a><br />
<a href="https://www.xwxwgo.com/post/2022/09/21/spell_check_in_nvim/">Neovim拼写检查</a></p>
</blockquote>

<h2 id="2-快捷键配置">2. 快捷键配置</h2>

<p><a href="https://juejin.cn/book/7051157342770954277/section/7051536642238054430">Neovim 配置实战：从0到1打造自己的IDE</a></p>

<h2 id="3-安装-packer-插件管理器">3. 安装 Packer 插件管理器</h2>

<p>参照 Packer 的 repo 的配置内容快速安装 <a href="https://github.com/wbthomason/packer.nvim">packer.nvim</a>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone <span class="nt">--depth</span> 1 https://github.com/wbthomason/packer.nvim<span class="se">\</span>
 ~/.local/share/nvim/site/pack/packer/start/packer.nvim
</code></pre></div></div>

<p><a href="https://github.com/wbthomason/packer.nvim#bootstrapping">Bootstrapping</a> 这一章节提供了一种便利的方式配置插件， 在导入配置后能自动安装已配置完的插件， 在 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins/plugins.lua</code> 中拷贝这部分代码作为插件配置的基础。 我们创建 <code class="language-plaintext highlighter-rouge">$HOME/.config/nvim/lua/plugins</code> 文件夹用以管理各个安装的插件。 若需要对插件进行自定义配置， 我们需要创建相关的 lua 文件， 例如 <code class="language-plaintext highlighter-rouge">onedark.lua</code> 之后在 <code class="language-plaintext highlighter-rouge">init.lua</code> 文件中 <code class="language-plaintext highlighter-rouge">require(plugins.onedark)</code> 即可应用相关的配置。</p>

<h2 id="4-插件安装">4. 插件安装</h2>

<h3 id="41-安装-onedark---dark-主题">4.1 安装 OneDark - Dark 主题</h3>

<p>主要参考 <a href="https://github.com/navarasu/onedark.nvim">onedark.nvim</a>， 加入插件后自定义配置即可。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- lua/plugins/plugins.lua</span>
<span class="n">use</span> <span class="s1">'navarasu/onedark.nvim'</span>
</code></pre></div></div>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- plugins/onedark.lua</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="n">setup</span> <span class="p">{</span>
    <span class="c1">-- Main options --</span>
    <span class="n">style</span> <span class="o">=</span> <span class="s1">'dark'</span><span class="p">,</span>
    <span class="n">transparent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">-- Show/hide background</span>
<span class="p">}</span>
<span class="nb">require</span><span class="p">(</span><span class="s1">'onedark'</span><span class="p">).</span><span class="nb">load</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="42-status-line">4.2 Status Line</h3>

<p>主要参考 <a href="https://github.com/nvim-lualine/lualine.nvim">lualine.nvim</a>， 拷贝 <a href="https://github.com/nvim-lualine/lualine.nvim#default-configuration">default configuration</a> 到 <code class="language-plaintext highlighter-rouge">lua/plugins/lualine.lua</code>， 其余步骤与上述一致。 后续若没有特殊情况就不重复说明相关步骤。</p>

<blockquote>
  <p>值得注意的是， 添加相关的插件后需要在 nvim 中运行 <code class="language-plaintext highlighter-rouge">PackerSync</code> 以安装相关插件， 否则 nvim 会报错。</p>
</blockquote>

<h3 id="43-navigation">4.3 Navigation</h3>

<dl>
  <dt>File Explorer: <a href="https://github.com/nvim-tree/nvim-tree.lua">nvim-tree.nvim</a></dt>
  <dd>提供了便捷的文件管理树的功能， 所有的文件操作可以通过键盘实现</dd>
  <dt>Tmux Navigator: <a href="https://github.com/christoomey/vim-tmux-navigator">vim-tmux-navigator.nvim</a></dt>
  <dd>tmux (terminal multiplexer) 是一个终端复用器， 主要可以用于分屏和保持会话。 保持会话的意思是， 即使关闭终端窗口， 或者 SSH 由于各种原因连接中断， 在服务器端 tmux 中的会话和对应的进程仍然不会终止。 tmux 能够创建多个会话 （session）， 每个会话能够创建多个窗口 （window）， 每个窗口又可以分为多个窗格 （pane）。</dd>
  <dt>Buffer Line: <a href="https://github.com/akinsho/bufferline.nvim">bufferline.nvim</a></dt>
  <dd>这个插件提供了类似 vscode 的标签页的功能</dd>
  <dt>Outline: <a href="https://github.com/simrat39/symbols-outline.nvim">symbols-outline.nvim</a></dt>
  <dd>类似 vscode 中的 Outline， 基于 LSP 实现的函数与符号树， 方便查看代码实现的整体结构。</dd>
</dl>

<blockquote>
  <p><a href="https://blog.51cto.com/u_11090813/5575032">从零开始配置 vim(13)——标签页插件 - jesssic</a>
<a href="https://blog.51cto.com/u_11090813/5759499">从零开始配置vim(26)——LSP UI 美化 - jesssic</a></p>
</blockquote>

<h3 id="44-highlight">4.4 Highlight</h3>

<dl>
  <dt>Code Highlighting: <a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter.nvim</a></dt>
  <dd>nvim-treesitter 插件提供基于 <a href="https://github.com/tree-sitter/tree-sitter">tree-sitter</a> 的多个基础功能， 它可以让你在 nvim 中高效的实现 <strong>代码高亮， 增量选择</strong> 等功能。</dd>
  <dt>Syntax Highlighting: <a href="https://github.com/p00f/nvim-ts-rainbow">nvim-ts-rainbow</a></dt>
  <dd>该插件依赖于 nvim-treesitter， 允许多种配置策略为不同的文件类型提供高亮支持。</dd>
</dl>

<h3 id="45-terminal">4.5 Terminal</h3>

<dl>
  <dt>Terminal: <a href="https://github.com/akinsho/toggleterm.nvim">toggleterm.nvim</a></dt>
  <dd>虽然用 nvim 默认的指令可以在编辑文档时打开 Terminal， 但是 toggleterm.nvim 提供了更为便捷以及功能更强大的 Terminal 管理方案。</dd>
</dl>

<blockquote>
  <p><a href="https://www.youtube.com/watch?v=5OD-7h7gzxU">Neovim - Toggleterm | Open terminal programs in Neovim - Youtube</a>
<a href="https://blog.51cto.com/u_11090813/5647999">从零开始配置vim(19)——终端配置 - jesssic</a></p>
</blockquote>

<h3 id="46-search">4.6 Search</h3>

<dl>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/popup.nvim">popup.nvim</a></dt>
  <dd>plenary.nvim 的必要组件， 能够提供与 vim <code class="language-plaintext highlighter-rouge">popup_*</code> 兼容的 API 接口。</dd>
  <dt>Basic Component: <a href="https://github.com/nvim-lua/plenary.nvim">plenary.nvim</a></dt>
  <dd>telescope.nvim 的必要组件， 能够提供异步编程， 目录扫描等基础功能。</dd>
  <dt>Fuzzy Finder: <a href="https://github.com/nvim-telescope/telescope.nvim">telescope.nvim</a></dt>
  <dd>telescope.nvim 能在 neovim 中提供文件名模糊搜索和文本内容搜索的功能， 以及更多复杂的功能。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/609527018">Vim/Neovim 全文检索插件 – telescope.nvim - 知乎</a></p>
</blockquote>

<h3 id="47-comment">4.7 Comment</h3>

<dl>
  <dt>Smart Comment: <a href="https://github.com/numToStr/Comment.nvim">Comment.nvim</a></dt>
  <dd>能够方便的对代码进行注释， 这个插件的配置更灵活也更强大。</dd>
</dl>

<h3 id="48-自动补全与内容查看">4.8 自动补全与内容查看</h3>

<h4 id="481-lsp-mason">4.8.1 LSP， Mason</h4>

<dl>
  <dt>Language Server Protocol: <a href="https://github.com/neovim/nvim-lspconfig">nvim-lspconfig</a></dt>
  <dd>Language Server Protocol (LSP) 是微软为开发工具提出的一个协议， 它将编程工具解耦成了Language Server 与 Language Client 两部分。 Client 专注于页面样式实现， Server 负责提供语言支持， 包括常见的自动补全， 跳转到定义， 查找引用， 悬停文档提示等功能。</dd>
  <dt>Portable Package Manager: <a href="https://github.com/williamboman/mason.nvim">mason.nvim</a></dt>
  <dd>mason.nvim 是下一代 nvim-lsp-installer， 能够方便地安装和管理 LSP servers， DAP servers， linters， 以及 formatters.</dd>
  <dt>Packer: <a href="https://github.com/williamboman/mason-lspconfig.nvim">mason-lspconfig.nvim</a></dt>
  <dd>mason-lspconfig.nvim 为 mason.nvim 以及 nvim-lspconfig 建立了桥梁， 方便两个插件的协同工作和配置。</dd>
  <dt>UI: <a href="https://github.com/j-hui/fidget.nvim">fidget.nvim</a></dt>
  <dd>nvim-lsp progress 的独立 UI插件， 将这部分信息显示在窗口右下角为程序员更专注编程提供便利。</dd>
</dl>

<blockquote>
  <p><a href="https://zhuanlan.zhihu.com/p/444836713">Neovim 内置 LSP 配置 (一)：基础配置 - 知乎</a></p>
</blockquote>

<h4 id="482-补全与自动提示">4.8.2 补全与自动提示</h4>

<dl>
  <dt>AutoPair: <a href="https://github.com/windwp/nvim-autopairs">nvim-autopairs</a></dt>
  <dd>自动补全括号的插件， 具体作用之后用了补充。</dd>
  <dt>Completion: <a href="https://github.com/hrsh7th/nvim-cmp">nvim-cmp</a></dt>
  <dd>自动补全的引擎， 支持 LSP 以及自定义灵活配置， 我们需要安装如下插件 <code class="language-plaintext highlighter-rouge">neovim/nvim-lspconfig</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-nvim-lsp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-buffer</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-path</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-cmdline</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/nvim-cmp</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/cmp-vsnip</code>, <code class="language-plaintext highlighter-rouge">hrsh7th/vim-vsnip</code>, <code class="language-plaintext highlighter-rouge">saadparwaiz1/cmp_luasnip</code></dd>
  <dt>Friendly Snippets: <a href="https://github.com/rafamadriz/friendly-snippets">friendly-snippets</a></dt>
  <dd>更够为不同语言提供 Snippets 支持。</dd>
</dl>

<h3 id="49-debug">4.9 Debug</h3>

<dl>
  <dt>Debugger: <a href="https://github.com/puremourning/vimspector">vimspector</a></dt>
  <dd>多语言的带图形界面的调试工具， 看起来挺复杂。</dd>
  <dt>Debug Adapter Protocol: <a href="https://github.com/mfussenegger/nvim-dap">nvim-dap</a></dt>
  <dd>Nvim-dap 是基于 Neovim 的 Debug Adapter Protocol 客户端实现的， 能够进行基本的断点、 步进等操作， 并监视应用的状态。</dd>
</dl>

<h3 id="410-rust-语言支持">4.10 Rust 语言支持</h3>

<dl>
  <dt>Code: <a href="https://rust-analyzer.github.io/">rust-analyzer</a></dt>
  <dd>rust-analyzer 基于 LSP 实现， 它为许多代码编辑器 (包括 VS Code、 Emacs 和 Vim) 提供了补全和跳转定义等特性。</dd>
</dl>

<blockquote>
  <p>nvim 打开后使用 <code class="language-plaintext highlighter-rouge">:Mason</code> 选择 rust-analyzer 按 i 可以便捷安装。</p>
</blockquote>

<dl>
  <dt>Tool: <a href="https://github.com/simrat39/rust-tools.nvim">rust-tools.nvim</a></dt>
  <dd>为 rust 编程提供便利的实用工具。</dd>
</dl>

<h3 id="411-clipboard">4.11 Clipboard</h3>

<dl>
  <dt>Clipboard: <a href="https://github.com/EtiamNullam/deferred-clipboard.nvim/tree/master">deferred-clipboard.nvim</a></dt>
  <dd>打通操作系统与 nvim 之间的桥梁， 二者能共用剪贴板的缓存。</dd>
</dl>

<h3 id="412-git">4.12 Git</h3>

<dl>
  <dt>LazyGit: <a href="https://github.com/kdheepak/lazygit.nvim">lazygit.nvim</a></dt>
  <dd>Git 相关组件， 实现 commit, push 等操作的可视化。</dd>
  <dt>Git Signs: <a href="https://github.com/lewis6991/gitsigns.nvim">gitsigns.nvim</a></dt>
  <dd>提供了和 Git 相关的功能， 例如查看 git diff， last commit， status bar 等， 类似 vscode 中的 GitLen。</dd>
</dl>

<h3 id="413-speed-up">4.13 Speed Up</h3>

<dl>
  <dt>FileType: <a href="https://github.com/nathom/filetype.nvim">filetype.nvim</a></dt>
  <dd>filetype.nvim 是为了替代 nvim 启动时引用的 <code class="language-plaintext highlighter-rouge">filetype.vim</code> 文件， 该文件的目的是创建一系列自动命令， 根据文件名设置 filetype 变量， 但该文件的载入耗费了大量的时间， filetype.nvim 能优化这一载入过程， 对启动过程进行加速。</dd>
  <dt>Lua Loader: <a href="https://github.com/lewis6991/impatient.nvim">impatient.nvim</a></dt>
  <dd>该插件在 neovim 0.9 后就不需要了， 只用开启 <code class="language-plaintext highlighter-rouge">vim.loader.enable()</code> 即可对 lua 模块以及文件的载入进行加速。</dd>
</dl>

<h3 id="414-greeter">4.14 Greeter</h3>

<dl>
  <dt>Greeter: <a href="https://github.com/startup-nvim/startup.nvim">startup.nvim</a></dt>
  <dd>自定义 nvim 启动界面， 能够自己更换喜欢的主题！</dd>
</dl>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/617522665">从零开始：使用Neovim搭建Rust开发IDE - 知乎</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/467428462">我的现代化 NeoVim 配置介绍/教程</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="neovim" /><summary type="html"><![CDATA[鉴于NvChard 这类整包的灵活性不高， 以及 vscode 经常抽风的现实情况， 从零开始搭建用于 Rust 编程环境的 Neovim]]></summary></entry></feed>