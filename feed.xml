<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://hangx-ma.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hangx-ma.github.io/" rel="alternate" type="text/html" /><updated>2023-06-16T15:46:08+08:00</updated><id>https://hangx-ma.github.io/feed.xml</id><title type="html">一只豆腐</title><subtitle>Code, life and embedded system...
</subtitle><author><name>HangX-Ma</name><email>m-contour@qq.com</email></author><entry><title type="html">Rust 线程同步： Channel</title><link href="https://hangx-ma.github.io/2023/06/11/rust-channel.html" rel="alternate" type="text/html" title="Rust 线程同步： Channel" /><published>2023-06-11T00:00:00+08:00</published><updated>2023-06-11T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/11/rust-channel</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/11/rust-channel.html"><![CDATA[<blockquote>
  <ul>
    <li>CS110L Spring 2020 仓库： <a href="https://github.com/HangX-Ma/cs110l-sp20">https://github.com/HangX-Ma/cs110l-sp20</a></li>
    <li>CS110L Spring 2020 课程网站： <a href="https://reberhardt.com/cs110l/spring-2020/">https://reberhardt.com/cs110l/spring-2020/</a></li>
  </ul>
</blockquote>

<p>CS110L Spring20 课程的 Lecture 12 提及了 Rust 多线程间的数据共享的问题。 一般来说， 线程之间会通过一块共享内存传递数据， 并使用 <code class="language-plaintext highlighter-rouge">Arc</code> 以及 <code class="language-plaintext highlighter-rouge">Mutex</code> 避免数据竞争 (Race Condition)。</p>

<p>但是 <strong>使用锁的办法是开销极大的</strong>。 假设内核调度时线程 A 遇到了上锁的数据， 虽然处理这一小段数据可能只需要几纳秒的时间， 但是剩余的时间片因为锁的原因而被浪费了， 而此时该线程又被内核放在了调度队列的末尾， 这意味着线程 A 真正运行时需要经历多轮调度等待很长时间。 那么最好的办法就是使用一种不上锁的数据结构。</p>

<h2 id="1-channel-模型的提出">1. Channel 模型的提出</h2>

<div align="center" style="font-weight: bold; font-style: italic;">

Do not communicate by sharing memory; instead, share memory by communicating
<p align="right">-- Effective Golang</p>
</div>

<p>早在 1978 年就已经提出了 Channel 的理论模型， 多个线程之间的通信以消息的方式传递， 由于没有使用共享内存， 因而不会产生数据竞争。 但消息传递并不意味着高效， 由于我们没有使用共享内存， 这需要我们将需要传递的数据拷贝进 <code class="language-plaintext highlighter-rouge">Message</code> 中， 这会造成极大的资源浪费和严重的效率问题。</p>

<p>在 Rust 中可以通过浅拷贝达到数据共享的目的， 我们需要在 <code class="language-plaintext highlighter-rouge">Message</code> 中传递指针。 用以描述指针的数据结构所占的资源是极小的， 这种 <strong>Partial Shared Memory</strong> 的安全性也能得到保证。 由于 Rust 语言的特性， 指针的所有权会在传递时转移至 Channel 中， 编译器会保证我们在传递指针后无法再在除 Channel 外的任何地方使用这个指针。</p>

<p>完美的 Channel 模型应当是 <em><strong>MPMC (multi-producer, multi-consumer)</strong></em> 类型， 简单的 <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt; + CondVar</code> 组合能够实现 MPMC 但正如前述所言， 使用锁会降低效率。 比如在 Go 语言中实现了基于锁的安全的 MPMC Channel， 虽然使用了 <strong>futex (fast userspace mutex)</strong> 但由于锁的存在而效率低下。 因而， 标准的 Rust 库中实现的是 <em><strong>MPSC (multi-producer, single-consumer)</strong></em>， 这种实现方式有如下优缺点：</p>

<ul>
  <li>优点
    <ul>
      <li>适用于归约数据汇总的场合， 多个线程需要将结果统一发送给一个单独的线程。</li>
      <li>可以退化为 <em><strong>SPSC(single-producer, single-consumer)</strong></em> 进行线程与线程之间独立的通信。</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>当我们想分发数据的时候即一对多时， 情况就比较难办且复杂了。</li>
      <li>Rust 标准库中的 Channel 比较古老， 一些术语和标准没有统一， 不仅难用而且很有可能会被替代。</li>
    </ul>
  </li>
</ul>

<p><a href="https://docs.rs/crossbeam/0.7.3/crossbeam/">crossbeam</a> 是 Rust 官方指定的 Channel 的实现库， 实现了 MPMC 的特性， 改进了很多 API， 甚至比当前的标准库的实现还要快上不少。</p>

<h2 id="2-crossbeam-channel">2. crossbeam Channel</h2>

<p>这里使用 CS110L 课程的 farm v3.0 这个例子对 Channel 的使用进行解释说明。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="n">crossbeam_channel</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">core</span><span class="p">::</span><span class="n">num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">thread</span><span class="p">,</span> <span class="n">time</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">factor_number</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// unbounded 表示使用的内存是无上限的</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">crossbeam</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="nf">unbounded</span><span class="p">();</span>
    
    <span class="k">let</span> <span class="k">mut</span> <span class="n">threads</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="nn">num_cpus</span><span class="p">::</span><span class="n">get</span> <span class="p">{</span>
        <span class="c1">// 创建一个 receiver 的拷贝， 避免下一个线程因所有权转移而无法使用 receiver</span>
        <span class="k">let</span> <span class="n">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">threads</span><span class="nf">.push</span><span class="p">(</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">next_num</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">factor_number</span><span class="p">(</span><span class="n">next_num</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">stdin</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">stdin</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"Tried writing to channel, but there are no receivers!"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果没有调用 drop， 那么通道关闭的两个条件： 发送者全部 drop 或接收者被 drop 就无法满足。</span>
    <span class="c1">// 那么对于子线程而言， 如果它想从 while 循环中跳出必须要让 recv() 返回一个 Err()， 只有提早</span>
    <span class="c1">// 通过 drop 函数关闭了 sender 才能让 Channel 关闭， 让子线程完成处理。</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">thread</span> <span class="k">in</span> <span class="n">threads</span> <span class="p">{</span>
        <span class="n">thread</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Panic occurred in thread"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-参考">3. 参考</h2>

<ul>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-12.pdf">CS110L, Spring 2020: Channels</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/slides/lecture-11.pdf">CS110L, Spring 2020: Synchronization</a></li>
  <li><a href="https://reberhardt.com/cs110l/spring-2020/lecture-notes/lecture-11/">CS110L, Spring 2020: Synchronization in Rust</a></li>
  <li><a href="https://course.rs/advance/concurrency-with-threads/message-passing.html#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93">Rust Course: Channel</a></li>
</ul>

<p class="error">Thanks for Roberto Huertas providing the background image, you can find some from his blog: <a href="https://robertohuertas.com/2019/12/08/wallpapers-for-the-rust-of-us/">Wallpapers for the Rust of us</a></p>]]></content><author><name>HangX-Ma</name></author><category term="rust" /><summary type="html"><![CDATA[学习 CS110L Spring20 课程 Lecture 12： Channel， 总结相关原理及用法。]]></summary></entry><entry><title type="html">MDIO (Management Data Input/Output)</title><link href="https://hangx-ma.github.io/2023/06/06/net-mdio.html" rel="alternate" type="text/html" title="MDIO (Management Data Input/Output)" /><published>2023-06-06T00:00:00+08:00</published><updated>2023-06-06T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/06/06/net-mdio</id><content type="html" xml:base="https://hangx-ma.github.io/2023/06/06/net-mdio.html"><![CDATA[<h2 id="1-mdio-简介">1. MDIO 简介</h2>

<p><a href="#ref-mdio-wiki">wiki</a> 中这样定于 <em><strong>MDIO（Management Data Input/Output）</strong></em>： <em>MDIO 是 IEEE 802.3 标准定义一种两线以太网串行总线用于 <strong>MII（Media Independent Interface）</strong>， 有时关于 MDIO 我们还会说到 <strong>SMI（Serial Management Interface）</strong> 或者 <strong>MIIM（Media Independent Interface Management）</strong></em>。SMI/MDIO 协议用来管理 <em><strong>MAC（Media Access Controller）</strong></em> 与 <em><strong>PHY（Physical）</strong></em> 两个网络层之间的数据传输。 控制 MDIO 总线的设备称为 <em><strong>STA（Station Management Entity）</strong></em> 而被 MDIO 总线管理的设备称为 <em><strong>MMD（MDIO Manageable Device）</strong></em>。</p>

<blockquote>
  <p>MDIO 上层是 MII 其有两个接口： 数据接口连接以太网 MAC 层， 用以发送和接收以太网帧数据； 另外一个 PHY 管理接口了， 也就是我们所说的 MDIO 接口。</p>
</blockquote>

<p>MMD 一般是指 PHY 设备这类 MDIO 从设备， MDIO 接口会连接控制单元控制 PHY 设备以及获取其状态 （读写寄存器）。 每个 PHY 设备能在执行操作之前监视， 在执行操作时则可通过寄存器监视其状态。 这些寄存器提供了状态和控制信息， 包括 <em>link status, speed ability and selection, power down for low power consumption, duplex mode (full or half), auto-negotiation, fault signalling, loopback</em>。 MDIO 协议的作用就是配置 PHY 层所需要的接收/发送的参量。</p>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/mdio-interface-layout.png" alt="MDIO interface layout" width="600" />
    <br />
    <font size="2" color="#999"><u>MDIO interface layout</u></font>
</div>

<p>前述所说， MDIO 是一种双线协议， 其接口由两种信号构成：</p>

<ul>
  <li><strong>MDIO Data Clock（MDC）：</strong> 由 MAC 设备驱动的连接到 PHY 设备的时钟信号。</li>
  <li><strong>MDIO Data：</strong> 双向的数据传输， 所有的设备都依据 MDC 同步 （synchronous） 传输。</li>
</ul>

<p>虽然 MDIO 的是一种最高仅有 2.5 MHz 的低速总线 （最新的 DP83640 已经能支持 25 MHz）， 最开始是由 IEEE 802.3 的 Clause 22 定义， 后为了满足对 10G 以太网的设备需求在 IEEE 802.3ae 定义了 Clause 45。 对于 MDIO 总线而言其仅有一个主设备， 但能有多达 32 个 PHY 从设备。</p>

<blockquote>
  <p>MDIO 主从设备的控制器有不同的协议适用要求：</p>

  <ul>
    <li>MDIO master controller: Clause 22 和 Clause 45 均可</li>
    <li>MDIO slave controller: Clause 22</li>
    <li>MDIO slave controller: Clause 45</li>
  </ul>
</blockquote>

<h2 id="2-clause-22">2. Clause 22</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause22-frame-format.png" alt="Clause 22 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 22 format format</u></font>
</div>

<p>Clause 22 的帧格式只允许 5 bit 物理层地址和寄存器地址， 这限制了 STA 可以连接的 MMD 的数量。 此外，Clause 22 MDIO 只支持限压 5V 的设备且不支持多设备的 PHY。</p>

<h2 id="3-clause-45">3. Clause 45</h2>

<div align="center">
    <img src="/norobots/images/2023-06-06-net-mdio/clause45-frame-format.png" alt="Clause 45 format format" width="800" />
    <br />
    <font size="2" color="#999"><u>Clause 45 format format</u></font>
</div>

<p>Clause 45 更改了寄存器的读写模式， 不同于 Clause 22 将寄存器读写数据以及地址都放在一个独立帧， Clause 45 分成了两帧进行传输， 第一帧为地址帧确定 MMD 和 寄存器， 第二帧为数据帧进行数据的读写。 这种设计不仅向后兼容 Clause 22， 并且将地址从 5 bit 扩展到了 16 bit， 使得寄存器的访问数量从 32 个增加到了 65535 个。 另外 Clause 45 支持 32 个端口， 每个端口都能支持 32 个 MMD 设备。</p>

<h2 id="4-mdio-与-phy-与-nic">4. MDIO 与 PHY 与 NIC</h2>

<p>网卡 （NIC） 工作在 OSI 的最后两层， 物理层和数据链路层</p>

<ul>
  <li><strong>物理层</strong> 定义了数据传送与接收所需要的电与光信号、 线路状态、 时钟基准、 数据编码和电路等， 并向数据链路层设备提供标准接口。</li>
  <li><strong>数据链路层</strong> 则提供寻址机制、 数据帧的构建、 数据差错检查、 传送控制、 向网络层提供标准的数据接口等功能。 以太网卡中数据链路层的芯片称之为 MAC 控制器。</li>
</ul>

<p>物理层的芯片称之为 PHY。 IEEE-802.3 标准定义了以太网 PHY。 包括 <em><strong>MII（Media Independent Interface）</strong></em> 子层， <em><strong>PCS（Physical Coding Sublayer）</strong></em>， <em><strong>PMA（Physical Medium Attachment）</strong></em> 子层， <em><strong>PMD（Physical Medium Dependent）</strong></em> 子层， <em><strong>MDI（Medium Dependent Interface）</strong></em> 子层， 符合 IEEE-802.3k 中用于 10BaseT 和 100BaseTX 的规范。</p>

<p>PHY 和 MAC 之间通过 IEEE 定义的标准的 <em><strong>MII（Media Independent Interface）</strong></em> 连接 MAC 和 PHY。 MII 传递了网络的所有数据和数据的控制。 以太网接口实质是 MAC 通过 MII 总线控制 PHY 的过程。 按照前述内容可知， IEEE 定义了 MDIO 总线服务于 MII 用以与 PHY 的通信。</p>

<h2 id="5-参考">5. 参考</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Management_Data_Input/Output">Management Data Input/Output - wikipedia</a> <a id="ref-mdio-wiki"></a></li>
  <li><a href="https://www.latticesemi.com/-/media/LatticeSemi/Documents/ReferenceDesigns/JM/MDIOMasterandSlaveControllersDocumentation.ashx?document_id=50604">MDIO Master and Slave Controllers - LATTICE-semiconductor</a></li>
  <li><a href="https://prodigytechno.com/mdio-management-data-input-output/">MDIO ( Management Data Input/Output )</a></li>
  <li><a href="https://www.totalphase.com/support/articles/200349206-mdio-background/">MDIO Background</a></li>
  <li><a href="https://grouper.ieee.org/groups/802/3/ae/public/jul00/law_1_0700.pdf">IEEE P802.3ae 10Gb/s Ethernet MDC/MDIO Proposal</a></li>
  <li><a href="https://www.cnblogs.com/jason-lu/articles/3195473.html">网口扫盲三:以太网芯片MAC和PHY的关系</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Network" /><category term="Linux" /><summary type="html"><![CDATA[介绍 MDIO 以及与其相关的 clause 22， clause 45 协议。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 6: putting it all together</title><link href="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 6: putting it all together" /><published>2023-05-31T00:00:00+08:00</published><updated>2023-05-31T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/31/cs144-lab6</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/31/cs144-lab6.html"><![CDATA[<p>记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab6 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check6.pdf">Lab Checkpoint 6: putting it all together</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简介">1. 内容简介</h2>

<p>Lab6 是一个选择性的实验， 在前 6 个实验中我们已经完成了网络的框架， Checkpoint 0 (a reliable byte stream), Checkpoints 1–3 (the Transmission Control Protocol), Checkpoint 4 (an IP/Ethernet network interface) 以及 Checkpoint 5 (an IP router)， 该实验的目的是使用前述的网络栈实现真实的网络通信， 这需要我们有个 partner， 一人分饰两角也是可以的。</p>

<h2 id="2-the-network">2. The Network</h2>

<p>在该实验中需要一对可行的网络栈组合成一个真实的网络通信环境， 两方都需要构建 host 和 router， 网络拓扑如下图所示：</p>

<div align="center">
    <img src="/norobots/images/2023-05-31-cs144-lab6/the-network.png" alt="The Network" width="600" />
    <br />
    <font size="2" color="#999"><u>The Network</u></font>
</div>

<ol>
  <li>对于个人而言， 需要使用同一套代码在不同的终端中启用 server 以及 client。</li>
  <li>为了使用 relay， 我们需要选择任意的一个 1024 到 64000 之间的偶数以区分不同的 group。 我们可以选择 “4088”。</li>
  <li>
    <p>server 端在 build 文件夹下输入 <code class="language-plaintext highlighter-rouge">./apps/endtoend server cs144.keithw.org 4088</code>， 若顺利的话 server 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend server cs144.keithw.org 4088
 DEBUG: Network interface has Ethernet address 02:00:00:91:a1:8f and IP address 172.16.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:bf:ba:0e and IP address 10.0.0.172
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> 10.0.0.192 on interface 1
 DEBUG: Network interface has Ethernet address 9a:c0:ea:b5:88:82 and IP address 172.16.0.100
 DEBUG: Listening <span class="k">for </span>incoming connection...
</code></pre></div>    </div>
  </li>
  <li>
    <p>client 端在 build 文件夹下输入 <code class="language-bash highlight highlighter-rouge">./apps/endtoend client cs144.keithw.org 4089</code>， 若顺利的话 client 端会打印如下信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cs144@cs144-ubuntu22:~/minnow/build<span class="nv">$ </span>./apps/endtoend client cs144.keithw.org 4089
 DEBUG: Network interface has Ethernet address 02:00:00:e0:84:14 and IP address 192.168.0.1
 DEBUG: Network interface has Ethernet address 02:00:00:e8:1a:da and IP address 10.0.0.192
 DEBUG: adding route 192.168.0.0/16 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 0
 DEBUG: adding route 10.0.0.0/8 <span class="o">=&gt;</span> <span class="o">(</span>direct<span class="o">)</span> on interface 1
 DEBUG: adding route 172.16.0.0/12 <span class="o">=&gt;</span> 10.0.0.172 on interface 1
 DEBUG: Network interface has Ethernet address 7e:fa:65:55:c7:4e and IP address 192.168.0.50
 DEBUG: Connecting from 192.168.0.50:7907...
 DEBUG: Connecting to 172.16.0.100:1234...
 Successfully connected to 172.16.0.100:1234.
</code></pre></div>    </div>

    <p>并且 server 端会额外打印一条信息：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> New connection from 192.168.0.50:7907.
</code></pre></div>    </div>
  </li>
  <li>
    <p>若以上信息都能正确打印， 则意味着 TCP 握手成功， 若有问题则需要在之前的命令后加上 <code class="language-plaintext highlighter-rouge">debug</code> 进入 debug 模式进行调试。</p>

    <ul>
      <li>我们可以在 server 或者 client 任意一端输入数据， 就能在相应的另一端看到数据。
        <blockquote>
          <p>经过测试发现需要在 Terminal 输入需要发送的数据后按下 Ctrl-D 才能发送数据并在 remote 端看到。</p>
        </blockquote>
      </li>
      <li>可以使用 Ctrl-D 关闭链接。 server 或 client 关闭链接后会终止那一端的 ByteStream 的输出， 但仍会持续接收数据直到另一端也关闭了 ByteStream 的输出， 我们需要验证这点。
        <blockquote>
          <p>首先需要确保 Terminal 中已经没有数据了， 此时我们按下 Ctrl-D 才会断开 TCP 的链接。</p>
        </blockquote>
        <ul>
          <li>
            <p><em><strong>server</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  DEBUG: Outbound stream to 192.168.0.50:36742 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Inbound stream from 192.168.0.50:36742 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:36742 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p><em><strong>client</strong></em></p>

            <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># press Ctrl-D at server</span>
  <span class="c">######## Nothing ########</span>
  <span class="c"># press Ctrl-D at client</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>当 server 和 client 都关闭 ByteStream 输出后并且一端又持续存在数秒后， 两边的程序应该会正常退出。</li>
    </ul>
  </li>
</ol>

<h2 id="3-文件传输">3. 文件传输</h2>

<h3 id="31-操作流程">3.1 操作流程</h3>

<p>当基本的通信功能实现之后就可以通过网络进行文件的传输。</p>

<ul>
  <li>
    <p>将 1M 大小的随机数写入文件 <code class="language-plaintext highlighter-rouge">/tmp/big.txt</code>。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/urandom <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>1 <span class="nv">of</span><span class="o">=</span>/tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 server 端在接受连接后立刻发送文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ./apps/endtoend server cs144.keithw.org 4088 &lt; /tmp/big.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>让 client 端关闭输出数据流并下载文件。</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;/dev/null ./apps/endtoend client cs144.keithw.org 4089 <span class="o">&gt;</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
  <li>
    <p>比较两个文件确保二者一致</p>

    <div class="snippet">
      <div class="language-bash copyable highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">sha256sum</span> /tmp/big.txt
  <span class="nb">sha256sum</span> /tmp/big-received.txt
</code></pre></div>      </div>
    </div>
  </li>
</ul>

<p>如果 SHA-256 哈希值都能匹配上， 那我们就可以确定文件被正确传输了。</p>

<h3 id="32-输出打印">3.2 输出打印</h3>

<ul>
  <li>
    <p><em><strong>server</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Inbound stream from 192.168.0.50:27200 finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown...
  DEBUG: Outbound stream to 192.168.0.50:27200 finished <span class="o">(</span>63000 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 192.168.0.50:27200 has been fully acknowledged.
  DEBUG: TCP connection finished cleanly.
  <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>client</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  DEBUG: Outbound stream to 172.16.0.100:1234 finished <span class="o">(</span>0 seqnos still <span class="k">in </span>flight<span class="o">)</span><span class="nb">.</span>
  DEBUG: Outbound stream to 172.16.0.100:1234 has been fully acknowledged.
  DEBUG: Inbound stream from 172.16.0.100:1234 finished cleanly.
  DEBUG: TCP connection finished cleanly.
  DEBUG: Waiting <span class="k">for </span>clean shutdown... <span class="k">done</span><span class="nb">.</span>
  Exiting... <span class="k">done</span><span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em><strong>SHA-256</strong></em></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big.txt
  e0462e19b156c6a02c9f89f4069b624b4eefd1a4837c5d71397db3253d469ce1  /tmp/big-received.txt
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab6: putting it all together 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 5: building an IP router</title><link href="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 5: building an IP router" /><published>2023-05-30T00:00:00+08:00</published><updated>2023-05-30T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/30/cs144-lab5</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/30/cs144-lab5.html"><![CDATA[<p>记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab5 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check5.pdf">Lab Checkpoint 5: building an IP router</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/check5-structure.png" alt="IP router structure" width="500" />
    <br />
    <font size="2" color="#999"><u>IP router structure</u></font>
</div>

<p>Lab5 要求实现一个简易的路由器， 通常路由器会有多个网络接口， 能够从任意一个接口接收网络数据报。 路由器的作用就是将 datagrams 依据 <strong>路由表</strong> 进行转发， 路由表定义了路由转发的一些规则：</p>

<ul>
  <li>确定转发的接口</li>
  <li>确定下一跳的 IP 地址</li>
</ul>

<p>在 Lab5 中需要实现一个新的 <code class="language-plaintext highlighter-rouge">Router</code> 类， 该类能够 <em>跟踪路由表信息</em> 并且 <em>将接收到的每个 datagram 通过正确的输出端 <strong>NetworkInterface</strong> 正确转发到下一跳 （hop）</em>。 在项目指导书中明确解释了 <em><strong>route</strong></em> 的相关含义， 后续需要通过 IP 的最长前缀匹配来实现路由的功能， 这也是实验中最为棘手的部分。</p>

<h2 id="2-ip-router-实现">2. IP Router 实现</h2>

<ol>
  <li>
    <p><strong>add_route：</strong> 调用该方法将路由信息添加到路由表中， 我们需要自己添加存储相关信息的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">add_route</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">,</span> 
                 <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">interface_num</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>根据 <code class="language-plaintext highlighter-rouge">add_route</code> 所给的参数以及 <a href="https://en.wikipedia.org/wiki/Routing_table">wiki</a> 中对 routing table 内容的描述， 我们需要自己创建如下的数据结构。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Routing table data structure</span>
 <span class="k">using</span> <span class="n">route_t</span> <span class="o">=</span> <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">uint32_t</span> <span class="n">route_prefix</span><span class="p">;</span>
     <span class="kt">uint8_t</span> <span class="n">prefix_length</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Address</span><span class="o">&gt;</span> <span class="n">next_hop</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">interface_id</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">route_t</span><span class="o">&gt;</span> <span class="n">routing_table_</span> <span class="p">{};</span>
</code></pre></div>    </div>

    <blockquote>
      <p><a href="https://en.wikipedia.org/wiki/Routing_table">wikipedia - Routing table</a></p>
    </blockquote>
  </li>
  <li>
    <p><strong>route：</strong> 该方法需要对输入的 datagrams 进行路由， 将其通过正确的网络接口转发到下一跳， 这需要实现 <strong>“最长前缀匹配 （longest-prefix match）”</strong> 以找到最合适的路由方案， 该方法有如下细节需要实现：</p>

    <ul>
      <li>路由器需要搜索路由表找到匹配 datagrams 中的目的地址的那个路由。 这意味着目的地址的 <em>prefix_length</em> 需要与 <em>route_prefix</em> 的 <em>prefix_length</em> 完全一致。</li>
      <li>在匹配的路由方案中路由器选择 <em>prefix_length</em> 值最大的那个， 选中的就是满足 “最长前缀匹配” 的路由。</li>
      <li>如果没有匹配的路由信息， 则丢弃该项 datagram。</li>
      <li>每一跳的路由器都需要减少 datagrams 的 ttl。 如果 ttl 已经归零或者在本次减除后触及零的下界， 路由器同样需要丢弃该项 datagram。</li>
      <li>最终， 路由器需要将修改过的 datagram 通过合适的网络接口 （<code class="language-plaintext highlighter-rouge">interface(interface num).send datagram()</code>） 发送到下一跳。</li>
    </ul>

    <p>整个过程中， 路由器仅需要和 datagram 以及链接层的网络接口抽象进行交互， 完全不需要考虑 TCP， ARP 以及以太网帧， 较好实现了分层隔离， 降低了路由器的处理负担。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">route</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="3-网络拓扑">3. 网络拓扑</h2>

<div align="center">
    <img src="/norobots/images/2023-05-30-cs144-lab5/simulated-router-and-interfaces.png" alt="Simulated router and interfaces topology" width="600" />
    <br />
    <font size="2" color="#999"><u>Simulated router and interfaces topology</u></font>
</div>

<h2 id="4-坑点记录">4. 坑点记录</h2>

<p>测试的时候有这样一条记录（就是第一个测试都没过啦）， 当时觉得很奇怪怎么会有 <code class="language-plaintext highlighter-rouge">bad IPv4 datagram</code> 的打印， 查看后是 <code class="language-plaintext highlighter-rouge">InternetDatagram</code> 的 <code class="language-plaintext highlighter-rouge">parse</code> 返回了错误。 于是我给 <code class="language-plaintext highlighter-rouge">set_error</code> 的部分都加上了打印才发现是 <strong>checksum</strong> 未匹配。 我还以为是 <em><strong>NetworkInterface</strong></em> 部分的接收部分没有写好， 调试了半天就想着要不要用 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 在 <code class="language-plaintext highlighter-rouge">recv_frame</code> 中重新把 checksum 计算一下， 这时候突然发现这个函数的接口都是 <code class="language-plaintext highlighter-rouge">const</code> 类型， 并且结合 <em><strong>NetworkInterface</strong></em> 在 <em>link layer</em> 与 <em>application</em> 之间的情况， 以及错误是出现在以太网帧传输到 router 再转发出去的， 唯一有嫌疑的应当还是刚刚写的 <em><strong>Router</strong></em> 类。</p>

<p>在读 <code class="language-plaintext highlighter-rouge">router.cc</code> 代码考虑把 <code class="language-plaintext highlighter-rouge">compute_checksum</code> 加在哪里的时候我突然看到 ttl 的值被我更改了。 这不就是问题根源嘛， 我们更新了 <em><strong>InternetDatagram</strong></em> 的内容， 那么 checksum 也需要重新计算。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Testing traffic between two ordinary hosts <span class="o">(</span>applesauce to cherrypie<span class="o">)</span>...

Host applesauce trying to send datagram <span class="o">(</span>with next hop <span class="o">=</span> 10.0.0.1<span class="o">)</span>: 
    IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 
    <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/10.0.0.1

Transferring frame from router.eth0 to applesauce: 
    <span class="nv">dst</span><span class="o">=</span>16:4e:eb:3a:a2:3d, <span class="nv">src</span><span class="o">=</span>02:00:00:dd:27:73, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:dd:27:73/10.0.0.1, <span class="nv">target</span><span class="o">=</span>16:4e:eb:3a:a2:3d/10.0.0.2

Transferring frame from applesauce to router.eth0: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:dd:27:73, <span class="nv">src</span><span class="o">=</span>16:4e:eb:3a:a2:3d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: IPv4: IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, 
    <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2 <span class="nv">payload</span><span class="o">=</span><span class="s2">"random payload: {613419936}"</span>

Transferring frame from router.eth2 to cherrypie: 
    <span class="nv">dst</span><span class="o">=</span>ff:ff:ff:ff:ff:ff, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nb">type</span><span class="o">=</span>ARP, 
    payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REQUEST, 
    <span class="nv">sender</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1, <span class="nv">target</span><span class="o">=</span>00:00:00:00:00:00/192.168.0.2

Transferring frame from cherrypie to router.eth2: 
    <span class="nv">dst</span><span class="o">=</span>02:00:00:a1:96:8d, <span class="nv">src</span><span class="o">=</span>ea:80:f1:26:53:c8, 
    <span class="nb">type</span><span class="o">=</span>ARP, payload: ARP: <span class="nv">opcode</span><span class="o">=</span>REPLY, 
    <span class="nv">sender</span><span class="o">=</span>ea:80:f1:26:53:c8/192.168.0.2, <span class="nv">target</span><span class="o">=</span>02:00:00:a1:96:8d/192.168.0.1

Transferring frame from router.eth2 to cherrypie: 
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="nv">dst</span><span class="o">=</span>ea:80:f1:26:53:c8, <span class="nv">src</span><span class="o">=</span>02:00:00:a1:96:8d, 
    <span class="nb">type</span><span class="o">=</span>IPv4, payload: bad IPv4 datagram
    <span class="o">[</span>ERROR]: <span class="s1">'IPv4Header::parse'</span> Checksum is not matched
    <span class="o">[</span>NetworkInterface ERROR]: <span class="s1">'recv_frame'</span> IPV4 parse error



Error: Host cherrypie did NOT receive an expected Internet datagram: 
        IPv4, <span class="nv">len</span><span class="o">=</span>2f, <span class="nv">protocol</span><span class="o">=</span>6, <span class="nv">src</span><span class="o">=</span>10.0.0.2, <span class="nv">dst</span><span class="o">=</span>192.168.0.2
</code></pre></div></div>

<h2 id="5-测试结果">5. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check5
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/3 Test  <span class="c">#1: compile with bug-checkers ........   Passed   44.90 sec</span>
    Start 35: net_interface
2/3 Test <span class="c">#35: net_interface ....................   Passed    0.20 sec</span>
    Start 36: router
3/3 Test <span class="c">#36: router ...........................   Passed    0.17 sec</span>

100% tests passed, 0 tests failed out of 3

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  45.41 sec
Built target check5
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab5: building an IP router 的思路与实践难点。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)</title><link href="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 4: down the stack (the network interface)" /><published>2023-05-27T00:00:00+08:00</published><updated>2023-05-27T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/27/cs144-lab4</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/27/cs144-lab4.html"><![CDATA[<p>记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 <em><strong>TCPReceiver</strong></em> 和 <em><strong>TCPSender</strong></em> 结合起来）。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab4 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check4.pdf">Lab Checkpoint 4: down the stack (the network interface)</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<div align="center">
    <img src="/norobots/images/2023-05-27-cs144-lab4/check4-structure.png" alt="network interface structure" width="300" />
    <br />
    <font size="2" color="#999"><u>network interface structure</u></font>
</div>

<p>Lab4 要求实现网络接口部分， 打通网络数据报 （Internet datagrams） 和链路层的以太网帧（link-layer Ethernet frames） 之间的桥梁。 之前的实验实现了 TCP segments 在使用 TCP 协议的设备之间的传输， 而 TCP 报文是如何传递的？ TCP报文有三种方式可被传送至远程服务器：</p>

<ul>
  <li>
    <p><em><strong>TCP-in-UDP-in-IP：</strong></em> TCP 报文会被置于用户的数据报的 payload 中， 在用户空间下这是最简单的实现方式： Linux 提供接口 （如 <em><strong>UDPSocket</strong></em>）， 而用户侧仅需要提供 payload， 目标地址， Linux 内核会负责将 UDP 报部， IP 报头， 以太网报头组装起来， 将这个网络包发向下一个 hop。 <strong>Linux 内核会保证每个 socket 会有独立的本地与远端地址以及端口号， 并且保证这些数据在应用层的相互隔离</strong>。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP：</strong></em> 一般情况下， TCP 报文会直接放在 Internet datagrams 中， 这通常被成为 “TCP/IP”。 Linux 会提供一个 TUN 设备接口， 需要应用层提供整个 Internet datagram， 而 Linux 内核则会处理剩下的部分。 但此时应用层需要自己构建整个 IP 报头以及 payload 部分。</p>
  </li>
  <li>
    <p><em><strong>TCP-in-IP-in-Ethernet：</strong></em> 以上的方法依赖Linux内核来实现的协议栈操作， 每次用户向 TUN 设备写入 IP datagrams 时， Linux 都需要构建正确的带有 IP datagrams 的以太网帧作为 payload。 这意味着 Linux 需要知悉下一个 hop 的以太网目的地址， 给出其 IP 地址。 否则 Linux 会以广播的形式请求这些信息。</p>

    <p>这些功能是由 <em><strong>Network Interface</strong></em> 实现的， 该组件能将 IP 数据报转义成以太网帧等等， 之后会传入 TAP 设备 （类似 TUN 设备但更底层）， 实现对 link-layer 的数据帧的传输。</p>
  </li>
</ul>

<p>网络接口的大部分工作是， <strong>为每个下一跳 IP 地址查找(和缓存)以太网地址</strong>。而这种协议被称为 <strong>地址解析协议 ARP （Address Resolution Protocol）</strong>。</p>

<blockquote>
  <p><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">Address Resolution Protocol - wiki</a></p>
</blockquote>

<h2 id="2-network-interface-实现">2. Network Interface 实现</h2>

<h3 id="21-默认接口">2.1 默认接口</h3>

<p>在 Lab4 的 <em><strong>Network Interface</strong></em> 中我们需要实现以下几个部分， 维护一个 IP 地址到 Ethernet 地址的映射表。 这个映射类似缓存， 能提高网络栈的传输效率。</p>

<ol>
  <li><strong>send datagram：</strong> 该方法被 TCPConnection 或者 router 所调用， 这个接口就是将待发送的 Internet(IP) datagrams 转义为以太网帧并最终发送出去。
    <ul>
      <li>如果以太网目的地址是已知的就直接发送， 创建以太网帧 （<code class="language-plaintext highlighter-rouge">type = EthernetHeader::TYPE IPv4</code>）， 将 payload 设置为串行的数据报文， 并设置源地址和目标地址。</li>
      <li>如果以太网目的地址未知， 广播下一跳的以太网地址的 ARP 请求， 并将 IP 报文放入队列中待 ARP 回复收到后能将其发送出去。
        <blockquote>
          <p>需要间隔 5 秒再发送相同的 ARP 请求， 并且只有在收到目的以太网地址后再将数据报放入队列中。 若没有收到目的以太网地址， 我们需要将 dgrams 以及其对应的 Address 都暂存在列表中， 以供之后收到 ARP reply 后再进行发送， 否则这部分数据就会丢失了。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">send_datagram</span><span class="p">(</span><span class="k">const</span> <span class="n">InternetDatagram</span> <span class="o">&amp;</span><span class="n">dgram</span><span class="p">,</span> <span class="k">const</span> <span class="n">Address</span> <span class="o">&amp;</span><span class="n">next_hop</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>recv frame：</strong> 该方法接收来自网络的以太网帧， 但需要忽略任何目的地址非网络接口部分的帧 （广播地址或者存储在 <code class="language-plaintext highlighter-rouge">_ethernet_address</code> 中的接口自身的以太网地址）。
    <ul>
      <li>若为 IPv4 帧就将其以 <em><strong>InternetDatagramF</strong></em> 进行解析， 若成功的就将结果的 <em><strong>InternetDatagramF</strong></em> 返回给调用者。</li>
      <li>若为 ARP 帧就将其以 <em><strong>ARPMessage</strong></em>  进行解析， 若成功则缓存发送方 IP 地址与以太网帧的映射 30 秒。 若这个 ARP 请求是询问我们的 IP 地址， 就回复正确的 ARP 答复。
        <blockquote>
          <p>根据 FAQs 中的答疑， 我们需要自行创建一个用以存储映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>。</p>
        </blockquote>
      </li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">InternetDatagram</span><span class="o">&gt;</span> <span class="n">recv_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">EthernetFrame</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>maybe send：</strong> 该方法在必要时发送 <em><strong>EthernetFrame</strong></em>。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">maybe_send</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>tick：</strong> 记录时间， 以使得任何已经过期的 IP 地址到 Ethernet 地址的映射失效。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p class="warning"><em><strong>FAQs and special cases</strong></em> 中的信息都很有帮助， 可以当作一种提供解题思路的 Hints。</p>

<h3 id="22-额外说明">2.2 额外说明</h3>

<h4 id="ethernet-frames">Ethernet Frames</h4>

<p><em><strong>EthernetFrame</strong></em> 是我们需要传输给 TAP 设备的数据， 根据已有信息， 我们只需要将组装好的 <em><strong>EthernetFrame</strong></em> 用 <code class="language-plaintext highlighter-rouge">queue</code> 数据结构封装即可。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// outbound Ethernet frames which will be sent by the Network Interface</span>
<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">EthernetFrame</span><span class="o">&gt;</span> <span class="n">outbound_frames_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="arp-table">ARP Table</h4>

<p>从以上接口的描述可以看出， 我们需要建立一个存储 ARP 映射的 <code class="language-plaintext highlighter-rouge">arp_table_</code>， IP-To-Ethernet。 根据 <a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">wiki</a> 关于 ARP 原理章节的阐述， 这个表中的 ARP 数据需要有一个变量存储 <em><strong>EthernetFrame</strong></em> 表示映射目标， 以及 <em><strong>ttl (time-to-live)</strong></em> 表示该条 ARP 信息的生命周期 （默认是 30s）。 另外，在 FAQs 中有这么一句：</p>

<p class="info"><strong>Q:</strong> <em>How do I convert an IP address that comes in the form of an Address object, into a raw 32-bit integer that I can write into the ARP message?</em>
<br />
<strong>A:</strong> Use the <code class="language-plaintext highlighter-rouge">Address::ipv4 numeric()</code> method.</p>

<p>这说明 ARP 的映射应当是 <code class="language-plaintext highlighter-rouge">uint32_t</code> 类型到 <code class="language-plaintext highlighter-rouge">arp_t</code> 类型， 我们可以用一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储映射信息。 除此之外我们还注意到， 同一个 ARP 的 ARP 请求的间隔需要 5s， 那么除了映射信息外， 我们还需要一个 <code class="language-plaintext highlighter-rouge">list</code> 结构用以存储绑定 <em><strong>InternetDatagram</strong></em> 和 <em><strong>Address</strong></em> 的等待列表 <code class="language-plaintext highlighter-rouge">arp_datagrams_waiting_list_</code>。 另外， 为了记录 ARP 请求的声明周期， 我们还需要一个 <code class="language-plaintext highlighter-rouge">unordered_map</code> 数据结构存储 <em><strong>numeric IP</strong></em> 与该条 ARP 请求的声明周期的映射 <code class="language-plaintext highlighter-rouge">arp_requests_lifetime_</code>。</p>

<blockquote>
  <p>这里使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构是头文件中已经包含了相关的库文件， 另外这部分信息具有时效的不确定性， 我们并不清楚 ARP 请求究竟哪一个会在下一刻返回， 所以在这部分信息我们需要逐个遍历， 将已经获取目标以太网地址的数据包组装后放入发送队列中， 并从 <code class="language-plaintext highlighter-rouge">list</code> 中移除。 故而使用 <code class="language-plaintext highlighter-rouge">list</code> 数据结构能够利用链表插入/移除数据的快速性的优势， 而不用考虑查询带来的负面影响。</p>
</blockquote>

<p>这样关于 ARP Table 的数据结构就可以按如下格式创建。 需要注意的是 TTL 的时间单位是 ‘毫秒’， 而我们设定的边界值都是以 ‘秒’ 为单位。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ARP will be stored for 30s at most, which can reduce the length of ARP table,</span>
<span class="c1">// increasing the enquiry speed. What's more, </span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">ARP_REQUEST_DEFAULT_TTL</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">arp</span> <span class="p">{</span>
    <span class="n">EthernetAddress</span> <span class="n">eth_addr</span><span class="p">;</span> <span class="c1">// mac address</span>
    <span class="kt">size_t</span> <span class="n">ttl</span><span class="p">;</span> <span class="c1">// time to live</span>
<span class="p">}</span> <span class="n">arp_t</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="cm">/* ipv4 numeric */</span><span class="p">,</span> <span class="n">arp_t</span><span class="o">&gt;</span> <span class="n">arp_table_</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Address</span><span class="p">,</span> <span class="n">InternetDatagram</span><span class="o">&gt;&gt;</span> <span class="n">arp_requests_waiting_list_</span> <span class="p">{};</span>
</code></pre></div></div>

<h4 id="内存泄漏">内存泄漏</h4>

<p>在遍历 ARP Table 的时候我用了迭代器， 但是调用了 <code class="language-plaintext highlighter-rouge">erase</code> 函数之后又用了 <code class="language-plaintext highlighter-rouge">iter++</code> 去获取下一个 ARP 项， 这产生了矛盾， 当前的迭代器的内存空间已经被释放了。 因而使用 <code class="language-plaintext highlighter-rouge">erase</code> 函数需要注意使用 <code class="language-plaintext highlighter-rouge">iter = xxx.erase(iter);</code> 来更新迭代器的内容。</p>

<h2 id="3-测试结果">3. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check4
<span class="o">[</span>1/1] <span class="nb">cd</span> /home/cs144/minnow/build <span class="o">&amp;&amp;</span> /usr/bin/ctest <span class="nt">--output-on-failure</span> <span class="nt">--stop-on-failure</span> <span class="nt">--timeout</span> 12 <span class="nt">-R</span> <span class="s1">'^net_interface'</span>
Test project /home/cs144/minnow/build
    Start  1: compile with bug-checkers
1/2 Test  <span class="c">#1: compile with bug-checkers ........   Passed   20.14 sec</span>
    Start 35: net_interface
2/2 Test <span class="c">#35: net_interface ....................   Passed    0.15 sec</span>

100% tests passed, 0 tests failed out of 2

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  20.29 sec
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab4: down the stack (the network interface) 的思路与实践难点。 与以往实验不同的是， spring 2023 版本没有要求实现 TCP Connection 部分 （将 TCPReceiver 和 TCPSender 结合起来）。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 3: the TCP sender</title><link href="https://hangx-ma.github.io/2023/05/24/cs144-lab3.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 3: the TCP sender" /><published>2023-05-24T00:00:00+08:00</published><updated>2023-05-24T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/24/cs144-lab3</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/24/cs144-lab3.html"><![CDATA[<p>记录 cs144 Spring-23 Lab3: the TCP sender 的思路与实践难点。 前面一些内容看起来像翻译， 但其实也是做一遍逻辑梳理， 之后落实思路会更清晰一些。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab3 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check3.pdf">Lab Checkpoint 3: the TCP sender</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<p>Lab3 将实现 TCP 中的 <em><strong>TCPSender</strong></em>， 其需要完成的功能有：</p>

<ul>
  <li>跟踪 Receiver 的 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 信息， 通过将 <em><strong>ByteStream</strong></em> 的数据以 TCP Segments 的格式不断发送， 尽可能地填满 window， 直到 window 满了或者 <em><strong>ByteStream</strong></em> 中没有任何东西可以发送。</li>
  <li>跟踪那些已经发送但还没有被接收的 segments， 通常将这些数据被称为 “outstanding segments”。</li>
  <li>若是这些 segments 在足够长的时间后没有没接收， 则重传这些 segments 数据。</li>
</ul>

<p>这些功能实现了 “automatic repeat request (ARQ)” 机制， <em><strong>TCPSender</strong></em> 的任务就是确保 <em><strong>TCPReceiver</strong></em> 能收到每个字节至少一次。</p>

<h2 id="2-tcpsender-如何监测丢包">2. TCPSender 如何监测丢包</h2>

<p><em><strong>TCPSender</strong></em> 会跟踪那些 outstanding segments 的状态， 周期性调用 <code class="language-plaintext highlighter-rouge">tick</code> 函数以指示这些 segments 自发出以来所经过的时间。 <em><strong>TCPSender</strong></em> 会在内部的存储空间存储 <code class="language-plaintext highlighter-rouge">TCPSenderMessages</code> 的信息并遍历这个集合， 找出那些 <strong>已发出但经过时间太久但还未被接收</strong> 的 segments 进行 <strong>数据超时重传</strong>， 直到所有的 <code class="language-plaintext highlighter-rouge">seqno</code> 都被接收。</p>

<p>那么如何界定 <strong>已发出但经过时间太久</strong> 这个定义就尤为重要， 太长的等待时间会增加通信延时， 而太短的等待时间则会浪费网络存储空间以及增大开销。 需要注意如下几点：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tick</code> 函数每隔几毫秒需要调用一次， 记录自上一次调用以来经过的时间， 并以此记录 <em><strong>TCPSender</strong></em> 存在的总时长。 <code class="language-plaintext highlighter-rouge">time</code> 以及 <code class="language-plaintext highlighter-rouge">clock</code> 这类与操作系统和 CPU 相关的函数不允许调用， 否则会导致 TCP 工作异常。</li>
  <li><strong>retransmission timeout (RTO)</strong> 在 <em><strong>TCPSender</strong></em> 初始化时会初始化 <code class="language-plaintext highlighter-rouge">_initial_retransmission_timeout</code>， 该值始终不变而 RTO 会不断改变 （可能为初值的两倍， 或者等于初值） 以记录 outstanding segments 在超时重传前所经过的时间。</li>
  <li>重传定时器 timer 以 tick 为时间单位， timer 会在某个时间启动， 在经过 RTO 时间后失效。</li>
  <li>包含数据的 segment 被传输后 timer 会被启动， 直到经过 RTO 毫秒后 timer 会失效。</li>
  <li>当所有的 outstanding 数据都被接收后， 服务于重传机制的 timer 将会被停止。</li>
  <li>
    <p><a href="#func_tick">以下信息与 <em>tick</em> 函数的实现密切相关</a></p>

    <p>若是 <code class="language-plaintext highlighter-rouge">tick</code> 被调用而 timer 已经失效了：</p>

    <ol>
      <li>将时间最早的未被接收的 segment 进行重传 （<code class="language-plaintext highlighter-rouge">seqno</code> 最小的那个）。</li>
      <li>若此时 window size 非零：
        <ul>
          <li>跟踪记录连续 <strong>重传的数量</strong>， 并在每次重传后进行累加， <em><strong>TCPConnection</strong></em> 会使用这个信息用以判断 TCP 连接的可靠性， 太多连续的重传意味着 TCP 连接不稳定需要终止。</li>
          <li>设置 RTO 值为原来的两倍。 “exponential backoff” 以降低较差网络的重传速度， 避免加深网络的拥堵。</li>
        </ul>
      </li>
      <li>重置 timer 并启动， 使其在 RTO 毫秒之后失效 （需要考虑 RTO 已经翻倍）。</li>
    </ol>
  </li>
  <li>
    <p><a href="#func_receive">以下信息与 <em>receive</em> 函数的实现密切相关</a></p>

    <p>当接收方给发送方传输了 <code class="language-plaintext highlighter-rouge">ackno</code> 表示成功接收了新的数据 （这个 <code class="language-plaintext highlighter-rouge">ackno</code> 比之前任何一个的 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 都要大）:</p>

    <ol>
      <li>需要将 RTO 设置为其初始值。</li>
      <li>如果发送方仍有 outstanding 的数据， timer 需要重启并将会在 RTO 毫秒后失效。</li>
      <li>重置前述的 <strong>连续重传数量</strong> 为 0。</li>
    </ol>
  </li>
</ul>

<h2 id="3-tcp-sender-实现">3. TCP Sender 实现</h2>

<div align="center">
    <img src="/norobots/images/2023-05-24-cs144-lab3/space-structure.png" alt="space structure" width="600" />
    <br />
    <font size="2" color="#999"><u>space structure, HangX-Ma</u></font>
</div>

<p>需要实现以下 5 个接口并增添自己所需的变量以及 helper functions。 上图是 Sender 端所看到的内存结构以及 <code class="language-plaintext highlighter-rouge">seqno</code> 的分布。</p>

<ol>
  <li>
    <p><em><strong>push:</strong></em> 不断读取新的字节， 并组装生成 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>。 需要使满足 window 尺寸的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 尽可能大， 但上限是 <code class="language-plaintext highlighter-rouge">TCPConfig::MAX PAYLOAD SIZE (1452 bytes)</code>。 <code class="language-plaintext highlighter-rouge">TCPSenderMessage::sequence length()</code> 会用以计量该 segment 占用的 <code class="language-plaintext highlighter-rouge">seqno</code> 的尺寸， SYN 和 FIN 都需要计算在内。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Push bytes from the outbound stream */</span>
 <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">Reader</span> <span class="o">&amp;</span><span class="n">outbound_stream</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这里也是需要注意 window size 最小应当为 1。 另外我们需要两个布尔变量来记录是否需要给传输的 <em><strong>TCPSenderMessage</strong></em> 增加 SYN 标志或者 FIN 标志。 我们以如下顺序对 msg 进行组装： SYN， payload， FIN。 需要注意的是， FIN 标志设定有一定的条件限制：</p>

      <ul>
        <li>FIN 之前没设定过；</li>
        <li>Reader 已经没有数据了；</li>
        <li>塞完 SYN 和 payload 之后我们的 window size 还能容纳一个 FIN 的位置
如果本次 FIN 没有传输， 就下次传输， 不会有什么影响。</li>
      </ul>

      <p>另外， 只有在 outstanding segments 清空后我们才需要在传输新的 <em><strong>TCPSenderMessage</strong></em> 时重置 timer， 否则 timer 将在很大程度上失去其基本作用。 每次传输都需要更新 outstanding segments 集合以及发送的 <code class="language-plaintext highlighter-rouge">seqno</code> 数量， <code class="language-plaintext highlighter-rouge">next_seqno</code> 等信息。</p>
    </blockquote>

    <p class="info">cs144 指导书特地说明了 window size 为零的情况， 仅适用于 <code class="language-plaintext highlighter-rouge">push()</code> 函数。 这时 <em><strong>TCPSender</strong></em> 仍需要发送一个独立的字节， 虽然会被 <em><strong>TCPReceiver</strong></em> 拒绝接收但 <em><strong>TCPReceiver</strong></em> 会返回一个 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 数据， 这个信息可以告知 <em><strong>TCPSender</strong></em> window 中是否有新用于传输的空间。 否则 <em><strong>TCPSender</strong></em> 将无法确定何时发送新的 segment。</p>
  </li>
  <li>
    <p><em><strong>maybe_send:</strong></em> 必要时发送 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 或者为空。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TCPSenderMessage</span><span class="o">&gt;</span> <span class="n">maybe_send</span><span class="p">();</span>
</code></pre></div>    </div>

    <blockquote>
      <p>我们需要额外创建一个队列变量 <code class="language-plaintext highlighter-rouge">segments_out_</code> 来管理需要发送的 segments， 使用队列可以保证传输的先后顺序。 仅在这个队列的元素数量不为零且收到 SYN 信号才返回队列头部的那个数据， 并将其从队列头部移除。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>receive:</strong></em> <a id="func_receive"></a> 接收的 window 范围是 \([ackno, ackno + window size]\)。 <em><strong>TCPSender</strong></em> 需要遍历 outstanding segments 集合将其中已经被 ACK 的部分移除 （<code class="language-plaintext highlighter-rouge">ackno</code> 比 segments 中所有的 <code class="language-plaintext highlighter-rouge">seqno</code> 都要大的那些 segments）。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Receive an act on a TCPReceiverMessage from the peer's receiver */</span>
 <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPReceiverMessage</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>我们只需要按照 <a href="#2-tcpsender-如何监测丢包">2.TCPSender 如何监测丢包</a> 中的最后一条逻辑写代码就行。</p>

      <p>这里需要注意， 接收的 <code class="language-plaintext highlighter-rouge">TCPReceiveMessage</code> 中的 <code class="language-plaintext highlighter-rouge">ackno</code> 可能为空， 这时候不能直接返回， 有可能是我们传输了一个 <em><strong>empty message</strong></em> 去获取 window size 而返回的一个包。 因此， 我们需要更新 <code class="language-plaintext highlighter-rouge">window_size_</code> 变量， 除此之外就什么都不做了。</p>

      <p>或者收到的这个 <code class="language-plaintext highlighter-rouge">ackno</code> 比我们当前保存的 <code class="language-plaintext highlighter-rouge">next_seqno</code> 都要大， 这可能是一个错误信息需要丢弃这段数据。</p>
    </blockquote>
  </li>
  <li>
    <p><em><strong>tick:</strong></em> <a id="func_tick"></a> 计时单位， 得到与上次该函数被调用的时间间隔。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Time has passed by the given # of milliseconds since the last time the tick() method was called. */</span>
 <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>
</code></pre></div>    </div>

    <blockquote>
      <p>除了要创建一个 <code class="language-plaintext highlighter-rouge">timer_</code> 变量存储时间外， 在 tick 中还需要做 <a href="#2-tcpsender-如何监测丢包">2.TCPSender 如何监测丢包</a> 中的几件事：</p>

      <ol>
        <li>若 outstanding segments 存在且 timer 失效， 重传时间最早的那个 segments。</li>
        <li>window size 非零时累加连续重传数量， 并进行 “exponential backoff”。</li>
        <li>重置 timer 的值为 0， 为下一次重传准备。</li>
      </ol>
    </blockquote>
  </li>
  <li>
    <p><em><strong>send_empty_message:</strong></em> 长度为零并且 <code class="language-plaintext highlighter-rouge">seqno</code> 正确的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>， 在 <em><strong>TCPReceiver</strong></em> 希望通过 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code> 获取一些特定信息的时候特别有用， 这个和 <code class="language-plaintext highlighter-rouge">push</code> 中的那个想法很类似。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/* Generate an empty TCPSenderMessage */</span>
 <span class="n">TCPSenderMessage</span> <span class="n">send_empty_message</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <blockquote>
      <p>这种长度为 0 的 segments 不需要被监测并纳入 outstanding segments 用以重传。 我们只需要返回一个仅有 <code class="language-plaintext highlighter-rouge">ackno</code> 被赋值为下一个需要接收的字节的 <code class="language-plaintext highlighter-rouge">seqno</code> 的 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code>。</p>
    </blockquote>
  </li>
</ol>

<p class="warning"><em><strong>FAQs and special cases</strong></em> 中的信息都很有帮助， 可以当作一种提供解题思路的 Hints。</p>

<h3 id="helper-functions">Helper Functions</h3>

<p>简化 <code class="language-plaintext highlighter-rouge">seqno</code> 与 <code class="language-plaintext highlighter-rouge">abs_seqno</code> 转换， 使用如下两个 helper functions 即可满足需求。 之后在给 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 中的 <code class="language-plaintext highlighter-rouge">ackno</code> 赋值就很方便了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">get_next_abs_seqno_</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_abs_seqno_</span><span class="p">;</span> <span class="p">};</span>
<span class="n">Wrap32</span> <span class="n">get_next_seqno</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">isn_</span> <span class="o">+</span> <span class="n">next_abs_seqno_</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>

<h2 id="4-坑点记录">4. 坑点记录</h2>

<h3 id="41-the-test-retx-syn-twice-at-the-right-times-then-ack-failed">4.1 <em>The test “Retx SYN twice at the right times, then ack” failed.</em></h3>

<p>这个问题是初始化 window size 不正确导致的， 在文档里的 FAQs 部分有这么一段：</p>

<p class="info"><strong>Q:</strong> <em>What should my TCPSender assume as the receiver’s window size before I’ve gotten an ACK from the receiver?</em>
<br />
<strong>A:</strong> One.</p>

<p>当时我将 <code class="language-plaintext highlighter-rouge">window_size_</code> 初始化为 0， 结果在调用 <code class="language-plaintext highlighter-rouge">tick</code> 函数后 <code class="language-plaintext highlighter-rouge">window_size_ &gt; 0</code> 这条条件判断语句永远不满足， <code class="language-plaintext highlighter-rouge">RTO_timeout_</code> 永远无法进行翻倍。 正确的做法是将 window size 初始化为 1。</p>

<h3 id="42-the-test-retx-syn-until-too-many-retransmissions-failed">4.2 <em>The test “Retx SYN until too many retransmissions” failed.</em></h3>

<p><code class="language-plaintext highlighter-rouge">RTO_timeout</code> 翻倍， 但我以为是初始值翻倍就直接设定成了 <code class="language-plaintext highlighter-rouge">RTO_timeout = 2 * initial_RTO_ms_</code>， 实际上指导书就是说 <em><strong>Double the value of RTO</strong></em> 并且说明是 <em><strong>exponential backoff</strong></em> （给的提示很明显 :joy:）。</p>

<h3 id="5-测试结果">5. 测试结果</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
      Start 28: send_connect
27/36 Test <span class="c">#28: send_connect .....................   Passed    0.09 sec</span>
      Start 29: send_transmit
28/36 Test <span class="c">#29: send_transmit ....................   Passed    1.11 sec</span>
      Start 30: send_retx
29/36 Test <span class="c">#30: send_retx ........................   Passed    0.08 sec</span>
      Start 31: send_window
30/36 Test <span class="c">#31: send_window ......................   Passed    0.35 sec</span>
      Start 32: send_ack
31/36 Test <span class="c">#32: send_ack .........................   Passed    0.08 sec</span>
      Start 33: send_close
32/36 Test <span class="c">#33: send_close .......................   Passed    0.09 sec</span>
      Start 34: send_extra
33/36 Test <span class="c">#34: send_extra .......................   Passed    0.16 sec</span>
      Start 36: compile with optimization
34/36 Test <span class="c">#36: compile with optimization ........   Passed   18.01 sec</span>
      Start 37: byte_stream_speed_test
             ByteStream throughput: 1.02 Gbit/s
35/36 Test <span class="c">#37: byte_stream_speed_test ...........   Passed    0.45 sec</span>
      Start 38: reassembler_speed_test
             Reassembler throughput: 1.83 Gbit/s
36/36 Test <span class="c">#38: reassembler_speed_test ...........   Passed    0.85 sec</span>

100% tests passed, 0 tests failed out of 36

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span> 170.63 sec
Built target check3
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab3: the TCP sender 的思路与实践难点。 前面一些内容看起来像翻译， 但其实也是做一遍逻辑梳理， 之后落实思路会更清晰一些。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 2: the TCP receiver</title><link href="https://hangx-ma.github.io/2023/05/23/cs144-lab2.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 2: the TCP receiver" /><published>2023-05-23T00:00:00+08:00</published><updated>2023-05-23T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/23/cs144-lab2</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/23/cs144-lab2.html"><![CDATA[<p>记录 cs144 Spring-23 Lab2: the TCP receiver 的思路与实践难点。
<!--more--></p>
<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab2 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check2.pdf">Lab Checkpoint 2: the TCP receiver</a>。</li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-内容简述">1. 内容简述</h2>

<p>Lab2 将实现 TCP 协议的具体细节， <em><strong>TCPReceiver</strong></em>， 以处理传入的字符流数据。 如果还记得 Lab1 中的实验框图， <em><strong>TCPReceiver</strong></em> 是 <em><strong>Reassembler</strong></em> 和 <em><strong>ByteStream</strong></em> 的上层封装， 它通过 <code class="language-plaintext highlighter-rouge">receive()</code> 函数从 peer 端接收数据， 经过 <em><strong>Reassembler</strong></em> 处理写入 <em><strong>ByteStream</strong></em> 缓存， 应用层就可以通过 <em><strong>TCPSocket</strong></em> 读取数据。</p>

<p>在接收 peer 端数据的同时， <em><strong>TCPReceiver</strong></em> 通过 <code class="language-plaintext highlighter-rouge">send()</code> 函数承担着告知 peer 一些重要信息的职责， 这些信息包括这两个部分：</p>

<ul>
  <li><strong>Acknowledgment:</strong> <code class="language-plaintext highlighter-rouge">first_unassembled_index</code> 又称 <code class="language-plaintext highlighter-rouge">ackno</code>， 是 <em><strong>TCPReceiver</strong></em> 从 peer 发送端希望收到的 <strong>第一个字节的索引号</strong>。</li>
  <li><strong>Flow Control:</strong> <code class="language-plaintext highlighter-rouge">window size</code>， 是输出到 ByteStream 的剩余空间， 限制了 <em><strong>TCPSender</strong></em> 发送数据的 <em><strong>index</strong></em> 的实际范围。 通过这个 <code class="language-plaintext highlighter-rouge">window</code>， <em><strong>TCPReceiver</strong></em> 能够 <strong>对输入的数据流量进行控制</strong>， 限制发送端的数据直到接收端准备好继续接收。</li>
</ul>

<blockquote>
  <p>通常将 <code class="language-plaintext highlighter-rouge">ackno</code> 称作 <code class="language-plaintext highlighter-rouge">window</code> 的索引左边界 （Smallest Index）， 将 <code class="language-plaintext highlighter-rouge">ackno + window size</code> 称作 <code class="language-plaintext highlighter-rouge">window</code> 的索引右边界 （Largest Index）。</p>
</blockquote>

<h2 id="2-64-bit-索引与-32-bit-序列号的转换">2. 64-bit 索引与 32-bit 序列号的转换</h2>

<div align="center">
    <img src="/norobots/images/2023-05-23-cs144-lab2/tcp-segment.png" alt="TCP segment, wikipedia" width="600" />
    <br />
    <font size="2" color="#999"><u>TCP segment, wikipedia</u></font>
</div>

<p><em><strong>Reassembler</strong></em> 重组 substrings 时每一个字节的索引号都是 64-bit， 并且其首位 <em><strong>index</strong></em> 始终是从零开始。 这是一组在当前技术条件下永远不可能溢出的数据流索引号组。 但是在 TCP segment 的头部数据中， 这一组 <code class="language-plaintext highlighter-rouge">sequence number</code> 又被称为 <code class="language-plaintext highlighter-rouge">seqno</code> 是 32-bit 的， 这组索引号与前述的数据流索引号在长度上不匹配。 32-bit 的数据可以在 100 gigabits/sec 的传输速率下在 1/3 秒内传输完， 因而其可能溢出。 这种不匹配引入了一些复杂性：</p>

<ul>
  <li>TCP 的数据流长度是不固定的， 但数据段的头部 <code class="language-plaintext highlighter-rouge">seqno</code> 仅有 32 位， 4 GiB 大小。 当 <code class="language-plaintext highlighter-rouge">seqno</code> 到达 \(2^{32} - 1\) 大小后， <code class="language-plaintext highlighter-rouge">seqno</code> 会置零。</li>
  <li>TCP <code class="language-plaintext highlighter-rouge">seqno</code> 的起始位置是任意的， ISN （Initial Sequence Number） 可以是 32-bit 中的任意值， 避免数据混淆和提高协议的鲁棒性。 那么 ISN 就代表了当前数据流的 “零点 （zero point）”， 或称其为 SYN （beginning of stream）。</li>
  <li>有 SYN （beginning of stream） 自然也有 FIN （end of stream）， 它们不属于数据流中的任意字节， 仅作为数据流的起始和末尾的两个标识符存在， 但他们分别占有一个 <code class="language-plaintext highlighter-rouge">seqno</code>。</li>
</ul>

<div align="center">
    <img src="/norobots/images/2023-05-23-cs144-lab2/ex-three-types-number.png" alt="Example of Sequence Numbers, Absolute Sequence Numbers, Stream Indices" width="400" />
    <img src="/norobots/images/2023-05-23-cs144-lab2/three-types-number.png" alt="Sequence Numbers, Absolute Sequence Numbers, Stream Indices" width="600" />
    <br />
    <font size="2" color="#999"><u>Sequence Numbers, Absolute Sequence Numbers, Stream Indices</u></font>
</div>

<p>cs144 区分了三种类型的索引值， 并给出了一个 “cat” 数据的例子。 <code class="language-plaintext highlighter-rouge">seqno</code>， <code class="language-plaintext highlighter-rouge">absolute seqno</code>， 以及 <code class="language-plaintext highlighter-rouge">stream index</code>， 这些索引需要我们实现相互之间的转换， 并保持转换前后不同数据的这三类索引值之间的关系一致。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">wrap</code> 是将 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 转换为 <code class="language-plaintext highlighter-rouge">seqno</code>， 64-bit 数据本就是 32-bit 数据的倍数， 进行 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 截断直接和 <code class="language-plaintext highlighter-rouge">zero_point</code> 加和就是 wrap 后的结果。
    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">uint32_t</code> 数据类型自动将溢出部分进行了 wrap 操作。</p>
    </blockquote>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">static</span> <span class="n">Wrap32</span> <span class="nf">wrap</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">unwrap</code> 麻烦一些， 但指导书表明 10 行也能搞定 :joy:。 给了 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 中的 <code class="language-plaintext highlighter-rouge">checkpoint</code> 以及 <code class="language-plaintext highlighter-rouge">seqno</code> 中的 <code class="language-plaintext highlighter-rouge">zero_point</code>， <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 \([SYN,FIN] \in {64 bit}\) 之间的任意一个值。 在指导书中有这么一句：</p>

    <p><em>“Given a sequence number (the Wrap32), the Initial Sequence Number (zero point), and an absolute checkpoint sequence number, find the corresponding absolute sequence number that is closest to the checkpoint.”</em></p>

    <p>说明我们实际要转换的是一个 <code class="language-plaintext highlighter-rouge">Wrap32</code> 类型的数据， 这个数据源就是 <code class="language-plaintext highlighter-rouge">this-&gt;raw_data_</code>， 属于 <code class="language-plaintext highlighter-rouge">seqno</code>。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">uint64_t</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">checkpoint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>对于 <code class="language-plaintext highlighter-rouge">checkpoint</code> 的作用指导书也说的很明确， <code class="language-plaintext highlighter-rouge">seqno</code> 中 17 可能对应着 <code class="language-plaintext highlighter-rouge">absolute seqno</code> 的 17， 也可能是 \(17 + 2^{32}\) 等等。 我们确定变量 <code class="language-plaintext highlighter-rouge">seqno_offset = this-&gt;raw_data_ - zero_point.raw_data_</code>， 写过 Lab0 和 Lab1 应该都清楚， <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 first_unassembled_index， 它应当比传入的 <code class="language-plaintext highlighter-rouge">seqno_offset</code> 的值要小， 若 <code class="language-plaintext highlighter-rouge">checkpoint &gt;= seqno_offset</code>， 我们就需要找到具体偏移了几个 \(2^{32}\)， 那最终的 <code class="language-plaintext highlighter-rouge">absolute seqno = seqno_offset + UINT32_SIZE_num * UINT32_SIZE</code>。</p>
  </li>
</ul>

<h2 id="3-tcp-receiver-实现">3. TCP Receiver 实现</h2>

<p>cs144 提供了 <code class="language-plaintext highlighter-rouge">TCPSenderMessage</code> 和 <code class="language-plaintext highlighter-rouge">TCPReceiverMessage</code>, 前者用于 <code class="language-plaintext highlighter-rouge">receive</code> 后者用于 <code class="language-plaintext highlighter-rouge">send</code>。</p>

<ol>
  <li><em><strong>receive：</strong></em> 该部分有两个要求
    <ul>
      <li>在必要时， 也就是 message 中包含 SYN 时， 需要保存这个 SYN 的 <code class="language-plaintext highlighter-rouge">seqno</code>。</li>
      <li>将 payload 部分的数据推送给 <em><strong>Reassembler</strong></em>， FIN 作为标识符控制 push 过程的终止。</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span><span class="n">TCPSenderMessage</span> <span class="n">message</span><span class="p">,</span> <span class="n">Reassembler</span> <span class="o">&amp;</span><span class="n">reassembler</span><span class="p">,</span> <span class="n">Writer</span> <span class="o">&amp;</span><span class="n">inbound_stream</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>可以明确的是， 在 <em><strong>TCPReceiver</strong></em> 还没有接收到 SYN 时， 所有的数据都不应当被送入 <em><strong>Reassembler</strong></em>， 因为此时的数据传输还没有开始， 所以我们需要有一个标志位表明数据开始传输。</p>

    <p>另外传输的时候使用的是 <code class="language-plaintext highlighter-rouge">stream_index</code>， 而我们得到的是 <code class="language-plaintext highlighter-rouge">seqno</code>， 首先需要将 <code class="language-plaintext highlighter-rouge">seqno</code> 转为 <code class="language-plaintext highlighter-rouge">absolute seqno</code>， 我们已经写好了 <code class="language-plaintext highlighter-rouge">unwarp</code> 函数， 需要提供 <code class="language-plaintext highlighter-rouge">checkpoint</code>。 <code class="language-plaintext highlighter-rouge">checkpoint</code> 是 <em>first_unassembled_index</em>， 也就是下一个需要被 buffer 存储的字节。 在 Lab0 中我们完成的 <code class="language-plaintext highlighter-rouge">Writer</code> 类有一个 <code class="language-plaintext highlighter-rouge">bytes_pushed()</code> 函数， <code class="language-plaintext highlighter-rouge">bytes_pushed() + 1 = checkpoint</code>。</p>

    <p><code class="language-plaintext highlighter-rouge">absolute_seqno</code> 转换为 <code class="language-plaintext highlighter-rouge">stream_index</code> 时需要考虑当前的 message 是否有 SYN 部分。 我们给 <code class="language-plaintext highlighter-rouge">unwrap</code> 提供的 <code class="language-plaintext highlighter-rouge">zero_point</code> 是以 SYN 对应的 <code class="language-plaintext highlighter-rouge">seqno</code>， 若 SYN 在当前的 message 中不存在， 则 <code class="language-plaintext highlighter-rouge">zero_point</code> 应当为当前 payload 的第一个字节。 所以有如下转换满足：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">uint64_t</span> <span class="n">stream_index</span> <span class="o">=</span> <span class="n">abs_seqno</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">message</span><span class="p">.</span><span class="n">SYN</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>之后我们只需要提供 <code class="language-plaintext highlighter-rouge">inbound_stream.insert()</code> 所需要的各个变量即可。</p>
  </li>
  <li>
    <p><em><strong>send：</strong></em> 这里只需要注意只有 <code class="language-plaintext highlighter-rouge">ackno</code> 是 optional 属性， <code class="language-plaintext highlighter-rouge">window_size</code> 是每次都要发送的。 如果已经收到 FIN 那段 message， 满足 <code class="language-plaintext highlighter-rouge">inbound_stream.is_closed() == true</code> 那我们需要增加 FIN 部分的长度。 但也别忘了传输开始后， SYN 也是占有一个 <code class="language-plaintext highlighter-rouge">seqno</code> 位置的。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">TCPReceiverMessage</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">Writer</span> <span class="o">&amp;</span><span class="n">inbound_stream</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="4-测试结果">4. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/cs144-sp23/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check2
Test project /home/cs144/cs144-sp23/minnow/build
      Start  1: compile with bug-checkers
 1/29 Test  <span class="c">#1: compile with bug-checkers ........   Passed   20.37 sec</span>
 ...
      Start 21: recv_connect
20/29 Test <span class="c">#21: recv_connect .....................   Passed    0.09 sec</span>
      Start 22: recv_transmit
21/29 Test <span class="c">#22: recv_transmit ....................   Passed    0.75 sec</span>
      Start 23: recv_window
22/29 Test <span class="c">#23: recv_window ......................   Passed    0.09 sec</span>
      Start 24: recv_reorder
23/29 Test <span class="c">#24: recv_reorder .....................   Passed    0.09 sec</span>
      Start 25: recv_reorder_more
24/29 Test <span class="c">#25: recv_reorder_more ................   Passed    1.86 sec</span>
      Start 26: recv_close
25/29 Test <span class="c">#26: recv_close .......................   Passed    0.09 sec</span>
      Start 27: recv_special
26/29 Test <span class="c">#27: recv_special .....................   Passed    0.10 sec</span>
      Start 28: compile with optimization
27/29 Test <span class="c">#28: compile with optimization ........   Passed   18.11 sec</span>
      Start 29: byte_stream_speed_test
             ByteStream throughput: 0.63 Gbit/s
28/29 Test <span class="c">#29: byte_stream_speed_test ...........   Passed    0.71 sec</span>
      Start 30: reassembler_speed_test
             Reassembler throughput: 1.33 Gbit/s
29/29 Test <span class="c">#30: reassembler_speed_test ...........   Passed    1.23 sec</span>

100% tests passed, 0 tests failed out of 29

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>  47.45 sec
Built target check2
</code></pre></div></div>

<h2 id="website">Website</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol - wikipedia</a></li>
</ul>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[记录 cs144 Spring-23 Lab2: the TCP receiver 的思路与实践难点。]]></summary></entry><entry><title type="html">私有化 Git Pages 源码仓库</title><link href="https://hangx-ma.github.io/2023/05/21/protect-source-data.html" rel="alternate" type="text/html" title="私有化 Git Pages 源码仓库" /><published>2023-05-21T00:00:00+08:00</published><updated>2023-05-21T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/21/protect-source-data</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/21/protect-source-data.html"><![CDATA[<h2 id="1-前言">1. 前言</h2>

<p>被一件事儿恶心到了， 发现最开始发在博客园上的文章被爬到了一个不知名的小网站， 没有署名， 没有注明来源。 真的对这种侵犯个人权利的事情感到恶心， 至少引用和转载文章需要注明来源。 国内互联网的内容同质化严重， 优质内容也逐渐减少不是没有道理的。</p>

<p>一气之下把 cnblogs 的内容都删掉了。</p>

<p>后来又想了想什么地方造成了数据外泄， 毕竟 markdown 数据也是保存在自己的私有仓库中， 估计 content 部分的内容被精准地洗劫了， 而且图片是上传在博客园的服务器上的， 被爬走还能正常显示， 这和在 Git Pages 中用相对地址引用还有区别。</p>

<p>感觉自己的 Git Pages 把源码都泄露在外头无异于数据裸奔， 另外 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 每次都需要自己去手动更新， 明明 jekyll-sitemap 插件能够将这件事情自动化处理， 于是产生了分离源码仓库和展示仓库的想法。</p>

<h2 id="2-私有化与自动化部署">2. 私有化与自动化部署</h2>

<p>实现的思路很清晰， 通过 Github Action 实现私有仓库的数据编译， 再将编译后的内容推送到目标公有仓库中， 所有的内容均对外不可见就完成了源码的私有化和部署的公有化。</p>

<div class="mermaid" align="center">
flowchart LR
    p1(Private Repository)
    p2(Git Action)
    p3(Public Repository)
    style p1 fill:#4F94CD,stroke:#363636,stroke-width:2px,color:#F5F5F5
    style p2 fill:#DCDCDC,stroke:#363636,color:#8B8B7A,color:#696969
    style p3 fill:#FF6A6A,stroke:#363636,stroke-width:2px,color:#F5F5F5
    p1 --&gt; p2
    p2 --&gt;|Compile/Push| p3
</div>

<p>需要在自己的源码仓库中创建 <code class="language-plaintext highlighter-rouge">.github/workflows/jekyll.yml</code> 文件， 当然文件名可以自定义。 这样 Git Action 就可以识别这个配置文件的内容， 这个仓库就能执行配置文件定义的各个步骤。 在其中复制粘贴如下代码， 将其中带有提示性的大写的字符都替换为自己的配置。 但需要注意的是， 我们需要通过 <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa</code> 生成用于该仓库推送的一对密钥， 将私有密钥填写在私有仓库的 <code class="language-plaintext highlighter-rouge">Settings-&gt;Actions secrets and variables</code> 的 <code class="language-plaintext highlighter-rouge">Secrets</code> 中， 并将这个 <em>secret</em> 命名为 <code class="language-plaintext highlighter-rouge">DEPLOY_KEY</code>。 之后需要将公有密钥添加到 Github 账号的 <code class="language-plaintext highlighter-rouge">Settings-&gt;SSH and GPG keys</code> 中。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This workflow uses actions that are not certified by GitHub.</span>
<span class="c1"># They are provided by a third-party and are governed by</span>
<span class="c1"># separate terms of service, privacy policy, and support</span>
<span class="c1"># documentation.</span>

<span class="c1"># Sample workflow for building and deploying a Jekyll site to GitHub Pages</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Deploy Jekyll site to Pages</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="c1"># Runs on pushes targeting the default branch</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">YOUR_PRIVATE_REPO_SOURCE_BRANCH"</span><span class="pi">]</span>

  <span class="c1"># Allows you to run this workflow manually from the Actions tab</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>

<span class="c1"># Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages</span>
<span class="na">permissions</span><span class="pi">:</span>
  <span class="na">contents</span><span class="pi">:</span> <span class="s">read</span>
  <span class="na">pages</span><span class="pi">:</span> <span class="s">write</span>
  <span class="na">id-token</span><span class="pi">:</span> <span class="s">write</span>

<span class="c1"># Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.</span>
<span class="c1"># However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.</span>
<span class="na">concurrency</span><span class="pi">:</span>
  <span class="na">group</span><span class="pi">:</span> <span class="s2">"</span><span class="s">pages"</span>
  <span class="na">cancel-in-progress</span><span class="pi">:</span> <span class="kc">false</span>

<span class="na">env</span><span class="pi">:</span>
  <span class="na">TZ</span><span class="pi">:</span> <span class="s">Asia/Shanghai</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="c1"># Build job</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>
        <span class="na">with</span><span class="pi">:</span>
           <span class="na">persist-credentials</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># false 是用 personal token，true 是使用 GitHub token</span>
           <span class="na">fetch-depth</span><span class="pi">:</span> <span class="m">0</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Ruby</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">ruby/setup-ruby@55283cc23133118229fd3f97f9336ee23a179fcf</span> <span class="c1"># v1.146.0</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">ruby-version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.1'</span> <span class="c1"># Not needed with a .ruby-version file</span>
          <span class="na">bundler-cache</span><span class="pi">:</span> <span class="kc">true</span> <span class="c1"># runs 'bundle install' and caches installed gems automatically</span>
          <span class="na">cache-version</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># Increment this number if you need to re-download cached gems</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build with Jekyll</span>
        <span class="c1"># Outputs to the './_site' directory by default</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">bundle exec jekyll build --baseurl "$" --config ./_config.yml</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">JEKYLL_ENV</span><span class="pi">:</span> <span class="s">production</span>
          <span class="na">TZ</span><span class="pi">:</span> <span class="s">Asia/Shanghai</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload artifact</span>
        <span class="c1"># Automatically uploads an artifact from the './_site' directory by default</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/upload-pages-artifact@v1</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set SSH Environment</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="c1"># 1. Add this private key and title as DEPLOY_KEY in this repo -&gt; settings/secrets</span>
          <span class="c1"># 2. Add corresponding public key and named as any text to the github page repo -&gt; settings/deploy keys</span>
          <span class="na">DEPLOY_KEY</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">USER_NAME</span><span class="pi">:</span> <span class="s">YOUR_USER_NAME</span>
          <span class="na">USER_EMAIL</span><span class="pi">:</span> <span class="s">YOUR_USER_EMAIL</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">mkdir -p ~/.ssh/</span>
          <span class="s">echo "$DEPLOY_KEY" | tr -d '\r' &gt; ~/.ssh/id_rsa</span>
          <span class="s">chmod 600 ~/.ssh/id_rsa</span>
          <span class="s">chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/*</span>
          <span class="s">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span>
          <span class="s">git config --global user.name $USER_NAME</span>
          <span class="s">git config --global user.email $USER_EMAIL</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Commit and Push to Git Pages</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">USER_NAME</span><span class="pi">:</span> <span class="s">YOUR_USER_NAME</span>
          <span class="na">USER_EMAIL</span><span class="pi">:</span> <span class="s">YOUR_USER_EMAIL</span>
        <span class="na">working-directory</span><span class="pi">:</span> <span class="s">./</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span> 
          <span class="s">git clone -b PUBLIC_REPOSITORY_BRANCH git@github.com:YOUR_USER_NAME/YOUR_USER_NAME.github.io.git gitpage_repo</span>
          <span class="s">cd gitpage_repo</span>
          <span class="s">cp robots.txt ../_site/robots.txt</span>
          <span class="s">rm -rf *</span>
          <span class="s">cp -r ../_site/* .</span>
          <span class="s">git add -A</span>
          <span class="s">git -c user.name="$USER_NAME" -c user.email="$USER_EMAIL" commit -am "Site Updated: `date +'%Y-%m-%d %H:%M:%S'`" </span>
          <span class="s">git push origin master -f -q</span>
</code></pre></div></div>

<p>简化了个人摸索这个自动化配置的过程， 若对以上配置有所疑惑之处， 可以参考以下文章加深个人理解。 如有问题欢迎留言询问~</p>

<blockquote>
  <p><a href="https://juejin.cn/post/7120474763910676488">GitHub 私有仓库免费开启 GitHub Pages 的可行性方案</a><br />
<a href="https://babybluue.github.io/posts/89195a6e">通过Github Action自动部署Hexo</a><br />
<a href="https://gist.github.com/Half9000/7d83d7f8dea012926dc7d2203a1f169e">Hexo Deploy with Github Actions workflow</a><br />
<a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog/">使用 GitHub Actions 自动部署 Hexo 博客</a><br />
<a href="https://blog.csdn.net/shiwanghualuo/article/details/128514693">github actions中如何判断仓库是否有变更</a></p>
</blockquote>

<h2 id="3-爬虫与目录结构保护">3. 爬虫与目录结构保护</h2>

<p>更改网站的 <code class="language-plaintext highlighter-rouge">robots.txt</code> 为如下形式</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">layout</span><span class="pi">:</span> <span class="kc">null</span>
<span class="nn">---</span>

<span class="na">User-agent</span><span class="pi">:</span> <span class="err">*</span>

<span class="na">Disallow</span><span class="pi">:</span> <span class="s">/assets/</span>   <span class="c1"># /assets/ 是常规资源目录，不怕暴露路径</span>
<span class="na">Disallow</span><span class="pi">:</span> <span class="s">/norobots/</span> <span class="c1"># 零碎敏感文件、目录等放置在此</span>

<span class="na">Sitemap</span><span class="pi">:</span> <span class="s">https://hangx-ma.github.io/sitemap.xml</span>

</code></pre></div></div>

<p>出于安全考虑，站点的某些目录结构，譬如 <code class="language-plaintext highlighter-rouge">/norobots/</code>， 不希望被外部访问， 所以需要使用重定向来保护目录， 可以使用 GitHub 推荐的 Jekyll 重定向插件 <a href="https://github.com/jekyll/jekyll-redirect-from">Jekyll Redirect From</a>。</p>

<p>GitHub Pages 默认支持该插件，在项目的 <code class="language-plaintext highlighter-rouge">Gemfile</code> 里添加引用：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem "jekyll-redirect-from"
</code></pre></div></div>

<p>接着运行 <code class="language-plaintext highlighter-rouge">bundle install</code> 命令安装插件，安装完成后，在站点 404 页面的 YAML 头部添加跳转规则：</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">redirect_from</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">/norobots/</span>
<span class="nn">---</span>
</code></pre></div></div>

<p>具体的目录可以更具自己站点的实际情况定义， 按照上述定义， <code class="language-plaintext highlighter-rouge">访问 {SITE_URL}/norobots/</code> 会直接返回 404 页面， 从而保护了敏感目录。</p>

<blockquote>
  <p><a href="https://cotes.page/posts/the-seo-to-jekyll/">Jekyll 的 SEO 优化</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="Git" /><summary type="html"><![CDATA[通过私有化 Git Pages 源码仓库， 并自动化推送和部署公有 Git Pages 仓库以实现源数据保护。]]></summary></entry><entry><title type="html">关于 Jekyll TeXt 博客搭建</title><link href="https://hangx-ma.github.io/2023/05/18/Jekyll-TeXt-config.html" rel="alternate" type="text/html" title="关于 Jekyll TeXt 博客搭建" /><published>2023-05-18T00:00:00+08:00</published><updated>2023-05-18T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/18/Jekyll-TeXt-config</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/18/Jekyll-TeXt-config.html"><![CDATA[<p>之前用 Hexo 搭 Git Pages 的经历实在是惨痛， 个人对前端没什么研究配置非常痛苦， 尤其是还需要装大量的依赖库尝试解决 <strong>图片显示</strong>、 <strong>Markdown显示</strong>， <strong>数学公式显示</strong> 等问题， Node.js 也非常不省心， 库版本冲突也很严重。 咬咬牙用了一段时间博客园， 不简洁， 不优雅， 不顺我心。 偶然间在知乎上看到了一些关于 Hugo， Jekyll， Hexo 相关的比较， Jekyll 虽然用 Ruby 构建速度稍慢 （实际感觉还挺快）， 但关键是 Github 的支持非常友好， 能自动编译并部署网站， 而且相关的社区建设也很不错， 对于只想专注记录并做点代码微调的人而言显得非常良心。 偶然间发现了 <code class="language-plaintext highlighter-rouge">TeXt</code> 这款主题， 文档很新而且很全面， 样式也吸引人， 就此入坑了。 前后花了两天去踩坑配自己心仪的样式， 在此记录一些配置细节， 不定期更新。</p>

<p class="info"><code class="language-plaintext highlighter-rouge">_data/variables.yml</code> 中的配置对 <code class="language-plaintext highlighter-rouge">_config.yml</code> 会进行覆写有更高的优先级。</p>

<h2 id="logo">logo</h2>

<p>给自己的网站增加一个独一无二的 logo 是很多人第一件要做的事， 但这个 logo 尺寸也是有要求的， 例如 Bing 网页抓取的页面不能超过 125 KB。 因而 <code class="language-plaintext highlighter-rouge">logo.svg</code> 尺寸尽可能要小， 否则会导致页面尺寸过大出现网页抓取的 SEO 问题。</p>

<h2 id="bootcdn">bootcdn</h2>

<p>BootCDN 域名已经迁移到 <code class="language-plaintext highlighter-rouge">https://cdn.bootcdn.net/</code>， 以 <code class="language-plaintext highlighter-rouge">https://cdn.bootcss.com/</code> 开头的链接已经全部不可用， 需要在新的 BootCDN 往网站中找到相应的 js 文件进行更新。 需要在 <code class="language-plaintext highlighter-rouge">_data/variables.yml</code> 更新这些链接并适当更新版本， 老旧版本可能会造成一些问题。</p>

<p class="warning">需要注意的是， <code class="language-plaintext highlighter-rouge">mathjax</code> 需要更换为 <code class="language-plaintext highlighter-rouge">https://unpkg.com/</code> 源， BootCDN 源出现 <code class="language-plaintext highlighter-rouge">Uncaught ReferenceError: MathJax is not defined</code>。</p>

<h2 id="leancloud">leancloud</h2>

<p>使用 leancloud 国际版需要更新 <code class="language-plaintext highlighter-rouge">_includes/pageview-providers/leancloud.js</code> 的 <code class="language-plaintext highlighter-rouge">serverURLs</code> 为如下形式。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">serverURLs</span><span class="pi">:</span> <span class="s">https://xxxxxxxx.api.lncldglobal.com</span> <span class="c1"># 把xxxxxxxx替换成你自己AppID的前8位字符</span>
</code></pre></div></div>

<blockquote>
  <p>这个问题是在 valine 的 issue 版面找到的 <a href="https://github.com/xCss/Valine/issues/340">国际版域名问题 #340</a>。</p>
</blockquote>

<h2 id="pageview">pageview</h2>

<h3 id="1-自动生成文章标识-key">1. 自动生成文章标识 <em>key</em></h3>

<p>按照文档配置好 leancloud 之后发现文章的 views 一直都没有变化， 后检查文档说明发现需要给每篇文章增加一个 <em>unique key</em> 才能进行阅读量的统计。 找到 <code class="language-plaintext highlighter-rouge">_includes/pageview-providers/leancloud/post.html</code> 发现几个 <code class="language-plaintext highlighter-rouge">page.key</code> 的变量， 以及 <code class="language-plaintext highlighter-rouge">_includes/article-info.html</code> 中有这么一句代码给 <code class="language-plaintext highlighter-rouge">data-page-key</code> 进行了赋值。 <code class="language-plaintext highlighter-rouge">data-page-key</code> 是 <code class="language-plaintext highlighter-rouge">post.html</code> 用以判断是否对 pageview 进行增加的依据。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li&gt;&lt;i</span> <span class="na">class=</span><span class="s">"far fa-eye"</span><span class="nt">&gt;&lt;/i&gt;</span> <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"js-pageview"</span> <span class="na">data-page-key=</span><span class="s">"{{ include.article.key }}"</span><span class="nt">&gt;</span>0<span class="nt">&lt;/span&gt;</span> {{ _locale_views }}<span class="nt">&lt;/li&gt;</span>
</code></pre></div></div>

<p>对于 Jekyll 而言， <code class="language-plaintext highlighter-rouge">page.id</code> 以及 <code class="language-plaintext highlighter-rouge">page.url</code> 都是内置的变量， 且对于一个网页而言， 这两个值都可以作为唯一标识， 其作用与 <em>unique key</em> 的作用别无二致。 那么可以选择其中一个对原有的 <code class="language-plaintext highlighter-rouge">page.key</code> 进行替代。 但是， <code class="language-plaintext highlighter-rouge">page.id</code> 当时产生了一个问题， 虽然文章中的 views 部分会增加了， 但文章列表中仍然显示为 0， 我怀疑当时将 <code class="language-plaintext highlighter-rouge">data-page-key</code> 直接改为 <code class="language-plaintext highlighter-rouge">page.id</code>， 并且没有对 <code class="language-plaintext highlighter-rouge">/</code> 进行处理有关系。 实际的更改如下所示：</p>

<ul>
  <li>
    <p>post.html</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  { page.key } -&gt;  { page.url }
  {{ page.key }} -&gt; {{ page.url | replace:'/', 's' }}
</code></pre></div>    </div>
  </li>
  <li>
    <p>article.html</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {{ include.article.key }} -&gt; {{ include.article.url | replace: '/', 's' }}
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p>该部分有两条在 TeXt theme 的 <em>issues</em> 均有提及</p>

  <ul>
    <li>原文链接 <a href="https://github.com/Real-king-Ph/Real-king-Ph.GitHub.io/blob/master/_posts/2022-04-06M/2022-04-05-TeXt%E4%B8%BB%E9%A2%98%E4%B8%8B-key%E7%9A%84%E9%87%8D%E8%AE%BE-leancloud%E8%BD%AC%E5%9B%BD%E9%99%85%E7%89%88.md">Key 的重设</a></li>
    <li><a href="https://github.com/kitian616/jekyll-TeXt-theme/issues/321">Feature request: support post.id for comments</a></li>
  </ul>
</blockquote>

<h3 id="2-home-界面的多余的-views">2. Home 界面的多余的 views</h3>

<p>开启 pageview 之后在 Home/Archive/About 界面的右上角也能看到 views 这个字样， 感觉非常多余， 其实只需要在上述的那句 <code class="language-plaintext highlighter-rouge">data-page-key</code> 的代码前加一些判断， 让这个字样在 Home/Archive/About 界面不显示即可。 对于 Archive 以及 About 两个界面， 需要判断 <code class="language-plaintext highlighter-rouge">page.url != '/archive.html'</code> 以及 <code class="language-plaintext highlighter-rouge">page.url != '/about.html'</code>， 但对于 Home 界面就有些麻烦， 这些 views 在 Home 界面是全关联的， 如果右上角的 views 消失了， 后面的 article list 中的也会跟着消失， 所以需要区分 Home 界面本身的 article 和我们的在 <code class="language-plaintext highlighter-rouge">_posts</code> 文件夹下的 article。</p>

<p>发现 <code class="language-plaintext highlighter-rouge">home.html</code> 实际也是一种特殊的 post， 只是它的 title 被认为设置隐藏了。 所以， 只需要给这篇特殊的文章设定 <code class="language-plaintext highlighter-rouge">pageview: false</code> 就能让它的 pageview 字样消失而不影响 Home 界面其他文章的 pageview 字样的显示。</p>

<blockquote>
  <p>后来想想对于 Archive 和 About 这两个界面而言也是同样的道理， 都应该能用 <code class="language-plaintext highlighter-rouge">pageview: false</code> 将 pageview 字样去除。 实践证明确实可行！</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--  article-info.html --&gt;</span>
{%- if page.layout != "404" -%}
    {%- if page.url != '/about.html' and page.url != '/archive.html' -%}
        <span class="nt">&lt;li&gt;&lt;i</span> <span class="na">class=</span><span class="s">"far fa-eye"</span><span class="nt">&gt;&lt;/i&gt;</span> <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"js-pageview"</span> <span class="na">data-page-key=</span><span class="s">"{{ include.article.url | replace: '/', 's' }}"</span><span class="nt">&gt;</span>0<span class="nt">&lt;/span&gt;</span> {{ _locale_views }}<span class="nt">&lt;/li&gt;</span>
    {%- endif -%}
{%- else -%}
    <span class="nt">&lt;li&gt;&lt;i</span> <span class="na">class=</span><span class="s">"far fa-eye"</span><span class="nt">&gt;&lt;/i&gt;</span> 404 {{ _locale_views }}<span class="nt">&lt;/li&gt;</span>
{%- endif -%}
</code></pre></div></div>

<h2 id="gitalk">gitalk</h2>

<p>从博客园换成 Git Pages 的另外一个原因是评论系统的便利性， Github 账号登陆省去了评论需要重新创建账号的麻烦。 尝试过使用 valine 作为评论系统， 虽然可以和 leancloud 公用 key， 但界面有些复杂不简洁不如 gitalk 赏心悦目。</p>

<p class="info">gitalk 在 2023-05 时的最新版本是 1.7.2， 使用前记得在 <code class="language-plaintext highlighter-rouge">_include/variable.yml</code> 中更新 bootcdn 地址。</p>

<h3 id="1-让-gitalk-摆脱-pagekey">1. 让 gitalk 摆脱 page.key</h3>

<p>这里就不能直接改成把 <code class="language-plaintext highlighter-rouge">_includes/comments-providers/gitalk.html</code> 中的 <code class="language-plaintext highlighter-rouge">page.key</code> 直接改成 <code class="language-plaintext highlighter-rouge">page.url</code>， 不然在 Home 和 About 这两个界面也会出现评论框， 我改成了 <code class="language-plaintext highlighter-rouge">page.id</code> 就神奇的解决了问题。</p>

<p>另外在 issue 版面我看到一条 <a href="https://github.com/mzlogin/mzlogin.github.io/issues/63">发布的新文章提示“未找到相关的 Issues 进行评论，请联系xxx初始化创建” #63</a> 的问题， 如果自己是管理员的话登陆一下就能自动创建评论区解决问题。 关键的是这一句， 文章链接过长 （超过 50 个字符） 也会导致创建失败出现 <code class="language-plaintext highlighter-rouge">Error: Validation Failed.</code>， 按照 <a href="https://github.com/mzlogin/mzlogin.github.io/commit/5ef353c011b21c04193df19096bc67a7b7140bec">Prevent comments initialize issue</a> 中的记录， 只需要将 <code class="language-plaintext highlighter-rouge">page.id</code> 改为 <code class="language-plaintext highlighter-rouge">page.id | truncate: 50, ''</code> 即可解决问题。</p>

<h3 id="2-error-request-failed-with-status-code-403">2. Error: Request failed with status code 403</h3>

<p>这个问题就是 gitalk 被墙了， 加一个 <code class="language-plaintext highlighter-rouge">proxy</code> 在 <code class="language-plaintext highlighter-rouge">_config.yml</code> 就行， 但也要记得同步更新 <code class="language-plaintext highlighter-rouge">gitalk.html</code> 中的配置。 <code class="language-plaintext highlighter-rouge">proxy</code> 的值如何获取我找到了 <a href="https://prohibitorum.top/7cc2c97a15b4.html">解决 Gitalk 无法获取 Github Token 问题</a> 文章， <a href="https://github.com/Dedicatus546/cors-server">fork</a> 这个作者的仓库然后按照他文中给的步骤注册 netlify账号并编译部署 <code class="language-plaintext highlighter-rouge">cors-server</code> 仓库， 它会生成一个 <a href="https://xxxx.netlify.app">https://xxxx.netlify.app</a> 的 site 地址， 如果在网页中输入 <a href="https://xxxx.netlify.app/github_access_token">https://xxxx.netlify.app/github_access_token</a> 会出现 <code class="language-plaintext highlighter-rouge">a cors proxy by netlify!</code> 那就是成功了。 <code class="language-plaintext highlighter-rouge">proxy</code> 部分用这个地址即可。 懒的话直接拿这个作者已经建好的 <em>github_access_token</em> 也是可以的。</p>

<blockquote>
  <p><strong>vercel</strong>: <a href="https://vercel.prohibitorum.top/github_access_token">https://vercel.prohibitorum.top/github_access_token</a><br />
<strong>netlify</strong>: <a href="https://strong-caramel-969805.netlify.app/github_access_token">https://strong-caramel-969805.netlify.app/github_access_token</a></p>
</blockquote>

<h3 id="3-error-uconcatjoin-is-not-a-function">3. Error: u.concat(…).join is not a function</h3>

<p>在 gitalk repository 的 issue 界面就可以找到这条问题的处理办法， <a href="https://github.com/gitalk/gitalk/issues/114">Error: u.concat(…).join is not a function! #114</a> 在 <code class="language-plaintext highlighter-rouge">_config.yml</code> 配置界面给 gitalk 加上如下代码。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">gitalk</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">gitalk</span>
</code></pre></div></div>

<p>另外在 <code class="language-plaintext highlighter-rouge">_includes/comments-providers/gitalk.html</code> 中进行修改。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const gitalk = new Gitalk({
    // ...
    labels: '{{ theme.gitalk.labels }}'.split(',').filter(l =&gt; l),
    //...
});
gitalk.render('gitalk-container');
</code></pre></div></div>

<h2 id="site-exposure">site exposure</h2>

<p>注册 google analytics 并且配置好 <code class="language-plaintext highlighter-rouge">_config.yml</code> 文件中的 <code class="language-plaintext highlighter-rouge">analytics</code> 部分的信息， 会发现 <a href="https://analytics.google.com/">google analytics</a> 好像并没有开始工作。 实际上是 google 并没有将网站纳入搜索索引中， 在 google 搜索中输入 <code class="language-plaintext highlighter-rouge">site:YOUR_GIT_PAGES_ADDRESS</code> 会发现没有任何内容。 要么等着 google 的搜索引擎来抓网页， 要么就自己主动先进行配置申请。</p>

<blockquote>
  <p><a href="https://evanli.github.io/blog/2018/10/25/let-jekyll-github-pages-be-searched-by-google/">让Google搜索到用Jekyll搭建在Github Pages上的博客</a><br />
<a href="https://blog.naibabiji.com/tutorial/google-analytics.html">自己建网站怎么添加Google Analytics统计代码查看每日流量</a></p>
</blockquote>

<h3 id="1-sitemap">1. sitemap</h3>

<p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构,以便于高效爬取内容，快速建立索引。 使用 <a href="https://www.xml-sitemaps.com/">XML-Sitemaps</a> 生成我们的 Git Pages 的 sitemap.xml 文件， 然后将其放在自己网站文件的根目录。 之后就需要在对应的 Google Search Console 中增加 sitemap URL 进行验证。 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 需要在我们增添新的博文或内容后手动进行更新， 以使得搜索引擎能够获取网站的最新内容。 或者通过 jekyll-sitemap 插件自动生成更新。</p>

<h3 id="2-google-search-console">2. Google Search Console</h3>

<p>资源类型选择 “网站前缀”， 提交我们的 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 并对需要的网址进行网站检查， 然后申请编入索引。</p>

<h3 id="3-bing-webmasters">3. Bing Webmasters</h3>

<p>如果想要在 Bing 中增加自己的网站索引也是类似的操作， 只是我们需要用到 <a href="https://www.bing.com/webmasters/">Bing Webmaster Tools</a>。 如果用 Google Search Console 顺利的话， 可以用同一个 Google 账号导入相关的信息， 但 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 验证好像还是需要自己添加。</p>

<h3 id="4-url-上传搜索引擎索引">4. URL 上传搜索引擎索引</h3>

<p>这篇 <a href="https://www.cnblogs.com/duanguyuan/p/16205184.html">文章</a> 介绍了如何通过 API 接口提交 URL 申请， 以加快文章列表被搜索引擎的收录。</p>

<ul>
  <li>
    <p>生成 URL 列表手动递交</p>

    <p>在提交 URL 之前需要准备好 URL 列表， 形如</p>

    <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  http://www.your-site.com/1.html
  http://www.your-site.com/2.html
</code></pre></div>    </div>

    <p>我们可以手动通过 <a href="https://www.xml-sitemaps.com/">XML-Sitemaps</a> 网站生成 sitemap， 或者通过 Github 支持的 <code class="language-plaintext highlighter-rouge">jekyll-sitemap</code> 插件在部署后自动生成， 这个插件可以在 <code class="language-plaintext highlighter-rouge">_config.yml</code> 中看到是已经被添加了的。 那么之后就可以用以下 Linux 命令提取 <code class="language-plaintext highlighter-rouge">sitemap.xml</code> 文件中的 URL， 筛选我们最新添加的部分。</p>

    <blockquote>
      <p>可以使用诸如 compareit 这类插件进行更高效的对比筛选</p>
    </blockquote>
  </li>
  <li>
    <p>API 推送递交</p>

    <p>Bing 以及 Baidu 都提供了 API 接口进行提交。 根据 <a href="https://www.bing.com/webmasters/">Bing Webmasters</a> 以及 <a href="https://ziyuan.baidu.com/linksubmit/">Baidu linksubmit</a> 提供的 API 结构， 可以更改如下 <code class="language-plaintext highlighter-rouge">commit_urls.py</code> 的相应信息， 使用 <code class="language-plaintext highlighter-rouge">python commit_urls.py</code> 提交网站， 该办法是通过 Git Log 获取最新一条更改信息， 并将其中与 URL 对应部分进行裁剪组合获取所需的 URLs。</p>

    <details>
      <summary> <code class="language-plaintext highlighter-rouge">commit_urls.py</code> <i class="fas fa-file-code" style="color: #ff4040;"></i></summary>

      <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="n">os</span>
  <span class="kn">import</span> <span class="n">subprocess</span>
  <span class="kn">import</span> <span class="n">requests</span>
  <span class="kn">import</span> <span class="n">json</span>

  <span class="k">def</span> <span class="nf">commit_urls</span><span class="p">():</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Submit newest URLs to Baidu and Bing</span><span class="sh">"</span><span class="p">)</span>
      <span class="n">os</span><span class="p">.</span><span class="nf">system</span><span class="p">(</span><span class="sh">"</span><span class="s">git checkout master</span><span class="sh">"</span><span class="p">)</span>
      <span class="n">urls</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="c1"># 生成url列表
</span>      <span class="n">ret</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span>
          <span class="sh">"</span><span class="s">git rev-parse --short HEAD</span><span class="sh">"</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span>
      <span class="p">)</span>
      <span class="k">if</span> <span class="n">ret</span><span class="p">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">commit_id</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">stdout</span><span class="p">,</span> <span class="sh">"</span><span class="s">utf_8</span><span class="sh">"</span><span class="p">).</span><span class="nf">strip</span><span class="p">()</span>
          <span class="n">ret</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span>
              <span class="sh">"</span><span class="s">git show --pretty=</span><span class="sh">"</span> <span class="sh">"</span><span class="s"> --name-only </span><span class="sh">"</span> <span class="o">+</span> <span class="n">commit_id</span><span class="p">,</span>
              <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span>
              <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span>
          <span class="p">)</span>
          <span class="k">if</span> <span class="n">ret</span><span class="p">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
              <span class="n">changes</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">stdout</span><span class="p">,</span> <span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">).</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">changes</span><span class="p">:</span>
                  <span class="sh">'''</span><span class="s"> 使用 Jekyll 主题直接上传源码至 Git Pages 版本
                  # change[7:] 去掉最前面的 _post/
                  change = change[7:]
                  post_name = change.split(</span><span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="s">)
                  if len(post_name) &gt; 3:
                      year = str(post_name.__getitem__(0))
                      month = str(post_name.__getitem__(1))
                      day = str(post_name.__getitem__(2))
                      if len(year) == 4 and int(year) &gt;= 2023:
                          if len(month) == 2 and int(month) &gt;= 1 and int(month) &lt;= 12:
                              if len(day) == 2 and int(day) &gt;= 1 and int(day) &lt;= 31:
                                  if change.endswith(</span><span class="sh">"</span><span class="s">.md</span><span class="sh">"</span><span class="s">):
                                      # change[:-3] 是为了去掉末尾的 .md
                                      prefix = year + </span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="s"> + month + </span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="s"> + day + </span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="s">
                                      article_path = prefix + change[len(prefix):-3]
                                      urls.append(</span><span class="sh">"</span><span class="s">https://your-site.com/{}</span><span class="sh">"</span><span class="s">.format(article_path))
                  </span><span class="sh">'''</span>
                  <span class="c1"># 文章为 .html 结尾的编译后的静态网站， 自行更改相关配置
</span>                  <span class="k">if</span> <span class="n">change</span><span class="p">.</span><span class="nf">endswith</span><span class="p">(</span><span class="sh">"</span><span class="s">.html</span><span class="sh">"</span><span class="p">):</span>
                      <span class="c1"># change[:-5] 是为了去掉末尾的 .html
</span>                      <span class="n">urls</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="sh">"</span><span class="s">https://your-site.com/{}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">change</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">]))</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">subprocess run error:{}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">stderr</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">subprocess run error:{}</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">stderr</span><span class="p">))</span>

      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Current submitted URLs:</span><span class="sh">"</span><span class="p">,</span> <span class="n">urls</span><span class="p">)</span>

      <span class="c1"># 提交到 Bing
</span>      <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
          <span class="sh">"</span><span class="s">Content-Type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">application/json; charset=utf-8</span><span class="sh">"</span><span class="p">,</span>
          <span class="sh">"</span><span class="s">Host</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">ssl.bing.com</span><span class="sh">"</span><span class="p">,</span>
      <span class="p">}</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">siteUrl</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">https://your-site.com</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">urlList</span><span class="sh">"</span><span class="p">:</span> <span class="n">urls</span><span class="p">}</span>
      <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span>
          <span class="n">url</span><span class="o">=</span><span class="sh">"</span><span class="s">https://www.bing.com/webmaster/api.svc/json/SubmitUrlbatch?apikey=your-apikey</span><span class="sh">"</span><span class="p">,</span>
          <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
          <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Bing</span><span class="sh">'</span><span class="s">s response: </span><span class="sh">"</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">content</span><span class="p">)</span>

      <span class="c1"># 提交到百度
</span>      <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
          <span class="sh">"</span><span class="s">User-Agent</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">curl/7.12.1</span><span class="sh">"</span><span class="p">,</span>
          <span class="sh">"</span><span class="s">Host</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">data.zz.baidu.com</span><span class="sh">"</span><span class="p">,</span>
          <span class="sh">"</span><span class="s">Content-Type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">text/plain</span><span class="sh">"</span>
      <span class="p">}</span>
      <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span>
          <span class="n">url</span><span class="o">=</span><span class="sh">"</span><span class="s">http://data.zz.baidu.com/urls?site=your-site.com&amp;token=your-token</span><span class="sh">"</span><span class="p">,</span>
          <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span>
          <span class="n">data</span><span class="o">=</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
      <span class="p">)</span>
      <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Baidu</span><span class="sh">'</span><span class="s">s response: </span><span class="sh">"</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">content</span><span class="p">)</span>
</code></pre></div>      </div>

    </details>

    <p>如果成功则会有类似如下的打印</p>

    <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Submit newest URLs to Baidu and Bing
  Switched to branch 'master'
  Your branch is up to date with 'origin/master'.
  Current submitted URLs: ['https://hangx-ma.github.io/2023/05/18/Jekyll-TeXt-config']
  Bing's response:  b'{"d":null}'
  Baidu's response:  b'{"remain":99,"success":1}'
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="copyright">Copyright</h2>

<p>复制博客内容的时候增加版权信息感觉也是挺有用的， 需要确认版权声明的位置， 对于文章而言， 主题内容肯定在 <code class="language-plaintext highlighter-rouge">content</code> 中。 F12 使用开发者工具可以确定 TeXt 主题的文章主题内容是在 <code class="language-plaintext highlighter-rouge">&lt;div class="page__content"&gt;</code> 中。 我在 <code class="language-plaintext highlighter-rouge">_includes/custom</code> 中创建了一个 <code class="language-plaintext highlighter-rouge">copyright.js</code> 监听版权声明， 之后只需要在 <code class="language-plaintext highlighter-rouge">_layouts/page.html</code> 中引用该 js 文件即可。 当然为了灵活处理， 可以在 <code class="language-plaintext highlighter-rouge">_config.yml</code> 增加 copyright 的开关并在引用时加入条件语句。</p>

<details>
  <summary> <code class="language-plaintext highlighter-rouge">copyright.js</code> <i class="fas fa-file-code" style="color: #ff4040;"></i></summary>

  <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">setClipboardText</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="c1">// clipboardData 对象是为通过编辑菜单、快捷菜单和快捷键执行的编辑操作所保留的，也就是你复制或者剪切内容</span>
    <span class="kd">let</span> <span class="nx">clipboardData</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">clipboardData</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">clipboardData</span><span class="p">;</span>
    <span class="c1">// 如果未复制或者未剪切，则return出去</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">clipboardData</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="nx">event</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
    <span class="c1">// Selection 对象，表示用户选择的文本范围或光标的当前位置。</span>
    <span class="c1">//     声明一个变量接收 -- 用户输入的剪切或者复制的文本转化为字符串</span>
    <span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nf">getSelection</span><span class="p">().</span><span class="nf">toString</span><span class="p">();</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果文本存在则先取消文本默认事件</span>
        <span class="nx">event</span><span class="p">.</span><span class="nf">preventDefault</span><span class="p">();</span>
        <span class="c1">// 通过调用常clipboardData对象的 setData(format, data) 方法；来设置相关文本</span>
        <span class="c1">// format: 一个DOMString 表示要添加到 drag object的拖动数据的类型。</span>
        <span class="c1">// data: 一个 DOMString表示要添加到 drag object的数据。</span>
        <span class="kd">var</span> <span class="nx">copyright</span> <span class="o">=</span> <span class="dl">'</span><span class="se">\n\n</span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="s1">Author: HangX-Ma(一只豆腐)</span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="s1">Email: m-contour@qq.com</span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="s1">Article Address: </span><span class="dl">'</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hostname</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">pathname</span>
        <span class="o">+</span> <span class="dl">'</span><span class="se">\n</span><span class="s1">Copyright Notice: </span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="s1">The copyright belongs to the author. </span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="s1">For commercial reproduction, please contact the author for authorization. </span><span class="dl">'</span>
        <span class="o">+</span> <span class="dl">'</span><span class="s1">For non-commercial reproduction, please indicate the source.</span><span class="dl">'</span>

        <span class="nx">clipboardData</span><span class="p">.</span><span class="nf">setData</span><span class="p">(</span><span class="dl">'</span><span class="s1">text/plain</span><span class="dl">'</span><span class="p">,</span> <span class="nx">text</span> <span class="o">+</span> <span class="nx">copyright</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">contents</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nf">getElementsByClassName</span><span class="p">(</span><span class="dl">"</span><span class="s2">page__content</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 监听文章内容的copy事件</span>
<span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">copy</span><span class="dl">'</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nf">setClipboardText</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>  </div>

</details>

<ul>
  <li>
    <p>通过 F12 开发者工具查阅自己的网站主题内容所属位置。</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c">&lt;!-- F12 查阅地址 --&gt;</span>
  <span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"root"</span> <span class="na">data-is-touch=</span><span class="s">"false"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"layout--page js-page-root"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page__main js-page-main page__viewport cell cell--auto"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page__main-inner"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page__header d-print-none"</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page__content"</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"page__header d-print-none"</span><span class="nt">&gt;</span>...<span class="nt">&lt;/div&gt;</span>
          <span class="nt">&lt;/div&gt;</span>
      <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>将 <code class="language-plaintext highlighter-rouge">copyright.js</code> 监听 javascript 文件在 head 中引用。</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c">&lt;!-- _layouts/page.html 底部增添 copyright.js --&gt;</span>
  ...
  {%- if page.copyright -%}
  <span class="nt">&lt;script&gt;</span>
  <span class="p">{</span><span class="o">%-</span> <span class="nx">include</span> <span class="nx">custom</span><span class="o">/</span><span class="nx">copyright</span><span class="p">.</span><span class="nx">js</span> <span class="o">-%</span><span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
  {%- endif -%}
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><a href="https://blog.csdn.net/qq_33430083/article/details/105626840">新手如何给Hexo博客在复制时添加版权声明</a></p>
</blockquote>

<h2 id="markdown">markdown</h2>

<h3 id="1-代码块-liquid-代码误解析">1. 代码块 Liquid 代码误解析</h3>

<p>如果页面是通过Jekyll引擎进行渲染的, 那么在文章中写了 Liquid 代码, 引擎也会将其解析。 找了一圈发现最方便的是针对块内容进行特殊的解释。 这样在 <code class="language-plaintext highlighter-rouge">{% raw %}</code> 以及 <code class="language-plaintext highlighter-rouge">{% endraw %}</code> 之间的代码就不会被解析了， 但也需要注意空白符此时也会被作为 raw 的一部分显示在代码块中。</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% raw %}
{% this %}
{% endraw %}
</code></pre></div></div>

<p>作为替代，如果 Jekyll 的版本在 4.0 及以上，也可以在 post 顶部的 YAML 区域指定：</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">render_with_liquid</span><span class="pi">:</span> <span class="kc">false</span>
<span class="nn">---</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://blog.csdn.net/qq_41437512/article/details/123031890">设置Markdown中展示Liquid(Jekyll)但不解析的方式</a><br />
<a href="https://cotes.page/posts/jekyll-code-snippet/">Jekyll 代码块展示</a></p>
</blockquote>

<h3 id="2-代码块折叠">2. 代码块折叠</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{::options parse_block_html="true" /}

<span class="nt">&lt;details&gt;&lt;summary</span> <span class="na">markdown=</span><span class="s">"span"</span><span class="nt">&gt;</span> `commit_urls.py` <span class="nt">&lt;i</span> <span class="na">class=</span><span class="s">"fas fa-file-code"</span> <span class="na">style=</span><span class="s">"color: #ff4040;"</span><span class="nt">&gt;&lt;/i&gt;&lt;/summary&gt;</span>

YOUR_CODE_HERE

<span class="nt">&lt;/details&gt;</span>

{::options parse_block_html="false" /}
</code></pre></div></div>

<blockquote>
  <p><a href="https://www.endtoend.ai/tutorial/collapsible-code-blocks/">Collapsible Code Blocks in GitHub Pages</a></p>
</blockquote>

<h2 id="个性化配置">个性化配置</h2>

<h3 id="1-back-to-top">1. Back To Top</h3>

<p>给网页增加返回顶部的功能能提供阅读的便利， 尝试过很多自己添加 js 代码的方式都没成功， 或者是中间没有过渡动画。 Github 上的一个开源的库倒是非常好用， 配置也很简单。 我在 <code class="language-plaintext highlighter-rouge">_layouts/base.html</code> 的 body 部分增加了配置代码， 毕竟所有的页面都是继承自 base， 这样这个 Back-To-Top 按钮就能全局可见了。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- _layouts/base.html --&gt;</span>
<span class="nt">&lt;body&gt;</span>
    ...
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script&gt;</span><span class="nf">addBackToTop</span><span class="p">({</span>
        <span class="na">diameter</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
        <span class="na">backgroundColor</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#FF4040</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">textColor</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#FFFFF0</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">})</span><span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/vfeskov/vanilla-back-to-top">vfeskov/vanilla-back-to-top</a>: Simple and tiny Back To Top button with no dependencies.</p>
</blockquote>

<h3 id="2-隐藏-addtoany-悬浮按钮">2. 隐藏 AddToAny 悬浮按钮</h3>

<p>摸索了有一阵子， 发现 AddToAny 的按钮实际上是通过 <code class="language-plaintext highlighter-rouge">&lt;a class="a2a_button_copy_link"&gt;&lt;/a&gt;</code> 这样的语句添加的， 那我们只需要对这些语句段进行控制就能控制 AddToAny 的按钮的隐藏和显示了。 这对于手机阅读非常重要， 读者也不希望一个特占位置的分享按钮影响阅读体验， 把它缩小成一个小三角就很优雅了。</p>

<blockquote>
  <p>主要通过切换 <code class="language-plaintext highlighter-rouge">display: block</code> 和 <code class="language-plaintext highlighter-rouge">display: none</code> 两种状态完成显示和隐藏。</p>
</blockquote>

<h3 id="3-访客与阅读统计">3. 访客与阅读统计</h3>

<p>用 “不蒜子”， 非常简易！ 只需要在 <code class="language-plaintext highlighter-rouge">_includes/footer.html</code> 中加入如下代码， 就能获得和咱一样的显示效果了。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"site-info mt-2"</span><span class="nt">&gt;</span>
      ...
      <span class="nt">&lt;div</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;script </span><span class="na">async</span> <span class="na">src=</span><span class="s">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
        <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"busuanzi_container_site_pv"</span><span class="nt">&gt;</span>
            Total <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"busuanzi_value_site_pv"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-spinner fa-pulse"</span><span class="nt">&gt;&lt;/i&gt;&lt;/span&gt;</span> views,
        <span class="nt">&lt;/span&gt;</span>
        <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"busuanzi_container_site_uv"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;span</span> <span class="na">id=</span><span class="s">"busuanzi_value_site_uv"</span><span class="nt">&gt;&lt;i</span> <span class="na">class=</span><span class="s">"fa fa-spinner fa-pulse"</span><span class="nt">&gt;&lt;/i&gt;&lt;/span&gt;</span> visitors.
        <span class="nt">&lt;/span&gt;</span>
      <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<h3 id="4-个性化页签">4. 个性化页签</h3>

<p>个性化 Tab 标签。 相信很多人都看过 Tab 标签显示突然崩溃， 然后点回去又是好的。 我创建了 <code class="language-plaintext highlighter-rouge">_include/custom/funny-title.js</code> 文件， 并在 <code class="language-plaintext highlighter-rouge">_layouts/base.html</code> 中以 script 的形式引用了该文件。 这样我的网站的 Tab 也能跟读者开个小小的玩笑了 :stuck_out_tongue_closed_eyes:。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funny-title.js</span>
<span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">OriginTitle</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">titleTime</span><span class="p">;</span>
    <span class="nb">document</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">visibilitychange</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">hidden</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">[rel="icon"]</span><span class="dl">'</span><span class="p">).</span><span class="nf">attr</span><span class="p">(</span><span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">/favicon.ico</span><span class="dl">"</span><span class="p">);</span>
            <span class="nb">document</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">╭(°A°`)╮ 页面崩溃啦 ~</span><span class="dl">'</span><span class="p">;</span>
            <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">titleTime</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">[rel="icon"]</span><span class="dl">'</span><span class="p">).</span><span class="nf">attr</span><span class="p">(</span><span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">,</span> <span class="dl">"</span><span class="s2">/favicon.ico</span><span class="dl">"</span><span class="p">);</span>
            <span class="nb">document</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">OriginTitle</span><span class="p">;</span>
            <span class="nx">titleTime</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
                <span class="nb">document</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">OriginTitle</span><span class="p">;</span>
            <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">})();</span>
</code></pre></div></div>

<h3 id="5-增加-last_modified-标签">5. 增加 last_modified 标签</h3>

<p>想给有些文章加上 <strong>最后的修改日期</strong> 以方便标识和记忆， 但这个主题的 <code class="language-plaintext highlighter-rouge">last_date</code> 的功能是在文章末尾添加一句最后修改日期， 我想自己加一个和文章日期非常像的样式， 也在文章列表中显示出来的那种。 既然之前操作过 pageview， 已经知道是在 <code class="language-plaintext highlighter-rouge">article-info.html</code> 修改文章样式， 那就模仿已有格式增加。</p>

<ul>
  <li>
    <p>增加 <code class="language-plaintext highlighter-rouge">_show_last_modified</code> 标识以判断是否显示最后修改日期。</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {%- assign _show_last_modified = include.article.last_modified -%}
</code></pre></div>    </div>
  </li>
  <li>
    <p>增加新的文章信息。</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  {%- if _show_author or _show_date or _pageview or _show_last_modified -%}
    {%- if _show_last_modified -%}
      <span class="nt">&lt;li&gt;</span>
      {%- include snippets/get-locale-string.html key='ARTICLE_DATE_FORMAT' -%}
      <span class="nt">&lt;i</span> <span class="na">class=</span><span class="s">"far fa-edit"</span><span class="nt">&gt;&lt;/i&gt;</span> <span class="nt">&lt;span&gt;</span>{{ include.article.last_modified | date: __return }}<span class="nt">&lt;/span&gt;</span>
      <span class="nt">&lt;/li&gt;</span>
    {%- endif -%}
  {%- endif -%}
</code></pre></div>    </div>
  </li>
  <li>
    <p>最后只要在想增加该信息的文章的头部增加如下样式信息就能显示了。</p>

    <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="pi">-</span> <span class="na">last_modified</span><span class="pi">:</span> <span class="s">2023-05-20</span> <span class="c1"># 需要和日期的格式一致</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="6-增加-jekyll-seo-tag">6. 增加 jekyll-seo-tag</h3>

<p>按照官网给的指导书就行 <a href="https://github.com/jekyll/jekyll-seo-tag">jekyll/jekyll-seo-tag</a>。</p>

<h3 id="7-一键代码复制">7. 一键代码复制</h3>

<p>文章倒是没咋看， 主要看 PR 的 commit 部分更改了啥自己加上了， 感觉效果还挺不错的。</p>

<blockquote>
  <p><a href="https://be-my-only.xyz/blog/TeXt-copy-to-clipboard/">为博客添加代码块一键复制功能 - Yuze Zou</a><br />
<a href="https://github.com/kitian616/jekyll-TeXt-theme/pull/218/commits">feat: copy to clipboard for code blocks #218</a></p>
</blockquote>

<h3 id="8-代码自动换行与行号设置">8. 代码自动换行与行号设置</h3>

<h4 id="自动换行">自动换行</h4>

<p>在 <code class="language-plaintext highlighter-rouge">_sass/custom.scss</code> 中加入如下代码即可。</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* auto wrap code */</span>
<span class="nt">pre</span> <span class="p">{</span>
    <span class="nl">white-space</span><span class="p">:</span> <span class="n">pre-wrap</span><span class="p">;</span>
    <span class="nl">word-wrap</span><span class="p">:</span> <span class="n">break-word</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://www.jarods.org/2001.html">让pre标签的代码块自动换行</a></p>
</blockquote>

<h4 id="代码行号设置">代码行号设置</h4>

<p>按这种方法可以对常规的 Markdown 的代码段自动显示行号， 在 <code class="language-plaintext highlighter-rouge">_config.yml</code> 中加入以下代码即可。 但这种方式会在 code 外层套上一个 table 的框， 不美观。</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># More › http://kramdown.gettalong.org/quickref.html</span>
<span class="c1"># Options › http://kramdown.gettalong.org/options.html</span>
<span class="na">kramdown</span><span class="pi">:</span>
  <span class="na">input</span><span class="pi">:</span>          <span class="s">GFM</span>
  <span class="c1"># https://github.com/jekyll/jekyll/pull/4090</span>
  <span class="na">syntax_highlighter</span><span class="pi">:</span> <span class="s">rouge</span>

  <span class="c1"># Rouge Highlighter in Kramdown › http://kramdown.gettalong.org/syntax_highlighter/rouge.html</span>
  <span class="c1"># span, block element options fall back to global</span>
  <span class="na">syntax_highlighter_opts</span><span class="pi">:</span>
    <span class="c1"># Rouge Options › https://github.com/jneen/rouge#full-options</span>
    <span class="na">default_lang</span><span class="pi">:</span> <span class="s">c</span> 
    <span class="na">css_class</span><span class="pi">:</span> <span class="s1">'</span><span class="s">highlight'</span>
    <span class="c1">#line_numbers: true # bad idea, spans don't need linenos and would inherit this option</span>
    <span class="na">span</span><span class="pi">:</span>
      <span class="na">line_numbers</span><span class="pi">:</span> <span class="kc">false</span>
    <span class="na">block</span><span class="pi">:</span>
      <span class="na">line_numbers</span><span class="pi">:</span> <span class="kc">true</span>
      <span class="na">start_line</span><span class="pi">:</span> <span class="m">1</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/Renovamen/jekyll-theme-gungnir">jekyll-theme-gungnir</a><br />
<a href="https://www.luxiyue.com/server/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AEhighlight-js%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E8%A1%8C%E5%8F%B7/">代码高亮Highlight.Js的使用以及添加行号</a><br />
<a href="https://www.wannaexpresso.com/2020/03/04/jekyll-blog-troubleshooting/">Jekyll博客搭建答疑解惑</a><br />
<a href="https://mrcn.ski/jekyll-syntax-highlighting-and-line-numbers/">Jekyll: Syntax Highlighting And Line Numbers</a><br />
<a href="https://www.drewsilcock.co.uk/proper-linenumbers">Proper line numbers with Jekyll</a><br />
<a href="https://botleg.com/stories/line-numbers-in-jekyll-code-blocks/">Line numbers in Jekyll code blocks</a><br />
<a href="https://github.com/jekyll/jekyll/issues/4619">Enabling line numbers with rouge #4619</a><br />
<a href="https://cotes.page/posts/jekyll-code-snippet/">Jekyll 代码块展示</a></p>
</blockquote>

<h3 id="9-取消滚动条但不影响滚动">9. 取消滚动条但不影响滚动</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">::webkit-scrollbar</code> 伪元素选择器，不过这个选择器只在 webkit 核心的浏览器中有效，例如 Chrome、新 Edge、Safari 等。<code class="language-plaintext highlighter-rouge">::web-kit-scrollbar</code> 可以直接选择滚动条元素，把它的 display 属性设置为 none 就可以隐藏滚动条了：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">::-webkit-scrollbar</span> <span class="p">{</span>
  <span class="nl">display</span><span class="p">:</span> <span class="nb">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">main</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100vw</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100vh</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">section</span> <span class="p">{</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p><a href="https://zxuqian.cn/css-how-to-hide-scrollbars/">CSS 如何隐藏滚动条，但不影响内容滚动</a></p>
</blockquote>]]></content><author><name>HangX-Ma</name></author><category term="Tool" /><category term="TeXt" /><summary type="html"><![CDATA[在此记录一些与 Jekyll TeXt 主题相关的配置细节， 以及问题的解决办法， 不定期更新。]]></summary></entry><entry><title type="html">cs144-sp23, Lab Checkpoint 1: stitching substrings into a byte stream</title><link href="https://hangx-ma.github.io/2023/05/14/cs144-lab1.html" rel="alternate" type="text/html" title="cs144-sp23, Lab Checkpoint 1: stitching substrings into a byte stream" /><published>2023-05-14T00:00:00+08:00</published><updated>2023-05-14T00:00:00+08:00</updated><id>https://hangx-ma.github.io/2023/05/14/cs144-lab1</id><content type="html" xml:base="https://hangx-ma.github.io/2023/05/14/cs144-lab1.html"><![CDATA[<p><a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/lab0.md">Lab Checkpoint 0: networking warmup</a> 直接写了 Markdown 记录 <strong>Networking by hand</strong> 的部分， 另外完成了 <code class="language-plaintext highlighter-rouge">ByteStream</code> 部分的框架。 而看完 Lab1 的实验要求之后， 感觉需要具体分析并厘清思路， 故而在此做一个详细的记录。
<!--more--></p>
<blockquote>
  <p><a href="https://kiprey.github.io/2021/11/cs144-lab1/">Kiprey</a> 2021 年的 Lab1 的记录给予了我帮助和启发。</p>

  <p>该实验通过打印信息进行调试会更有效， 可以自己在 <code class="language-plaintext highlighter-rouge">test</code> 文件中增加自己的测试样例。</p>
</blockquote>

<ul>
  <li>CS144 Spring 2023 实验仓库 <a href="https://github.com/CS144/minnow">CS144/minnow</a>， 备份为 <a href="https://github.com/HangX-Ma/minnow">HangX-Ma/minnow</a> 进行版本回退即可。</li>
  <li>CS144 Spring 2023 Lab1 项目指导书 - <a href="https://github.com/HangX-Ma/cs144-sp23/blob/main/assignment-notes/check1.pdf">Lab Checkpoint 1: stitching substrings into a byte stream</a></li>
  <li>具体的项目实现在个人的 <a href="https://github.com/HangX-Ma/cs144-sp23">Github</a>。</li>
</ul>

<h2 id="1-实验说明">1. 实验说明</h2>

<div align="center">
    <img src="/norobots/images/2023-05-14-cs144-lab1/cs144_lab_structure.png" alt="CS144 Labs'structure" width="800" />
    <br />
    <font size="2" color="#999"><u>CS144 Labs'structure</u></font>
</div>

<p>Lab1 的实验需要完成 <code class="language-plaintext highlighter-rouge">ByteStream</code> 外部的 <code class="language-plaintext highlighter-rouge">StreamReassembler</code> 部分。 Transmission Control Protocol (TCP) 的传输实现是一种可靠的顺序字节流， 尽管底层网络是以 <em>“best effort”</em> 的形式在进行报文的传输。 这意味着在报文传输的过程中， 数据包中的信息很可能会丢失、 重排、 替换、 或者重复。 这需要 TCP 为数据包提供可靠的底层逻辑。</p>

<p>TCP 的发送端会将字节流分割成短的 <code class="language-plaintext highlighter-rouge">segments</code>， 因此这些数据能够契合报文的容量需求。 但正如前述所说， 底层网络可能会使得这些 <code class="language-plaintext highlighter-rouge">segments</code> 变得不那么可靠， 因而 <code class="language-plaintext highlighter-rouge">StreamReassembler</code> 部分需要实现的， 就是在发送端确保发送的数据是连续的字节流。</p>

<h2 id="2-要求">2. 要求</h2>

<p><code class="language-plaintext highlighter-rouge">StreamReassembler</code> 需要遵循一定的规则。 starter code 中提供了两个公有函数对接口进行了一定的限制。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Insert a new substring to be reassembled into a ByteStream.</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">,</span> 
            <span class="kt">bool</span> <span class="n">is_last_substring</span><span class="p">,</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">output</span> <span class="p">);</span>
<span class="c1">// How many bytes are stored in the Reassembler itself?</span>
<span class="kt">uint64_t</span> <span class="n">bytes_pending</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>

<p>另外， 根据实验说明， 原则上 <code class="language-plaintext highlighter-rouge">Reassembler</code> 需要处理以下几种情况：</p>

<ul>
  <li>获取的字节流正好是 <code class="language-plaintext highlighter-rouge">ByteStream</code> 所需的下一组字节， 需要将这些字节直接用 <code class="language-plaintext highlighter-rouge">Writer</code> 写入到 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的缓存中。</li>
  <li><code class="language-plaintext highlighter-rouge">ByteStream</code> 很有可能也会存满， 此时若有一部分字节完成 <code class="language-plaintext highlighter-rouge">Reassembler</code> 处理需要传递给 <code class="language-plaintext highlighter-rouge">ByteStream</code>， 则该部分也需要缓存， 实际上就是该部分也需要占用 <code class="language-plaintext highlighter-rouge">Reassembler</code> 内部的缓存空间， 这个内部的缓存空间就是 <em>unassembled</em> 的部分。</li>
  <li>当收到的字节流能够符合当前的空余空间但在在其更早的字节却不存在的时候 （也就是数据传输产生了空洞， 不连续） 需要将当前收到的字节流在 <code class="language-plaintext highlighter-rouge">Reassembler</code> 中进行缓存。</li>
  <li><code class="language-plaintext highlighter-rouge">Reassembler</code> 会丢弃那些超出当前空余空间的字节。 并且， 传入 <code class="language-plaintext highlighter-rouge">Reassembler</code> 中的子列 （substring） 可能会存在重复以及重叠， 或者有一部分已经被存入 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的缓存中， 这些情况都需要考虑并进行处理。</li>
</ul>

<p>关于存储空间指导书给了下图的提示。</p>

<div align="center">
    <img src="/norobots/images/2023-05-14-cs144-lab1/bytestream_space_interpretation.png" alt="Memory usage limitation of Reassembler and ByteStream" width="800" />
    <br />
    <font size="2" color="#999"><u>Memory usage limitation of Reassembler and ByteStream</u></font>
</div>

<p><code class="language-plaintext highlighter-rouge">Reassembler</code> 与 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的内存上限是之前 Lab0 中规定的 <code class="language-plaintext highlighter-rouge">capacity</code> 的大小。 对于 <code class="language-plaintext highlighter-rouge">Reassembler</code> 而言， <code class="language-plaintext highlighter-rouge">capacity = first_unacceptable_index - first_unpopped_index</code>。 <code class="language-plaintext highlighter-rouge">ByteStream</code> 相对于 <code class="language-plaintext highlighter-rouge">Reassembler</code> 更为底层， 位于网络收发的端口， 负责实际的收发工作。 所以对于途中的几个 <em>first</em> 开头的索引其具备如下含义：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">first_unpopped_index</code>： 已经排序整理且验证正确的部分的起始索引， 这部分（绿色区块）存储在 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的缓存中等待发送。</li>
  <li><code class="language-plaintext highlighter-rouge">first_unassembled_index</code>： 尚未排序的整理验证的部分， 可称其为子列 （substrings）的起始索引， 这部分（红色区块）存储在 <code class="language-plaintext highlighter-rouge">Reassembler</code> 的内部缓存区域。</li>
  <li><code class="language-plaintext highlighter-rouge">first_unacceptable_index</code>： 需要被丢弃的部分的起始索引。</li>
</ul>

<h2 id="3-实现思路">3. 实现思路</h2>

<p>依据 <code class="language-plaintext highlighter-rouge">Memory usage limitation of Reassembler and ByteStream</code> 图中所示的几个 <em>index</em>， 其中最为关键的两个应当是 <code class="language-plaintext highlighter-rouge">first_unpopped_index</code> 和 <code class="language-plaintext highlighter-rouge">first_unacceptable_index</code>。 框架程序提供的两个方法函数是不够用的， 我们需要定义几个私有变量以便存储关键信息：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unassembled_index_</code>： 表示 <code class="language-plaintext highlighter-rouge">first_unassembled_index</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">unassembled_substrings_</code>： 表示 <em>unassembled</em> 部分的缓存集， 为 <em>map</em> 类型， 可以将存储的 <em>first_index</em> 与其对应的 <em>data</em> 进行映射， 并提高查找速度。</li>
  <li><code class="language-plaintext highlighter-rouge">is_closed_</code>： 表示接受端已收到最后一节 <em>substring</em>， 并且 <code class="language-plaintext highlighter-rouge">pending_buffer_</code> 也已清空， 此时应当终止此次数据的接收。</li>
</ul>

<p>另外也对框架代码所给的两个函数的变量与功能进行说明：</p>

<ol>
  <li>
    <p><strong>insert</strong></p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">,</span> 
         <span class="kt">bool</span> <span class="n">is_last_substring</span><span class="p">,</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">output</span> <span class="p">);</span>
</code></pre></div>    </div>

    <p>传输 <em>substring</em> 至 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的主体方法， 包含大部分逻辑实现。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">first_index</code>： <em>substring</em> 数据的第一个 index， 需要和上述 <code class="language-plaintext highlighter-rouge">unassembled_index_</code> 进行区分。</li>
      <li><code class="language-plaintext highlighter-rouge">data</code>： 需要进行传输的 <em>substring</em> 数据。</li>
      <li><code class="language-plaintext highlighter-rouge">is_last_substring</code>： 最后一条 <em>substring</em> 的标志变量。</li>
      <li><code class="language-plaintext highlighter-rouge">output</code>： <code class="language-plaintext highlighter-rouge">ByteStream</code> 中实现的 <code class="language-plaintext highlighter-rouge">Writer</code> 类， 将数据写入（push）传输缓存， 这部分信息会被远端的 <code class="language-plaintext highlighter-rouge">Reader</code> 类导出(pop)接收。</li>
    </ul>
  </li>
  <li>
    <p><strong>bytes_pending</strong></p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">uint64_t</span> <span class="n">bytes_pending</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>剩余仍存留在 <code class="language-plaintext highlighter-rouge">unassembler</code> 缓存部分的数据大小， 该部分和 <code class="language-plaintext highlighter-rouge">[first_unassembled_index, first_unacceptable_index]</code> 区间的 <code class="language-plaintext highlighter-rouge">available_capability</code> 毫无关系， 需要区分。 <code class="language-plaintext highlighter-rouge">available_capability</code> 表示当前能够接收的 <code class="language-plaintext highlighter-rouge">substring</code> 最大的大小。</p>
  </li>
</ol>

<h3 id="30-符号说明与特殊处理">3.0 符号说明与特殊处理</h3>

<h4 id="符号说明">符号说明</h4>

<ul>
  <li>重叠部分： 以 <code class="language-plaintext highlighter-rouge">=</code> 表示子列和存于 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中或已传入 <code class="language-plaintext highlighter-rouge">ByteStream</code> 中的数据重叠的 <em>index</em>。</li>
  <li>当前数据： 以 <code class="language-plaintext highlighter-rouge">&gt;</code> 表示当前数据。</li>
  <li>front数据： 以 <code class="language-plaintext highlighter-rouge">F</code> 表示与当前数据最邻近的保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中的那段数据， 这段数据的 <em>first_index</em> 比当前传入数据的 <em>first_index</em> 要小。</li>
  <li>rear数据： 以 <code class="language-plaintext highlighter-rouge">R</code> 表示与当前数据最邻近的保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中的那段数据， 这段数据的 <em>first_index</em> 比当前传入数据的 <em>first_index</em> 要大。</li>
</ul>

<h4 id="特殊情况">特殊情况</h4>

<p>对于特殊情况可以跳过后续繁琐的处理逻辑， 加快处理速度。 对于传入的 <em>substring</em> 而言， 有如下几种特殊情况可以跳过处理直接返回：</p>

<ul>
  <li><strong>数据重复</strong>， 这意味着 <code class="language-plaintext highlighter-rouge">first_index + data.size() - 1 &lt; unassembled_index_</code>， 传入的 <em>substring</em> 已经是 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的一部分， 无需重复传输数据。</li>
  <li><strong>缓存不足</strong>， <code class="language-plaintext highlighter-rouge">first_index_ &gt;= unassembled_substrings_ + available_capability</code>， 相当于 <code class="language-plaintext highlighter-rouge">first_index</code> 处于 <code class="language-plaintext highlighter-rouge">first_unacceptable_index</code> 之后的区间， 意味着该 <em>substring</em> 需要被丢弃。 或者 <em><code class="language-plaintext highlighter-rouge">available_capability == 0</code></em>， 此时已经没有空间用于处理。</li>
  <li><strong>空子列</strong>， <em>substring</em> 传入的 data 的大小为零。</li>
</ul>

<h3 id="31-unassembled_index_--first_index">3.1 unassembled_index_ &gt;= first_index</h3>

<p>这意味着此时传入的 substring 的一部分是已经传入 <code class="language-plaintext highlighter-rouge">ByteStream</code> 中的， 或者全都已经传入了 <code class="language-plaintext highlighter-rouge">ByteStream</code>。 还有可能有一部分和已经在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中缓存的数据重叠， 那么重叠的部分就需要被丢弃。</p>

<ul>
  <li>
    <p>部分重叠</p>

    <p>这种情况和有 <code class="language-plaintext highlighter-rouge">rear</code> 部分的处理会差不多， 所以在代码实现上做了整合， 实时细节在 <a href="#32-unassembled_index_--first_index">3.2</a> 节讨论， 唯一有区别的就是在此时需要截断 <code class="language-plaintext highlighter-rouge">[first_index, unassembled_index_]</code> 之间的数据。</p>

    <p>进行截断后的数据是从 <code class="language-plaintext highlighter-rouge">unassembled_index</code> 起始的， 需要检查截断后的 <em>data</em> 的长度， 若截断后的 <em>data</em> 的长度超过了 <em>available_capability</em> 那么需要取 <code class="language-plaintext highlighter-rouge">min(data.size() - overlapped_length, available_capability())</code>。</p>

    <pre><code class="language-txt">      first_index  unassembled_index_
          v                v      REPEATED_IN_MAP
  --------+----------------+-----------+---+------+------
          |================|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|===|RRRRRR|      
  --------+----------------+-----------+---+------+------
                                                  ^
                                      first_index + data.size() - 1
</code></pre>

    <pre><code class="language-txt">      first_index  unassembled_index_
          v                v      REPEATED_IN_MAP
  --------+----------------+-----------+---+------+------
          |================|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|===|&gt;&gt;&gt;&gt;&gt;&gt;|      
  --------+----------------+-----------+---+------+------
                                                  ^
                                      first_index + data.size() - 1
</code></pre>
  </li>
  <li>
    <p>全部重叠</p>

    <p>这种情况是部分重叠的特殊子集， 已经在特殊情况中处理掉了。</p>

    <pre><code class="language-txt">      first_index     unassembled_index_
          v                   v
  --------+-------------------+--------------------------
          |===================|           ...            
  --------+-------------------+--------------------------
                              ^
                  first_index + data.size() - 1
</code></pre>
  </li>
</ul>

<h3 id="32-unassembled_index_--first_index">3.2 unassembled_index_ &lt; first_index</h3>

<p>在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中的数据有些是连续的， 有些则不是连续的， 我们在保存数据的时候是以当前要保存的 <em>data</em> 与该 <em>data</em> 的 <em>first_index</em> 值进行映射的。 那么， 最复杂的情况是， 当前的这段数据正好恰在两段已缓存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 之间。 这种情况也是需要进行数据截断的， 当前数据可能会超出最大索引值的范围， 这种情况发生在 <code class="language-plaintext highlighter-rouge">first_index + data.size() - 1 &gt; unassembled_index_ + cap - 1</code> 的时候。</p>

<ol>
  <li>
    <p>讨论传入数据的 <em>first_index</em> 比保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中最邻近的数据的 <em>fisrt_index</em> 小的那部分数据。 可将 <em>index</em> 值较大段的数据称为_rear_index_， 当前数据的 <em>index</em> 仍称作 <em>first_index</em>。 可通过 <code class="language-plaintext highlighter-rouge">map::lower_bound(first_index)</code> 获取大于等于 <code class="language-plaintext highlighter-rouge">first_index</code> 的迭代器。</p>

    <ul>
      <li>
        <p>没有重叠</p>

        <p>则当前的 <em>substring</em> 可以直接保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中， 无需做额外的处理， 判断 <code class="language-plaintext highlighter-rouge">first_index + data.size() - 1 &lt; rear_index</code> 即可。</p>

        <pre><code class="language-txt">                      first_index  rear_index
                          v            v
  ----------------------- +----+-------+-------------------+-----------------
                          |&gt;&gt;&gt;&gt;|       |RRRRRRRRRRRRRRRRRRR|       ...
  ----------------------- +----+-------+-------------------+-----------------
                               ^                           ^
                  first_index + data.size() - 1    rear_index + rear_data.size() - 1
</code></pre>
      </li>
      <li>
        <p>部分重叠， 与 <a href="#31-unassembled_index_--first_index">3.1</a> 节中的情况类似， 需要截断当前的 <em>substring</em> 重复的部分即可， 若截断 <code class="language-plaintext highlighter-rouge">rear</code> 部分重复的数据， 则还需要重新更新 <code class="language-plaintext highlighter-rouge">unassemble_substrings_</code>， 效率不高。 需要满足 <code class="language-plaintext highlighter-rouge">first_index + data.size() - 1 &lt; rear_index + rear_data.size() - 1</code> 的条件， 否则就会变成全部重叠的情况。 此时的重叠部分长度就是 <code class="language-plaintext highlighter-rouge">first_index + data.size() - rear_index</code>。</p>

        <pre><code class="language-txt">              first_index  rear_index
                  v           v
  ----------------+-----------+-------+-----------------------+-------------
                  |&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|=======|RRRRRRRRRRRRRRRRRRRRRRR|    ...
  ----------------+-----------+-------+-----------------------+-------------
                                      ^                       ^
                          first_index + data.size() - 1  rear_index + rear_data.size() - 1
</code></pre>
      </li>
      <li>
        <p>全部重叠
  以 <code class="language-plaintext highlighter-rouge">rear</code> 存在全部重叠为例， 这种情况就直接将 <code class="language-plaintext highlighter-rouge">rear</code> 从 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中移除即可。</p>

        <p>需要注意处理完一个最邻近的 <em>substring</em> 后， 可能新的最邻近的 <em>substring</em> 也需要进行处理， 这一般发生在 <em>substring</em> 产生全部重叠的时候， 这能确保当前保存的 <em>substring</em> 的正确性。 更新迭代器时需要更新为 <code class="language-plaintext highlighter-rouge">map::lower_bound(rear_index + rear_data.size() - 1)</code>， 才能跨过当前的 <code class="language-plaintext highlighter-rouge">rear</code> 找到 <code class="language-plaintext highlighter-rouge">next_rear</code> 继续进行处理， <code class="language-plaintext highlighter-rouge">next_rear</code> 也可能还在当前的 <em>data</em> 的覆盖范围。</p>
      </li>
    </ul>

    <pre><code class="language-txt">             first_index  rear_index
                 v           v
 ----------------+-----------+-------+------------+---+------+-------------
                 |&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|=======|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;?????&gt;&gt;&gt;&gt;&gt;&gt;|    ...
 ----------------+-----------+-------+------------+---+------+-------------
                                     ^                       ^
                         rear_index + rear_data.size() - 1  first_index + data.size() - 1
</code></pre>
  </li>
  <li>
    <p>讨论当前传入数据与保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中 <em>first_index</em> 比当前数据的 <em>first_index</em> 小的最邻近那部分数据的关系。 可将 <em>index</em> 较小段的数据称为 <em>front_index</em>， 当前数据的 <em>index</em> 仍称作 <code class="language-plaintext highlighter-rouge">first_index</code>。 与 <code class="language-plaintext highlighter-rouge">rear</code> 不同的是， 最多只有一个 <code class="language-plaintext highlighter-rouge">front</code> 数据存在。 若 <code class="language-plaintext highlighter-rouge">map::lower_bound(first_index)</code> 得到的迭代器不是 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 的头部， 说明存在 <code class="language-plaintext highlighter-rouge">front</code>， 只需要将该位置所在的迭代器向前更新一步即可。 相较从头向后扫描查找与 <code class="language-plaintext highlighter-rouge">front</code> 重叠， 这种办法仅需一次操作即可完成。</p>

    <ul>
      <li>
        <p>没有重叠</p>

        <p>则当前的 <em>substring</em> 可以直接保存在 <code class="language-plaintext highlighter-rouge">unassembled_substrings_</code> 中， 无需做额外的处理。</p>

        <pre><code class="language-txt">  unassembled_index_  front_index   first_index
          v              v            v
  --------+--------------+----+-------+-------------------+-----------------
          |              |FFFF|       |&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|       ...
  --------+--------------+----+-------+-------------------+-----------------
                              ^                           ^
                  front_index + front_data.size() - 1    first_index + data.size() - 1
</code></pre>
      </li>
      <li>
        <p>部分重叠</p>

        <p>与 <a href="#31-unassembled_index_--first_index">3.1</a> 节中的情况类似， 只需要截断当前的 <em>substring</em> 重复的部分即可， 也可以截断 <code class="language-plaintext highlighter-rouge">front</code> 重复的部分。</p>

        <pre><code class="language-txt">  unassembled_index_  front_index  first_index  
          v              v            v
  --------+--------------+------------+---+---------------+-----------------
          |              |FFFFFFFFFFFF|===|&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;|       ...
  --------+--------------+------------+---+---------------+-----------------
                                          ^               ^
                                              first_index + data.size() - 1
                              front_index + front_data.size() - 1
</code></pre>
      </li>
      <li>
        <p>全部重叠</p>

        <p>此时的处理会和 <code class="language-plaintext highlighter-rouge">rear</code> 部分有所区别， 调用 <code class="language-plaintext highlighter-rouge">erase</code> 处理 <em>data</em> 时是从前向后， 而 <code class="language-plaintext highlighter-rouge">rear</code> 是从后向前。</p>

        <pre><code class="language-txt">              front_index  first_index
                  v           v
  ----------------+-----------+-------+-----------------------+-------------
                  |FFFFFFFFFFF|=======|FFFFFFFFFFFFFFFFFFFFFFF|    ...
  ----------------+-----------+-------+-----------------------+-------------
                                      ^                       ^
                          first_index + data.size() - 1  front_index + front_data.size() - 1
</code></pre>
      </li>
    </ul>
  </li>
</ol>

<h3 id="33-补充">3.3 补充</h3>

<p>最后将数据加入 <code class="language-plaintext highlighter-rouge">map</code> 缓存的时候需要特别判断 <code class="language-plaintext highlighter-rouge">data.size() &gt; 0</code>， 因为在之前的处理中很可能 <em>data</em> 已经没有实际数据存在了， 这样就不需要将这部分数据放到 <code class="language-plaintext highlighter-rouge">map</code> 结构中。 除此之外， 在调用 <code class="language-plaintext highlighter-rouge">output.push</code> 的时候需要判断前后的 <code class="language-plaintext highlighter-rouge">output.bytes_pushed</code> 的情况， 很可能有一部分数据并没有被传入 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的缓存中， 需要我们手动将这部分数据再保存在 <code class="language-plaintext highlighter-rouge">map</code> 中， 但不要忘了调用 <code class="language-plaintext highlighter-rouge">erase</code> 将之前的 push 不完整的那段数据从 <code class="language-plaintext highlighter-rouge">map</code> 中删除。 在遍历 <code class="language-plaintext highlighter-rouge">map</code> 查找可以传入 <code class="language-plaintext highlighter-rouge">ByteStream</code> 的数据的时候， 一旦发现 <em>unassembled_index</em> 和获取的 <code class="language-plaintext highlighter-rouge">sub_index</code> 不一致了， 就可以直接跳出循环， 这意味着数据已经不连续了， 没有必要继续数据传递的进程了。</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">reassembler_win.cc</code> 测试不通过， 可能是迭代器更新不对， 以及 <code class="language-plaintext highlighter-rouge">lower_bound</code> 可能用了 <code class="language-plaintext highlighter-rouge">upper_bound</code> 没找到对应的位置。</p>

  <p><code class="language-plaintext highlighter-rouge">reassembler_speed_test.cc</code> 测试发现读取和写入数据不一致， 可能就是没有考虑 push 时仅有一部分数据被传入了 <code class="language-plaintext highlighter-rouge">ByteStream</code> 而导致数据丢失。</p>
</blockquote>

<h2 id="4-测试结果">4. 测试结果</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cs144@cs144-ubuntu22:~/cs144-sp23/minnow<span class="nv">$ </span>cmake <span class="nt">--build</span> build <span class="nt">--target</span> check1
Test project /home/cs144/cs144-sp23/minnow/build
      Start  1: compile with bug-checkers
 1/17 Test  <span class="c">#1: compile with bug-checkers ........   Passed    4.03 sec</span>
      Start  3: byte_stream_basics
 2/17 Test  <span class="c">#3: byte_stream_basics ...............   Passed    0.02 sec</span>
      Start  4: byte_stream_capacity
 3/17 Test  <span class="c">#4: byte_stream_capacity .............   Passed    0.03 sec</span>
      Start  5: byte_stream_one_write
 4/17 Test  <span class="c">#5: byte_stream_one_write ............   Passed    0.03 sec</span>
      Start  6: byte_stream_two_writes
 5/17 Test  <span class="c">#6: byte_stream_two_writes ...........   Passed    0.02 sec</span>
      Start  7: byte_stream_many_writes
 6/17 Test  <span class="c">#7: byte_stream_many_writes ..........   Passed    0.06 sec</span>
      Start  8: byte_stream_stress_test
 7/17 Test  <span class="c">#8: byte_stream_stress_test ..........   Passed    0.03 sec</span>
      Start  9: reassembler_single
 8/17 Test  <span class="c">#9: reassembler_single ...............   Passed    0.02 sec</span>
      Start 10: reassembler_cap
 9/17 Test <span class="c">#10: reassembler_cap ..................   Passed    0.02 sec</span>
      Start 11: reassembler_seq
10/17 Test <span class="c">#11: reassembler_seq ..................   Passed    0.03 sec</span>
      Start 12: reassembler_dup
11/17 Test <span class="c">#12: reassembler_dup ..................   Passed    0.04 sec</span>
      Start 13: reassembler_holes
12/17 Test <span class="c">#13: reassembler_holes ................   Passed    0.02 sec</span>
      Start 14: reassembler_overlapping
13/17 Test <span class="c">#14: reassembler_overlapping ..........   Passed    0.02 sec</span>
      Start 15: reassembler_win
14/17 Test <span class="c">#15: reassembler_win ..................   Passed    0.30 sec</span>
      Start 16: compile with optimization
15/17 Test <span class="c">#16: compile with optimization ........   Passed    1.57 sec</span>
      Start 17: byte_stream_speed_test
             ByteStream throughput: 2.26 Gbit/s
16/17 Test <span class="c">#17: byte_stream_speed_test ...........   Passed    0.25 sec</span>
      Start 18: reassembler_speed_test
             Reassembler throughput: 8.10 Gbit/s
17/17 Test <span class="c">#18: reassembler_speed_test ...........   Passed    0.36 sec</span>

100% tests passed, 0 tests failed out of 17

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>   6.87 sec
Built target check1
</code></pre></div></div>]]></content><author><name>HangX-Ma</name></author><category term="Course" /><category term="cs144" /><summary type="html"><![CDATA[Lab Checkpoint 0: networking warmup 直接写了 Markdown 记录 Networking by hand 的部分， 另外完成了 ByteStream 部分的框架。 而看完 Lab1 的实验要求之后， 感觉需要具体分析并厘清思路， 故而在此做一个详细的记录。]]></summary></entry></feed>